<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   xiic.c File Reference
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.5 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>xiic.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Contains required functions for the <a class="el" href="struct_x_iic.html">XIic</a> component. See xiic.h for more information on the driver.<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who  Date     Changes
 ----- --- ------- -----------------------------------------------
 1.01a rfp  10/19/01 release
 1.01c ecm  12/05/02 new rev
 1.01c rmm  05/14/03 Fixed diab compiler warnings relating to asserts.
 1.01d jhl  10/08/03 Added general purpose output feature
 1.02a jvb  12/13/05 Added CfgInitialize(), and made CfgInitialize() take
                     a pointer to a config structure instead of a device id.
                     Moved Initialize() into <a class="el" href="xiic__sinit_8c.html">xiic_sinit.c</a>, and have
                     Initialize() call CfgInitialize() after it retrieved the
                     config structure using the device id. Removed include of
                     xparameters.h along with any dependencies on xparameters.h
                     and the _g.c config table.
 1.02a mta  03/09/06 Added a new function XIic_IsIicBusy() which returns
			whether IIC Bus is Busy or Free.
 1.13a wgr  03/22/07 Converted to new coding style.
 1.15a ktn  02/17/09 Fixed <a class="el" href="xiic_8c.html#bd6fde309d7c3dc05dd1d809825e6cb6">XIic_GetAddress()</a> to return correct device address.
 1.16a ktn  07/18/09 Updated the notes in XIic_Reset function to clearly
                     indicate that only the Interrupt Registers are reset.
 1.16a ktn  10/16/09 Updated the notes in the <a class="el" href="xiic__selftest_8c.html#a2b7a4414d0b12788ae5554b4de76c8a">XIic_SelfTest()</a> API to mention
                     that the complete IIC core is Reset on giving a software
                     reset to the IIC core. This issue is fixed in the latest
                     version of the IIC core (some previous versions of the
                     core only reset the Interrupt Logic/Registers), please
		      see the Hw specification for further information.
 2.00a ktn  10/22/09 Converted all register accesses to 32 bit access.
		      Some of the macros have been renamed to remove _m from
		      the name see the <a class="el" href="xiic__i_8h.html">xiic_i.h</a> and <a class="el" href="xiic__l_8h.html">xiic_l.h</a> file for further
		      information (Example XIic_mClearIntr is now
		      XIic_ClearIntr).
		      Some of the macros have been renamed to be consistent,
		      see the <a class="el" href="xiic__l_8h.html">xiic_l.h</a> file for further information
		      (Example XIIC_WRITE_IIER is renamed as XIic_WriteIier).
		      The driver has been updated to use the HAL APIs/macros.
 2.07a adk   18/04/13 Updated the code to avoid unused variable warnings 
			  when compiling with the -Wextra -Wall flags. 
			  Changes done if files <a class="el" href="xiic_8c.html">xiic.c</a> and <a class="el" href="xiic__i_8h.html">xiic_i.h</a>. CR:705001.</pre><p>
<pre> </pre> 
<p>
<code>#include &quot;xiic.h&quot;</code><br>
<code>#include &quot;<a class="el" href="xiic__i_8h.html">xiic_i.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8c.html#383d0669747cfc0b64d40b802e5cb122">XIic_CfgInitialize</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, <a class="el" href="struct_x_iic___config.html">XIic_Config</a> *Config, u32 EffectiveAddr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8c.html#0ab2b5201b6bab7711edda1b8a5ef2bc">XIic_Start</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8c.html#a4bb38c3c1185e2028131ed6952479e4">XIic_Stop</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8c.html#00a38e8a079f27e032d84f5fb3ca05f0">XIic_Reset</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8c.html#683f960be0a370cd8f64fd8ee8933fe7">XIic_SetAddress</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, int AddressType, int Address)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8c.html#bd6fde309d7c3dc05dd1d809825e6cb6">XIic_GetAddress</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, int AddressType)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8c.html#8fa669aa0c6bee8fc25951dc2a9c6317">XIic_SetGpOutput</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, u8 OutputValue)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8c.html#e29ddcee26b7472b6d8f095e9e6ac11e">XIic_GetGpOutput</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, u8 *OutputValuePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8c.html#4ddb170927afd52c798850e344dd0f18">XIic_IsSlave</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8c.html#9e532df7fc12c4bb891be3ce8a052102">XIic_SetRecvHandler</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, void *CallBackRef, XIic_Handler FuncPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8c.html#2bcd94e6dfc7ff6ecfb88b2d91ca1696">XIic_SetSendHandler</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, void *CallBackRef, XIic_Handler FuncPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8c.html#2ce3c741743e31d0ad30b0d95f537882">XIic_SetStatusHandler</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, void *CallBackRef, XIic_StatusHandler FuncPtr)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="383d0669747cfc0b64d40b802e5cb122"></a><!-- doxytag: member="xiic.c::XIic_CfgInitialize" ref="383d0669747cfc0b64d40b802e5cb122" args="(XIic *InstancePtr, XIic_Config *Config, u32 EffectiveAddr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XIic_CfgInitialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct_x_iic___config.html">XIic_Config</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Config</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>EffectiveAddr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializes a specific <a class="el" href="struct_x_iic.html">XIic</a> instance. The initialization entails:<p>
<ul>
<li>Initialize the driver to allow access to the device registers and initialize other subcomponents necessary for the operation of the device.</li><li>Default options to:<ul>
<li>7-bit slave addressing</li><li>Send messages as a slave device</li><li>Repeated start off</li><li>General call recognition disabled</li></ul>
</li><li>Clear messageing and error statistics</li></ul>
<p>
The <a class="el" href="xiic_8c.html#0ab2b5201b6bab7711edda1b8a5ef2bc">XIic_Start()</a> function must be called after this function before the device is ready to send and receive data on the IIC bus.<p>
Before <a class="el" href="xiic_8c.html#0ab2b5201b6bab7711edda1b8a5ef2bc">XIic_Start()</a> is called, the interrupt control must connect the ISR routine to the interrupt handler. This is done by the user, and not <a class="el" href="xiic_8c.html#0ab2b5201b6bab7711edda1b8a5ef2bc">XIic_Start()</a> to allow the user to use an interrupt controller of their choice.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Config</em>&nbsp;</td><td>is a reference to a structure containing information about a specific IIC device. This function can initialize multiple instance objects with the use of multiple calls giving different Config information on each call. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the device base address in the virtual memory address space. The caller is responsible for keeping the address mapping from EffectiveAddr to the device physical base address unchanged once this function is invoked. Unexpected errors may occur if the address mapping changes after this function is called. If address translation is not used, use Config-&gt;BaseAddress for this parameters, passing the physical address instead.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS when successful</li><li>XST_DEVICE_IS_STARTED indicates the device is started (i.e. interrupts enabled and messaging is possible). Must stop before re-initialization is allowed.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="bd6fde309d7c3dc05dd1d809825e6cb6"></a><!-- doxytag: member="xiic.c::XIic_GetAddress" ref="bd6fde309d7c3dc05dd1d809825e6cb6" args="(XIic *InstancePtr, int AddressType)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u16 XIic_GetAddress           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>AddressType</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function gets the addresses for the IIC device driver. The addresses include the device address that the device responds to as a slave, or the slave address to communicate with on the bus. The address returned has the same format whether 7 or 10 bits.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressType</em>&nbsp;</td><td>indicates which address, the address which this responds to on the IIC bus as a slave, or the slave address to communicate with when this device is a master. One of the following values must be contained in this argument. <pre>
   XII_ADDR_TO_SEND_TYPE	Slave being addressed as a master
   XII_ADDR_TO_RESPOND_TYPE	Slave address to respond to as a slave
 </pre> If neither of the two valid arguments are used, the function returns the address of the slave device</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The address retrieved.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="e29ddcee26b7472b6d8f095e9e6ac11e"></a><!-- doxytag: member="xiic.c::XIic_GetGpOutput" ref="e29ddcee26b7472b6d8f095e9e6ac11e" args="(XIic *InstancePtr, u8 *OutputValuePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XIic_GetGpOutput           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>OutputValuePtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function gets the contents of the General Purpose Output register for the IIC device driver. Note that the number of bits in this register is parameterizable in the hardware such that it may not exist. This function checks to ensure that it does exist to prevent bus errors.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OutputValuePtr</em>&nbsp;</td><td>contains the value which was read from the register.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the given data is read from the GPO register.</li><li>XST_NO_FEATURE if the hardware is configured such that this register does not contain any bits to read or write.</li></ul>
</dd></dl>
The OutputValuePtr is also an output as it contains the value read.<p>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4ddb170927afd52c798850e344dd0f18"></a><!-- doxytag: member="xiic.c::XIic_IsSlave" ref="4ddb170927afd52c798850e344dd0f18" args="(XIic *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u32 XIic_IsSlave           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A function to determine if the device is currently addressed as a slave.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the device is addressed as slave.</li><li>FALSE if the device is NOT addressed as slave.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="00a38e8a079f27e032d84f5fb3ca05f0"></a><!-- doxytag: member="xiic.c::XIic_Reset" ref="00a38e8a079f27e032d84f5fb3ca05f0" args="(XIic *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XIic_Reset           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Resets the IIC device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The complete IIC core is Reset on giving a software reset to the IIC core. Some previous versions of the core only reset the Interrupt Logic/Registers, please refer to the HW specification for futher details about this. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="683f960be0a370cd8f64fd8ee8933fe7"></a><!-- doxytag: member="xiic.c::XIic_SetAddress" ref="683f960be0a370cd8f64fd8ee8933fe7" args="(XIic *InstancePtr, int AddressType, int Address)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XIic_SetAddress           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>AddressType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Address</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function sets the bus addresses. The addresses include the device address that the device responds to as a slave, or the slave address to communicate with on the bus. The IIC device hardware is built to allow either 7 or 10 bit slave addressing only at build time rather than at run time. When this device is a master, slave addressing can be selected at run time to match addressing modes for other bus devices.<p>
Addresses are represented as hex values with no adjustment for the data direction bit as the software manages address bit placement. Example: For a 7 address written to the device of 1010 011X where X is the transfer direction (send/recv), the address parameter for this function needs to be 01010011 or 0x53 where the correct bit alllignment will be handled for 7 as well as 10 bit devices. This is especially important as the bit placement is not handled the same depending on which options are used such as repeated start.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressType</em>&nbsp;</td><td>indicates which address is being modified, the address which this device responds to on the IIC bus as a slave, or the slave address to communicate with when this device is a master. One of the following values must be contained in this argument. <pre>
   XII_ADDR_TO_SEND_TYPE	Slave being addressed by a this master
   XII_ADDR_TO_RESPOND_TYPE	Address to respond to as a slave device
 </pre></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Address</em>&nbsp;</td><td>contains the address to be set, 7 bit or 10 bit address. A ten bit address must be within the range: 0 - 1023 and a 7 bit address must be within the range 0 - 127.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS is returned if the address was successfully set.</li><li>XST_IIC_NO_10_BIT_ADDRESSING indicates only 7 bit addressing supported.</li><li>XST_INVALID_PARAM indicates an invalid parameter was specified.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
Upper bits of 10-bit address is written only when current device is built as a ten bit device.     </td>
  </tr>
</table>
<a class="anchor" name="8fa669aa0c6bee8fc25951dc2a9c6317"></a><!-- doxytag: member="xiic.c::XIic_SetGpOutput" ref="8fa669aa0c6bee8fc25951dc2a9c6317" args="(XIic *InstancePtr, u8 OutputValue)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XIic_SetGpOutput           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8&nbsp;</td>
          <td class="mdname" nowrap> <em>OutputValue</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function sets the contents of the General Purpose Output register for the IIC device driver. Note that the number of bits in this register is parameterizable in the hardware such that it may not exist. This function checks to ensure that it does exist to prevent bus errors, but does not ensure that the number of bits in the register are sufficient for the value being written (won't cause a bus error).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OutputValue</em>&nbsp;</td><td>contains the value to be written to the register.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the given data is written to the GPO register.</li><li>XST_NO_FEATURE if the hardware is configured such that this register does not contain any bits to read or write.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="9e532df7fc12c4bb891be3ce8a052102"></a><!-- doxytag: member="xiic.c::XIic_SetRecvHandler" ref="9e532df7fc12c4bb891be3ce8a052102" args="(XIic *InstancePtr, void *CallBackRef, XIic_Handler FuncPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XIic_SetRecvHandler           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>XIic_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>FuncPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the receive callback function, the receive handler, which the driver calls when it finishes receiving data. The number of bytes used to signal when the receive is complete is the number of bytes set in the XIic_Recv function.<p>
The handler executes in an interrupt context such that it must minimize the amount of processing performed such as transferring data to a thread context.<p>
The number of bytes received is passed to the handler as an argument.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the upper layer callback reference passed back when the callback function is invoked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FuncPtr</em>&nbsp;</td><td>is the pointer to the callback function.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The handler is called within interrupt context . </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="2bcd94e6dfc7ff6ecfb88b2d91ca1696"></a><!-- doxytag: member="xiic.c::XIic_SetSendHandler" ref="2bcd94e6dfc7ff6ecfb88b2d91ca1696" args="(XIic *InstancePtr, void *CallBackRef, XIic_Handler FuncPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XIic_SetSendHandler           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>XIic_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>FuncPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the send callback function, the send handler, which the driver calls when it receives confirmation of sent data. The handler executes in an interrupt context such that it must minimize the amount of processing performed such as transferring data to a thread context.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>the pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>the upper layer callback reference passed back when the callback function is invoked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FuncPtr</em>&nbsp;</td><td>the pointer to the callback function.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The handler is called within interrupt context . </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="2ce3c741743e31d0ad30b0d95f537882"></a><!-- doxytag: member="xiic.c::XIic_SetStatusHandler" ref="2ce3c741743e31d0ad30b0d95f537882" args="(XIic *InstancePtr, void *CallBackRef, XIic_StatusHandler FuncPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XIic_SetStatusHandler           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>XIic_StatusHandler&nbsp;</td>
          <td class="mdname" nowrap> <em>FuncPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the status callback function, the status handler, which the driver calls when it encounters conditions which are not data related. The handler executes in an interrupt context such that it must minimize the amount of processing performed such as transferring data to a thread context. The status events that can be returned are described in xiic.h.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>points to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the upper layer callback reference passed back when the callback function is invoked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FuncPtr</em>&nbsp;</td><td>is the pointer to the callback function.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The handler is called within interrupt context . </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="0ab2b5201b6bab7711edda1b8a5ef2bc"></a><!-- doxytag: member="xiic.c::XIic_Start" ref="0ab2b5201b6bab7711edda1b8a5ef2bc" args="(XIic *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XIic_Start           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function starts the IIC device and driver by enabling the proper interrupts such that data may be sent and received on the IIC bus. This function must be called before the functions to send and receive data.<p>
Before <a class="el" href="xiic_8c.html#0ab2b5201b6bab7711edda1b8a5ef2bc">XIic_Start()</a> is called, the interrupt control must connect the ISR routine to the interrupt handler. This is done by the user, and not <a class="el" href="xiic_8c.html#0ab2b5201b6bab7711edda1b8a5ef2bc">XIic_Start()</a> to allow the user to use an interrupt controller of their choice.<p>
Start enables:<ul>
<li>IIC device</li><li>Interrupts:<ul>
<li>Addressed as slave to allow messages from another master</li><li>Arbitration Lost to detect Tx arbitration errors</li><li>Global IIC interrupt</li></ul>
</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XST_SUCCESS always.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
The device interrupt is connected to the interrupt controller, but no "messaging" interrupts are enabled. Addressed as Slave is enabled to reception of messages when this devices address is written to the bus. The correct messaging interrupts are enabled when sending or receiving via the IicSend() and IicRecv() functions. No action is required by the user to control any IIC interrupts as the driver completely manages all 8 interrupts. Start and Stop control the ability to use the device. Stopping the device completely stops all device interrupts from the processor.     </td>
  </tr>
</table>
<a class="anchor" name="a4bb38c3c1185e2028131ed6952479e4"></a><!-- doxytag: member="xiic.c::XIic_Stop" ref="a4bb38c3c1185e2028131ed6952479e4" args="(XIic *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XIic_Stop           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function stops the IIC device and driver such that data is no longer sent or received on the IIC bus. This function stops the device by disabling interrupts. This function only disables interrupts within the device such that the caller is responsible for disconnecting the interrupt handler of the device from the interrupt source and disabling interrupts at other levels.<p>
Due to bus throttling that could hold the bus between messages when using repeated start option, stop will not occur when the device is actively sending or receiving data from the IIC bus or the bus is being throttled by this device, but instead return XST_IIC_BUS_BUSY.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS indicates all IIC interrupts are disabled. No messages can be received or transmitted until <a class="el" href="xiic_8c.html#0ab2b5201b6bab7711edda1b8a5ef2bc">XIic_Start()</a> is called.</li><li>XST_IIC_BUS_BUSY indicates this device is currently engaged in message traffic and cannot be stopped.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
Copyright @ 1995-2014 Xilinx, Inc. All rights reserved. 
