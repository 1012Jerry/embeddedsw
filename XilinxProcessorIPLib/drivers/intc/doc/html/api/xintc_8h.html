<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver intc v3_2: xintc.h File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xintc.h File Reference</h1><code>#include &quot;xil_types.h&quot;</code><br/>
<code>#include &quot;xil_assert.h&quot;</code><br/>
<code>#include &quot;xparameters.h&quot;</code><br/>
<code>#include &quot;xstatus.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="xintc__l_8h.html">xintc_l.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_intc___config.html">XIntc_Config</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_intc.html">XIntc</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#a9e07373b9cba0eafcb65c0dd23f6a4ab">XINTC_H</a></td></tr>
<tr><td colspan="2"><div class="groupHeader">Configuration options</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp50f33d14f129e4548c1c270fd6725a78"></a> These options are used in <a class="el" href="xintc_8h.html#a1f0d32716f082a51a751df84312c7d56">XIntc_SetOptions()</a> to configure the device. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#af4bce8e2035f391b702686e49c66c839">XIN_SVC_SGL_ISR_OPTION</a>&nbsp;&nbsp;&nbsp;1UL</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#ad043237f658e83b2e8718ddddab12545">XIN_SVC_ALL_ISRS_OPTION</a>&nbsp;&nbsp;&nbsp;2UL</td></tr>
<tr><td colspan="2"><div class="groupHeader">Start modes</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp2d7bf383fe0e07a1b3b2b96df842c92b"></a> One of these values is passed to <a class="el" href="xintc_8c.html#a863eb58a3ae9419c7ac5da7c9fa9cb50">XIntc_Start()</a> to start the device. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#aefd5527cecdc1a6444b624d1e1a2514f">XIN_SIMULATION_MODE</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#a56b4aa3cb483ea5c882e2e36a4800af2">XIN_REAL_MODE</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td colspan="2"><div class="groupHeader">Masks to specify Interrupt Controller Mode</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpa4e591bea084233ab72f7f88affe5edc"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#a6787fa567536384f6133b8ce90cf22f1">XIN_INTC_NOCASCADE</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#ad8c8fd384185ceae0a8abe0cd8d4c638">XIN_INTC_PRIMARY</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#a35bc775ed0e234d9b069700f4825cd7d">XIN_INTC_SECONDARY</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#a3805fe4c0c209acc349242d75600646b">XIN_INTC_LAST</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mask to specify maximum number of interrupt sources per controller</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp68a567109e24df56bd3d80182f4f76ac"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#a842aea1f6663265412f5618f102e8f18">XIN_CONTROLLER_MAX_INTRS</a>&nbsp;&nbsp;&nbsp;32</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#aa7adc53d40c41e1a714ef8857329043d">XIntc_Initialize</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr, u16 DeviceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#a863eb58a3ae9419c7ac5da7c9fa9cb50">XIntc_Start</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr, u8 Mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#afabb05cf2e5b62031524a33d1f88f405">XIntc_Stop</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#aee9ec5873a764994d64b4da35a110084">XIntc_Connect</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr, u8 Id, XInterruptHandler Handler, void *CallBackRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#a8f7caaeb26b6b264fffefbd32f90f855">XIntc_Disconnect</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr, u8 Id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#ac7f59192d3b3ba2e2283a264677577b8">XIntc_Enable</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr, u8 Id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#aea44ec361097925f2994558d402988ab">XIntc_Disable</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr, u8 Id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#a8604653ac3a24bbb49c5fecb6a9ebfc7">XIntc_Acknowledge</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr, u8 Id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_intc___config.html">XIntc_Config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#ab2da07d4eeab07ac1ef67d56af1e1cb7">XIntc_LookupConfig</a> (u16 DeviceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#a24a344d15b12b8acd82cd4c49a020d74">XIntc_ConnectFastHandler</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr, u8 Id, <a class="el" href="xintc__l_8h.html#ab333e5826535071fe60f13b70b6e56dd">XFastInterruptHandler</a> Handler)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#a881154092f4f8cd5e29a71b284f7b2ae">XIntc_SetNormalIntrMode</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr, u8 Id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#a9c6dc6e838193da3ce51c8cdb3b88943">XIntc_VoidInterruptHandler</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#a635187ed756cee70b4b4051560cbd7bc">XIntc_InterruptHandler</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#a1f0d32716f082a51a751df84312c7d56">XIntc_SetOptions</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr, u32 Options)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#a6fdbe96b1db87f0c78e68da8bc767a69">XIntc_GetOptions</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#af9a9a16180b363930d21bc94dfe71147">XIntc_SelfTest</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc_8h.html#a17972363ab5a1a8f5f1d135c5b3c22c7">XIntc_SimulateIntr</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr, u8 Id)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a842aea1f6663265412f5618f102e8f18"></a><!-- doxytag: member="xintc.h::XIN_CONTROLLER_MAX_INTRS" ref="a842aea1f6663265412f5618f102e8f18" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_CONTROLLER_MAX_INTRS&nbsp;&nbsp;&nbsp;32</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3805fe4c0c209acc349242d75600646b"></a><!-- doxytag: member="xintc.h::XIN_INTC_LAST" ref="a3805fe4c0c209acc349242d75600646b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_INTC_LAST&nbsp;&nbsp;&nbsp;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6787fa567536384f6133b8ce90cf22f1"></a><!-- doxytag: member="xintc.h::XIN_INTC_NOCASCADE" ref="a6787fa567536384f6133b8ce90cf22f1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_INTC_NOCASCADE&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad8c8fd384185ceae0a8abe0cd8d4c638"></a><!-- doxytag: member="xintc.h::XIN_INTC_PRIMARY" ref="ad8c8fd384185ceae0a8abe0cd8d4c638" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_INTC_PRIMARY&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a35bc775ed0e234d9b069700f4825cd7d"></a><!-- doxytag: member="xintc.h::XIN_INTC_SECONDARY" ref="a35bc775ed0e234d9b069700f4825cd7d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_INTC_SECONDARY&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a56b4aa3cb483ea5c882e2e36a4800af2"></a><!-- doxytag: member="xintc.h::XIN_REAL_MODE" ref="a56b4aa3cb483ea5c882e2e36a4800af2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_REAL_MODE&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Real mode, no simulation allowed, hardware interrupts recognized </p>

</div>
</div>
<a class="anchor" id="aefd5527cecdc1a6444b624d1e1a2514f"></a><!-- doxytag: member="xintc.h::XIN_SIMULATION_MODE" ref="aefd5527cecdc1a6444b624d1e1a2514f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_SIMULATION_MODE&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Simulation only mode, no hardware interrupts recognized </p>

</div>
</div>
<a class="anchor" id="ad043237f658e83b2e8718ddddab12545"></a><!-- doxytag: member="xintc.h::XIN_SVC_ALL_ISRS_OPTION" ref="ad043237f658e83b2e8718ddddab12545" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_SVC_ALL_ISRS_OPTION&nbsp;&nbsp;&nbsp;2UL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af4bce8e2035f391b702686e49c66c839"></a><!-- doxytag: member="xintc.h::XIN_SVC_SGL_ISR_OPTION" ref="af4bce8e2035f391b702686e49c66c839" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_SVC_SGL_ISR_OPTION&nbsp;&nbsp;&nbsp;1UL</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<pre>
 XIN_SVC_SGL_ISR_OPTION	Service the highest priority pending interrupt
				and then return.
 XIN_SVC_ALL_ISRS_OPTION	Service all of the pending interrupts and then
				return.
 </pre>
</div>
</div>
<a class="anchor" id="a9e07373b9cba0eafcb65c0dd23f6a4ab"></a><!-- doxytag: member="xintc.h::XINTC_H" ref="a9e07373b9cba0eafcb65c0dd23f6a4ab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XINTC_H</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a8604653ac3a24bbb49c5fecb6a9ebfc7"></a><!-- doxytag: member="xintc.h::XIntc_Acknowledge" ref="a8604653ac3a24bbb49c5fecb6a9ebfc7" args="(XIntc *InstancePtr, u8 Id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_Acknowledge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acknowledges the interrupt source provided as the argument Id. When the interrupt is acknowledged, it causes the interrupt controller to clear its interrupt condition.In Cascade mode, acknowledges corresponding interrupt source of Slave controllers depending on the Id.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_intc.html">XIntc</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Id</em>&nbsp;</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_INTC_MAX_NUM_INTR_INPUTS - 1 with 0 being the highest priority interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aee9ec5873a764994d64b4da35a110084"></a><!-- doxytag: member="xintc.h::XIntc_Connect" ref="aee9ec5873a764994d64b4da35a110084" args="(XIntc *InstancePtr, u8 Id, XInterruptHandler Handler, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIntc_Connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XInterruptHandler&nbsp;</td>
          <td class="paramname"> <em>Handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Makes the connection between the Id of the interrupt source and the associated handler that is to run when the interrupt is recognized. The argument provided in this call as the Callbackref is used as the argument for the handler when it is called. In Cascade mode, connects handler to Slave controller handler table depending on the interrupt Id.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_intc.html">XIntc</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Id</em>&nbsp;</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_INTC_MAX_NUM_INTR_INPUTS - 1 with 0 being the highest priority interrupt. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Handler</em>&nbsp;</td><td>to the handler for that interrupt. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the callback reference, usually the instance pointer of the connecting driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<ul>
<li>XST_SUCCESS if the handler was connected correctly.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>WARNING: The handler provided as an argument will overwrite any handler that was previously connected. </p>

</div>
</div>
<a class="anchor" id="a24a344d15b12b8acd82cd4c49a020d74"></a><!-- doxytag: member="xintc.h::XIntc_ConnectFastHandler" ref="a24a344d15b12b8acd82cd4c49a020d74" args="(XIntc *InstancePtr, u8 Id, XFastInterruptHandler Handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIntc_ConnectFastHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xintc__l_8h.html#ab333e5826535071fe60f13b70b6e56dd">XFastInterruptHandler</a>&nbsp;</td>
          <td class="paramname"> <em>Handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Makes the connection between the Id of the interrupt source and the associated handler that is to run when the interrupt is recognized.In Cascade mode, connects handler to corresponding Slave controller IVAR register depending on the Id and sets all interrupt sources of the Slave controller as fast interrupts.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_intc.html">XIntc</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Id</em>&nbsp;</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_INTC_MAX_NUM_INTR_INPUTS - 1 with 0 being the highest priority interrupt. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Handler</em>&nbsp;</td><td>to the handler for that interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Slave controllers in Cascade Mode should have all as Fast interrupts or Normal interrupts, mixed interrupts are not supported</dd></dl>
<p>WARNING: The handler provided as an argument will overwrite any handler that was previously connected. </p>

</div>
</div>
<a class="anchor" id="aea44ec361097925f2994558d402988ab"></a><!-- doxytag: member="xintc.h::XIntc_Disable" ref="aea44ec361097925f2994558d402988ab" args="(XIntc *InstancePtr, u8 Id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_Disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disables the interrupt source provided as the argument Id such that the interrupt controller will not cause interrupts for the specified Id. The interrupt controller will continue to hold an interrupt condition for the Id, but will not cause an interrupt.In Cascade mode, disables corresponding interrupt of Slave controllers depending on the Id.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_intc.html">XIntc</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Id</em>&nbsp;</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_INTC_MAX_NUM_INTR_INPUTS - 1 with 0 being the highest priority interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f7caaeb26b6b264fffefbd32f90f855"></a><!-- doxytag: member="xintc.h::XIntc_Disconnect" ref="a8f7caaeb26b6b264fffefbd32f90f855" args="(XIntc *InstancePtr, u8 Id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_Disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Updates the interrupt table with the Null Handler and NULL arguments at the location pointed at by the Id. This effectively disconnects that interrupt source from any handler. The interrupt is disabled also. In Cascade mode, disconnects handler from Slave controller handler table depending on the interrupt Id.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_intc.html">XIntc</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Id</em>&nbsp;</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_INTC_MAX_NUM_INTR_INPUTS - 1 with 0 being the highest priority interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7f59192d3b3ba2e2283a264677577b8"></a><!-- doxytag: member="xintc.h::XIntc_Enable" ref="ac7f59192d3b3ba2e2283a264677577b8" args="(XIntc *InstancePtr, u8 Id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enables the interrupt source provided as the argument Id. Any pending interrupt condition for the specified Id will occur after this function is called. In Cascade mode, enables corresponding interrupt of Slave controllers depending on the Id.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_intc.html">XIntc</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Id</em>&nbsp;</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_INTC_MAX_NUM_INTR_INPUTS - 1 with 0 being the highest priority interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a6fdbe96b1db87f0c78e68da8bc767a69"></a><!-- doxytag: member="xintc.h::XIntc_GetOptions" ref="a6fdbe96b1db87f0c78e68da8bc767a69" args="(XIntc *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XIntc_GetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the currently set options.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_intc.html">XIntc</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The currently set options. The options are described in <a class="el" href="xintc_8h.html">xintc.h</a>.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7adc53d40c41e1a714ef8857329043d"></a><!-- doxytag: member="xintc.h::XIntc_Initialize" ref="aa7adc53d40c41e1a714ef8857329043d" args="(XIntc *InstancePtr, u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIntc_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize a specific interrupt controller instance/driver. The initialization entails:</p>
<ul>
<li>Initialize fields of the <a class="el" href="struct_x_intc.html">XIntc</a> structure</li>
<li>Initial vector table with stub function calls</li>
<li>All interrupt sources are disabled</li>
<li>Interrupt output is disabled</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_intc.html">XIntc</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the unique id of the device controlled by this <a class="el" href="struct_x_intc.html">XIntc</a> instance. Passing in a device id associates the generic <a class="el" href="struct_x_intc.html">XIntc</a> instance to a specific device, as chosen by the caller or application developer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if initialization was successful</li>
<li>XST_DEVICE_IS_STARTED if the device has already been started</li>
<li>XST_DEVICE_NOT_FOUND if device configuration information was not found for a device with the supplied device ID.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>In Cascade mode this function calls XIntc_InitializeSlaves to initialiaze Slave Interrupt controllers. </dd></dl>

</div>
</div>
<a class="anchor" id="a635187ed756cee70b4b4051560cbd7bc"></a><!-- doxytag: member="xintc.h::XIntc_InterruptHandler" ref="a635187ed756cee70b4b4051560cbd7bc" args="(XIntc *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_InterruptHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Interrupt handler for the driver used when there can be no argument passed to the handler. This function is provided mostly for backward compatibility. The user should use <a class="el" href="xintc__l_8c.html#ace91a1aeaf1a88e1b769decb4ac4a818">XIntc_DeviceInterruptHandler()</a>, defined in <a class="el" href="xintc__l_8c.html">xintc_l.c</a>, if possible.</p>
<p>The user must connect this function to the interrupt system such that it is called whenever the devices which are connected to it cause an interrupt.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>The constant XPAR_INTC_SINGLE_DEVICE_ID must be defined for this handler to be included in the driver compilation.</p>
<p>The interrupt handler for the driver. This function is provided mostly for backward compatibility. The user should use <a class="el" href="xintc__l_8c.html#ace91a1aeaf1a88e1b769decb4ac4a818">XIntc_DeviceInterruptHandler()</a>, defined in <a class="el" href="xintc__l_8c.html">xintc_l.c</a> when possible and pass the device ID of the interrupt controller device as its argument.</p>
<p>The user must connect this function to the interrupt system such that it is called whenever the devices which are connected to it cause an interrupt.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_intc.html">XIntc</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2da07d4eeab07ac1ef67d56af1e1cb7"></a><!-- doxytag: member="xintc.h::XIntc_LookupConfig" ref="ab2da07d4eeab07ac1ef67d56af1e1cb7" args="(u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_intc___config.html">XIntc_Config</a>* XIntc_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks up the device configuration based on the unique device ID. A table contains the configuration info for each device in the system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the unique identifier for a device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the <a class="el" href="struct_x_intc.html">XIntc</a> configuration structure for the specified device, or NULL if the device was not found.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="af9a9a16180b363930d21bc94dfe71147"></a><!-- doxytag: member="xintc.h::XIntc_SelfTest" ref="af9a9a16180b363930d21bc94dfe71147" args="(XIntc *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIntc_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Run a self-test on the driver/device. This is a destructive test.</p>
<p>This involves forcing interrupts into the controller and verifying that they are recognized and can be acknowledged. This test will not succeed if the interrupt controller has been started in real mode such that interrupts cannot be forced.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_intc.html">XIntc</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if self-test is successful.</li>
<li>XST_INTC_FAIL_SELFTEST if the Interrupt controller fails the self-test. It will fail the self test if the device has previously been started in real mode.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a881154092f4f8cd5e29a71b284f7b2ae"></a><!-- doxytag: member="xintc.h::XIntc_SetNormalIntrMode" ref="a881154092f4f8cd5e29a71b284f7b2ae" args="(XIntc *InstancePtr, u8 Id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_SetNormalIntrMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the normal interrupt mode for the specified interrupt in the Interrupt Mode Register. In Cascade mode disconnects handler from corresponding Slave controller IVAR register depending on the Id and sets all interrupt sources of the Slave controller as normal interrupts.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_intc.html">XIntc</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Id</em>&nbsp;</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_INTC_MAX_NUM_INTR_INPUTS - 1 with 0 being the highest priority interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Slave controllers in Cascade Mode should have all as Fast interrupts or Normal interrupts, mixed interrupts are not supported </dd></dl>

</div>
</div>
<a class="anchor" id="a1f0d32716f082a51a751df84312c7d56"></a><!-- doxytag: member="xintc.h::XIntc_SetOptions" ref="a1f0d32716f082a51a751df84312c7d56" args="(XIntc *InstancePtr, u32 Options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIntc_SetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the options for the interrupt controller driver. In Cascade mode same Option is set to Slave controllers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_intc.html">XIntc</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Options</em>&nbsp;</td><td>to be set. The available options are described in <a class="el" href="xintc_8h.html">xintc.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the options were set successfully</li>
<li>XST_INVALID_PARAM if the specified option was not valid</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a17972363ab5a1a8f5f1d135c5b3c22c7"></a><!-- doxytag: member="xintc.h::XIntc_SimulateIntr" ref="a17972363ab5a1a8f5f1d135c5b3c22c7" args="(XIntc *InstancePtr, u8 Id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIntc_SimulateIntr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allows software to simulate an interrupt in the interrupt controller. This function will only be successful when the interrupt controller has been started in simulation mode. Once it has been started in real mode, interrupts cannot be simulated. A simulated interrupt allows the interrupt controller to be tested without any device to drive an interrupt input signal into it. In Cascade mode writes to ISR of appropraite Slave controller depending on Id.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_intc.html">XIntc</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Id</em>&nbsp;</td><td>is the interrupt ID for which to simulate an interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful</li>
<li>XST_FAILURE if the interrupt could not be simulated because the interrupt controller is or has previously been in real mode.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a863eb58a3ae9419c7ac5da7c9fa9cb50"></a><!-- doxytag: member="xintc.h::XIntc_Start" ref="a863eb58a3ae9419c7ac5da7c9fa9cb50" args="(XIntc *InstancePtr, u8 Mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIntc_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Starts the interrupt controller by enabling the output from the controller to the processor. Interrupts may be generated by the interrupt controller after this function is called.</p>
<p>It is necessary for the caller to connect the interrupt handler of this component to the proper interrupt source. This function also starts Slave controllers in Cascade mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_intc.html">XIntc</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mode</em>&nbsp;</td><td>determines if software is allowed to simulate interrupts or real interrupts are allowed to occur. Note that these modes are mutually exclusive. The interrupt controller hardware resets in a mode that allows software to simulate interrupts until this mode is exited. It cannot be reentered once it has been exited.</td></tr>
  </table>
  </dd>
</dl>
<p>One of the following values should be used for the mode.</p>
<ul>
<li>XIN_SIMULATION_MODE enables simulation of interrupts only</li>
<li>XIN_REAL_MODE enables hardware interrupts only</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the device was started successfully</li>
<li>XST_FAILURE if simulation mode was specified and it could not be set because real mode has already been entered.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Must be called after <a class="el" href="struct_x_intc.html">XIntc</a> initialization is completed. </dd></dl>

</div>
</div>
<a class="anchor" id="afabb05cf2e5b62031524a33d1f88f405"></a><!-- doxytag: member="xintc.h::XIntc_Stop" ref="afabb05cf2e5b62031524a33d1f88f405" args="(XIntc *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stops the interrupt controller by disabling the output from the controller so that no interrupts will be caused by the interrupt controller.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_intc.html">XIntc</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c6dc6e838193da3ce51c8cdb3b88943"></a><!-- doxytag: member="xintc.h::XIntc_VoidInterruptHandler" ref="a9c6dc6e838193da3ce51c8cdb3b88943" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_VoidInterruptHandler </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
