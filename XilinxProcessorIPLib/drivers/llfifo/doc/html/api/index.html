<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   llfifo v4_0
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.5 -->
<div class="tabs">
  <ul>
    <li id="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>llfifo v4_0</h1>
<p>
The Xilinx Dual Channel Fifo driver component. This driver supports the Virtex-5(TM) and Virtex-4(TM) XPS_ll_Fifo and the AxiFifo.<p>
For a full description of the bridge features, please see the HW spec. This driver supports the following features:<ul>
<li>Memory mapped access to host interface registers</li><li>API for polled frame transfers</li><li>API for interrupt driven frame transfers</li><li>Virtual memory support</li><li>Full duplex operation</li></ul>
<p>
<h2>Driver Description</h2>
<p>
This driver enables higher layer software to access the XPS_llFifo core using any alignment in the data buffers.<p>
This driver supports send and receive channels in the same instance structure in the same fashion as the hardware core.<p>
<h2>Initialization</h2>
<p>
An instance of this driver is initialized using a call to Initialize().<p>
<h2>Usage</h2>
<p>
It is fairly simple to use the API provided by this FIFO driver. The only somewhat tricky part is that the calling code must correctly call a couple routines in the right sequence for receive and transmit.<p>
This sequence is described here. Check the routine functional descriptions for information on how to use a specific API routine.<p>
<h3>Receive</h3>
<p>
A frame is received by using the following sequence:<br>
 1) call XLlFifo_RxOccupancy() to check the occupancy count<br>
 2) call XLlFifo_RxGetLen() to get the length of the next incoming frame<br>
 3) call XLlFifo_Read() one or more times to read the number of bytes reported by XLlFifo_RxGetLen().<br>
<p>
For example: <pre>
 	while (XLlFifo_RxOccupancy(&amp;RxInstance)) {
 		frame_len = XLlFifo_RxGetLen(&amp;RxInstance);
		while (frame_len) {
 			unsigned bytes = min(sizeof(buffer), frame_len);
 			XLlFifo_Read(&amp;RxInstance, buffer, bytes);
 			// ********
 			// do something with buffer here
 			// ********
 			frame_len -= bytes;
		}
 	}
 </pre><p>
This FIFO hardware core does <b>not</b> support a sequence where the calling code calls RxGetLen() twice in a row and then receive the data for two frames. Each frame must be read in by calling RxGetLen() just prior to reading the data.<p>
<h3>Transmit</h3>
<p>
A frame is transmittted by using the following sequence:<br>
 1) call XLlFifo_Write() one or more times to write all the of bytes in the next frame.<br>
 2) call XLlFifo_TxSetLen() to begin the transmission of frame just written.<br>
<p>
For example: <pre>
 	frame_left = frame_len;
 	while (frame_left) {
 		unsigned bytes = min(sizeof(buffer), frame_left);
 		XLlFifo_Write(&amp;TxInstance, buffer, bytes);
 		// ********
 		// do something here to refill buffer
 		// ********
 		frame_left -= bytes;
 	}
 	XLlFifo_TxSetLen(&amp;RxInstance, frame_len);
 </pre><p>
This FIFO hardware core does <b>not</b> support a sequence where the calling code writes the data for two frames and then calls TxSetLen() twice in a row. Each frame must be written by writting the data for one frame and then calling TxSetLen().<p>
<h2>Interrupts</h2>
<p>
This driver does not handle interrupts from the FIFO hardware. The software layer above may make use of the interrupts by setting up its own handlers for the interrupts.<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who  Date     Changes
 ----- ---- -------- -------------------------------------------------------
 1.00a jvb  10/12/06 First release
 1.01a sdm  08/22/08 Removed support for static interrupt handlers from the
		       MDD file
 1.02a jz   12/04/09 Hal phase 1 support
 2.01a asa  09/17/10 Added code for resetting Local Link/AXI Streaming
		       interface for CR574868
 2.02a asa  12/27/11 Changed the function XStrm_Read in xtreamer.c to reset
		       HeadIndex to zero when all bytes have been read.
		       Changed the macro XStrm_IsRxInternalEmpty in file
		       xtreamer.h to use FrmByteCnt instead of HeadIndex.
		       When FrmByteCnt is zero, this means all internal buffers
		       in streamer are empty. Earlier implementation using
		       HeadIndex was not very clear and could give improper
		       results for some cases.
		       Changed the macro XLlFifo_IsRxEmpty in file xllfifo.h
		       These changes are done to fix the CR 604650.
 2.03a asa  14/08/12  Added XLLF_TDR_OFFSET, XLLF_RDR_OFFSET
		         defines for the new registers, and XLLF_INT_TFPF_MASK,
		         XLLF_INT_TFPE_MASK, XLLF_INT_RFPF_MASK and
		         XLLF_INT_RFPE_MASK for the new version of the
		         AXI4-Stream FIFO core (v2.01a and later)</pre><p>
<pre> 3.00a adk 08/10/13 Added support for AXI4 Datainterface.Changes are
 		      In <a class="el" href="xllfifo_8c.html">Xllfifo.c</a> file XLlFifo_RxGetWord,XLlFifo_TxPutword.
 		      In XLlfifo.h file updated XLlfifo structure for 
 		      Axi4BaseAddress and for Datainterface type provided 
		      polling and interrupt examples. XLlfifo_IsRxDone Macro 
		      Is added in the XLlfifo.h file for polledmode exmaple.
		      Added Static initialzation for the driver. 
		      XLlFifo_Initialize is still used to make the driver
		      backward compatible.
 4.0   adk  19/12/13 Updated as per the New Tcl API's</pre><p>
<pre> </pre> Copyright @ 1995-2014 Xilinx, Inc. All rights reserved. 
