<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>hdcp1x: Hdcp1x_v4_0</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">hdcp1x
   </div>
   <div id="projectbrief">Xilinx SDK Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Hdcp1x_v4_0</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_hdcp1x___config.html">XHdcp1x_Config</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_hdcp1x___cipher_stats.html">XHdcp1x_CipherStats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_hdcp1x___cipher.html">XHdcp1x_Cipher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_hdcp1x___port_stats.html">XHdcp1x_PortStats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_hdcp1x___repeater_exchange.html">XHdcp1x_RepeaterExchange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_hdcp1x___port_struct.html">XHdcp1x_PortStruct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_hdcp1x___tx_stats.html">XHdcp1x_TxStats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_hdcp1x___rx_stats.html">XHdcp1x_RxStats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_hdcp1x___rx_encyption_watch.html">XHdcp1x_RxEncyptionWatch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_hdcp1x___tx.html">XHdcp1x_Tx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_hdcp1x___rx.html">XHdcp1x_Rx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_hdcp1x___port_phy_if_adaptor_s.html">XHdcp1x_PortPhyIfAdaptorS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga66e1b425725213dd4d5231bf5710e04f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga66e1b425725213dd4d5231bf5710e04f">XHDCP1X_DEBUG_PRINTF</a>&#160;&#160;&#160;if (<a class="el" href="group__hdcp1x__v4__0.html#ga9edfb21b66722d61af03129b4dcbb734">XHdcp1xDebugPrintf</a> != NULL) <a class="el" href="group__hdcp1x__v4__0.html#ga9edfb21b66722d61af03129b4dcbb734">XHdcp1xDebugPrintf</a></td></tr>
<tr class="separator:ga66e1b425725213dd4d5231bf5710e04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83e87d466be18c22a62503f408c341cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga83e87d466be18c22a62503f408c341cc">XHDCP1X_DEBUG_LOGMSG</a>&#160;&#160;&#160;if (<a class="el" href="group__hdcp1x__v4__0.html#ga2c89c757bb1b6bb6c904b67afad4f624">XHdcp1xDebugLogMsg</a> != NULL) <a class="el" href="group__hdcp1x__v4__0.html#ga2c89c757bb1b6bb6c904b67afad4f624">XHdcp1xDebugLogMsg</a></td></tr>
<tr class="separator:ga83e87d466be18c22a62503f408c341cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5477e830e157f72072a2a7f470365682"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>(BaseAddress,  RegOffset)&#160;&#160;&#160;<a class="el" href="group__hdcp1x__v4__0.html#ga97852d12d6d27dbf95f755aa5e3c44e0">XHdcp1x_In32</a>((BaseAddress) + ((u32)RegOffset))</td></tr>
<tr class="separator:ga5477e830e157f72072a2a7f470365682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e356b098ccbcf8c2a851425e884ac00"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga8e356b098ccbcf8c2a851425e884ac00">XHdcp1x_WriteReg</a>(BaseAddress,  RegOffset,  Data)&#160;&#160;&#160;<a class="el" href="group__hdcp1x__v4__0.html#ga4797628ed0ce1674c0e34d410185e29c">XHdcp1x_Out32</a>((BaseAddress) + ((u32)RegOffset), (u32)(Data))</td></tr>
<tr class="separator:ga8e356b098ccbcf8c2a851425e884ac00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa99360d2e6f5cc2071ff95729c222344"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaa99360d2e6f5cc2071ff95729c222344">XHdcp1x_CipherIsEnabled</a>(InstancePtr)</td></tr>
<tr class="separator:gaa99360d2e6f5cc2071ff95729c222344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d98f541dd4fe90543190e24a4f6b5cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga9d98f541dd4fe90543190e24a4f6b5cc">XHdcp1x_CipherXorInProgress</a>(InstancePtr)</td></tr>
<tr class="separator:ga9d98f541dd4fe90543190e24a4f6b5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae90182b983742cb8e2fa091cffc83aaa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gae90182b983742cb8e2fa091cffc83aaa">XHdcp1x_CipherLocalKsvReady</a>(InstancePtr)</td></tr>
<tr class="separator:gae90182b983742cb8e2fa091cffc83aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac433f89288e18ce7be66f0871bf285e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gac433f89288e18ce7be66f0871bf285e4">XHdcp1x_CipherKmReady</a>(InstancePtr)</td></tr>
<tr class="separator:gac433f89288e18ce7be66f0871bf285e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2870575e04b7a20bca6801f47f1f2169"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga2870575e04b7a20bca6801f47f1f2169">XHdcp1x_IsDP</a>(InstancePtr)</td></tr>
<tr class="separator:ga2870575e04b7a20bca6801f47f1f2169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43765c1afc08c59a03b619d0c822e8b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga43765c1afc08c59a03b619d0c822e8b7">XHdcp1x_IsHDMI</a>(InstancePtr)</td></tr>
<tr class="separator:ga43765c1afc08c59a03b619d0c822e8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae45c2870e08ccd6d6e51409ede847c80"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gae45c2870e08ccd6d6e51409ede847c80">XHdcp1x_IsRX</a>(InstancePtr)</td></tr>
<tr class="separator:gae45c2870e08ccd6d6e51409ede847c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eb257e3b2af7d84e72e89dd93703d3d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga0eb257e3b2af7d84e72e89dd93703d3d">XHdcp1x_IsTX</a>(InstancePtr)</td></tr>
<tr class="separator:ga0eb257e3b2af7d84e72e89dd93703d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62b350f20404434a855f46c62ee888ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga62b350f20404434a855f46c62ee888ed">XHDCP1X_PORT_UINT_TO_BUF</a>(buf,  uint,  numbits)</td></tr>
<tr class="separator:ga62b350f20404434a855f46c62ee888ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b4d815c1d172e921b83f3685d54012b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga0b4d815c1d172e921b83f3685d54012b">XHDCP1X_PORT_BUF_TO_UINT</a>(uint,  buf,  numbits)</td></tr>
<tr class="separator:ga0b4d815c1d172e921b83f3685d54012b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf15471088fda7450a5b6c24c5c65e8da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaf15471088fda7450a5b6c24c5c65e8da">XHDCP1X_PORT_BSET_IN_BUF</a>(buf,  bitnum)&#160;&#160;&#160;buf[(bitnum) &gt;&gt; 3] |=  (1u &lt;&lt; ((bitnum) &amp; 0x07u));</td></tr>
<tr class="separator:gaf15471088fda7450a5b6c24c5c65e8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2baf460af0b886a5b2aedcc3085049b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gad2baf460af0b886a5b2aedcc3085049b">XHDCP1X_PORT_BCLR_IN_BUF</a>(buf,  bitnum)&#160;&#160;&#160;buf[(bitnum) &gt;&gt; 3] &amp;= ~(1u &lt;&lt; ((bitnum) &amp; 0x07u));</td></tr>
<tr class="separator:gad2baf460af0b886a5b2aedcc3085049b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae20b7b34529b50d90577913851201bf7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gae20b7b34529b50d90577913851201bf7">XHDCP1X_PORT_BTST_IN_BUF</a>(buf,  bitnum)&#160;&#160;&#160;(buf[(bitnum) &gt;&gt; 3] &amp; (1u &lt;&lt; ((bitnum) &amp; 0x07u)))</td></tr>
<tr class="separator:gae20b7b34529b50d90577913851201bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1865cffebcba3167ab0867e3a276fe12"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga1865cffebcba3167ab0867e3a276fe12">XHDCP1X_PORT_OFFSET_BKSV</a>&#160;&#160;&#160;(0x00u)</td></tr>
<tr class="separator:ga1865cffebcba3167ab0867e3a276fe12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f589bb54a9c7295aa522dcf5f25fbf7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga8f589bb54a9c7295aa522dcf5f25fbf7">XHDCP1X_PORT_SIZE_BKSV</a>&#160;&#160;&#160;(0x05u)</td></tr>
<tr class="separator:ga8f589bb54a9c7295aa522dcf5f25fbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga238771cd5536c2cf6ee36c2b300ac2bd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga238771cd5536c2cf6ee36c2b300ac2bd">XHDCP1X_PORT_BIT_BSTATUS_READY</a>&#160;&#160;&#160;(1u &lt;&lt; 0)</td></tr>
<tr class="separator:ga238771cd5536c2cf6ee36c2b300ac2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec57e0843c8887964dae8ef00c3c3634"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaec57e0843c8887964dae8ef00c3c3634">XHDCP1X_PORT_DPCD_BASE</a>&#160;&#160;&#160;(0x68000u)</td></tr>
<tr class="separator:gaec57e0843c8887964dae8ef00c3c3634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1865cffebcba3167ab0867e3a276fe12"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga1865cffebcba3167ab0867e3a276fe12">XHDCP1X_PORT_OFFSET_BKSV</a>&#160;&#160;&#160;(0x00u)</td></tr>
<tr class="separator:ga1865cffebcba3167ab0867e3a276fe12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f589bb54a9c7295aa522dcf5f25fbf7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga8f589bb54a9c7295aa522dcf5f25fbf7">XHDCP1X_PORT_SIZE_BKSV</a>&#160;&#160;&#160;(0x05u)</td></tr>
<tr class="separator:ga8f589bb54a9c7295aa522dcf5f25fbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c3f0ec04bdfb89e59ff25412971d907"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga0c3f0ec04bdfb89e59ff25412971d907">XHDCP1X_PORT_BIT_BSTATUS_HDMI_MODE</a>&#160;&#160;&#160;(1u &lt;&lt; 12)</td></tr>
<tr class="separator:ga0c3f0ec04bdfb89e59ff25412971d907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61b9d23c4ec1165434d8111157fe8e4a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga61b9d23c4ec1165434d8111157fe8e4a">XHDCP1X_PORT_PRIMARY_I2C_ADDR</a>&#160;&#160;&#160;(0x74u)</td></tr>
<tr class="separator:ga61b9d23c4ec1165434d8111157fe8e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa65e249fd6658172ea7255838d58f434"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaa65e249fd6658172ea7255838d58f434">XHdcp1x_RunDdcHandler</a>) (u8 DeviceAddress, u16 ByteCount, u8 *BufferPtr, u8 Stop, void *RefPtr)</td></tr>
<tr class="separator:gaa65e249fd6658172ea7255838d58f434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3390f77e705a54ca5639baa56743d3a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_x_hdcp1x___port_phy_if_adaptor_s.html">XHdcp1x_PortPhyIfAdaptorS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gab3390f77e705a54ca5639baa56743d3a">XHdcp1x_PortPhyIfAdaptor</a></td></tr>
<tr class="separator:gab3390f77e705a54ca5639baa56743d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga931fc14801a82c9cc3aa870d887bbc07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga931fc14801a82c9cc3aa870d887bbc07">XHdcp1x_CfgInitialize</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, const <a class="el" href="struct_x_hdcp1x___config.html">XHdcp1x_Config</a> *CfgPtr, void *PhyIfPtr, UINTPTR EffectiveAddr)</td></tr>
<tr class="separator:ga931fc14801a82c9cc3aa870d887bbc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81768260ec0f02284c294051c56e328e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga81768260ec0f02284c294051c56e328e">XHdcp1x_Poll</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga81768260ec0f02284c294051c56e328e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52caa4f761f34ccb7ad92a40a075ad1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga52caa4f761f34ccb7ad92a40a075ad1e">XHdcp1x_DownstreamReady</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga52caa4f761f34ccb7ad92a40a075ad1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6650255cee4d6285275448cfa0e5664e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga6650255cee4d6285275448cfa0e5664e">XHdcp1x_GetRepeaterInfo</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, <a class="el" href="struct_x_hdcp1x___repeater_exchange.html">XHdcp1x_RepeaterExchange</a> *RepeaterInfoPtr)</td></tr>
<tr class="separator:ga6650255cee4d6285275448cfa0e5664e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91937cd3d7e1aadbd8bb7be0f6c4fa91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga91937cd3d7e1aadbd8bb7be0f6c4fa91">XHdcp1x_SetRepeater</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u8 State)</td></tr>
<tr class="separator:ga91937cd3d7e1aadbd8bb7be0f6c4fa91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a42371924892562d7f6df80d5907a1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga5a42371924892562d7f6df80d5907a1f">XHdcp1x_Reset</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga5a42371924892562d7f6df80d5907a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72fafe0eef23bbe5dbbc07a260b8d6b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga72fafe0eef23bbe5dbbc07a260b8d6b3">XHdcp1x_Enable</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga72fafe0eef23bbe5dbbc07a260b8d6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab081c08c9cc4edb8c35c85fb27554b3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gab081c08c9cc4edb8c35c85fb27554b3e">XHdcp1x_Disable</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gab081c08c9cc4edb8c35c85fb27554b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa00a71253e9a68307ee86ebe6d70b5dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaa00a71253e9a68307ee86ebe6d70b5dc">XHdcp1x_SetPhysicalState</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, int IsUp)</td></tr>
<tr class="separator:gaa00a71253e9a68307ee86ebe6d70b5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga230854e10d59500a41137b4f5951042b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga230854e10d59500a41137b4f5951042b">XHdcp1x_SetLaneCount</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, int LaneCount)</td></tr>
<tr class="separator:ga230854e10d59500a41137b4f5951042b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga103ae62cd1207e7566bf4f39ce946f67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga103ae62cd1207e7566bf4f39ce946f67">XHdcp1x_Authenticate</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga103ae62cd1207e7566bf4f39ce946f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e1dc21a163e1e2c5281c36f23519a85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga4e1dc21a163e1e2c5281c36f23519a85">XHdcp1x_ReadDownstream</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga4e1dc21a163e1e2c5281c36f23519a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga934f616f1b538de0f90a343bc1185380"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga934f616f1b538de0f90a343bc1185380">XHdcp1x_IsInProgress</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga934f616f1b538de0f90a343bc1185380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacce89db1cfc0e9cd5c632f3499bff690"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gacce89db1cfc0e9cd5c632f3499bff690">XHdcp1x_IsAuthenticated</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gacce89db1cfc0e9cd5c632f3499bff690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad264c967aebfe269ea6e40f675886c9f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gad264c967aebfe269ea6e40f675886c9f">XHdcp1x_IsInComputations</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gad264c967aebfe269ea6e40f675886c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93df0cf3372141a9fd419a02c753196c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga93df0cf3372141a9fd419a02c753196c">XHdcp1x_IsInWaitforready</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga93df0cf3372141a9fd419a02c753196c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8389541cb1c23695221b17789eb945c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gae8389541cb1c23695221b17789eb945c">XHdcp1x_IsDwnstrmCapable</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gae8389541cb1c23695221b17789eb945c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac175508b95f7a2d101630aca5b55e8e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gac175508b95f7a2d101630aca5b55e8e5">XHdcp1x_IsEnabled</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gac175508b95f7a2d101630aca5b55e8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60f6a284a49f0e381c353180ec5bebdc"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga60f6a284a49f0e381c353180ec5bebdc">XHdcp1x_GetEncryption</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga60f6a284a49f0e381c353180ec5bebdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8d484e140ba4935f33b7fd14b9c5c2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaf8d484e140ba4935f33b7fd14b9c5c2a">XHdcp1x_IsEncrypted</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gaf8d484e140ba4935f33b7fd14b9c5c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ace40ed3ad14f22e3cce4bc8bf6249c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga7ace40ed3ad14f22e3cce4bc8bf6249c">XHdcp1x_EnableEncryption</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u64 Map)</td></tr>
<tr class="separator:ga7ace40ed3ad14f22e3cce4bc8bf6249c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad9f3acb0f7df366481d4261542ba2c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaad9f3acb0f7df366481d4261542ba2c8">XHdcp1x_DisableEncryption</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u64 Map)</td></tr>
<tr class="separator:gaad9f3acb0f7df366481d4261542ba2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga405e80474c58ef82e4c27ab99ae70f54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga405e80474c58ef82e4c27ab99ae70f54">XHdcp1x_SetKeySelect</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u8 KeySelect)</td></tr>
<tr class="separator:ga405e80474c58ef82e4c27ab99ae70f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadefd696ca95f00b16f9af353a0f7d2e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gadefd696ca95f00b16f9af353a0f7d2e8">XHdcp1x_HandleTimeout</a> (void *InstancePtr)</td></tr>
<tr class="separator:gadefd696ca95f00b16f9af353a0f7d2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2d6cb2bf146bfd87fc255200b09cd79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gac2d6cb2bf146bfd87fc255200b09cd79">XHdcp1x_SetDebugPrintf</a> (<a class="el" href="group__hdcp1x__v4__0.html#gaa14ea51a98757da9f24e489130804846">XHdcp1x_Printf</a> PrintfFunc)</td></tr>
<tr class="separator:gac2d6cb2bf146bfd87fc255200b09cd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d8820c98c821780e9cbede688cc2957"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga0d8820c98c821780e9cbede688cc2957">XHdcp1x_SetDebugLogMsg</a> (<a class="el" href="group__hdcp1x__v4__0.html#gaba9f04ac9a482bd9b3696df05868a598">XHdcp1x_LogMsg</a> LogFunc)</td></tr>
<tr class="separator:ga0d8820c98c821780e9cbede688cc2957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dc3ae5f39d71120d46f7dacf1f61b4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga4dc3ae5f39d71120d46f7dacf1f61b4e">XHdcp1x_SetKsvRevokeCheck</a> (<a class="el" href="group__hdcp1x__v4__0.html#ga268b0b51f0fc7b58d8c1e21829b52800">XHdcp1x_KsvRevokeCheck</a> RevokeCheckFunc)</td></tr>
<tr class="separator:ga4dc3ae5f39d71120d46f7dacf1f61b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab38a967494808e941831617a912b37b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gab38a967494808e941831617a912b37b4">XHdcp1x_SetTimerStart</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, <a class="el" href="group__hdcp1x__v4__0.html#ga38b1342cb63780a12f13f244c46e315f">XHdcp1x_TimerStart</a> TimerStartFunc)</td></tr>
<tr class="separator:gab38a967494808e941831617a912b37b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddaf275034b5df27dd68762192f58b78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaddaf275034b5df27dd68762192f58b78">XHdcp1x_SetTimerStop</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, <a class="el" href="group__hdcp1x__v4__0.html#gaea02f57423e496bb1bf659cd6652dd90">XHdcp1x_TimerStop</a> TimerStopFunc)</td></tr>
<tr class="separator:gaddaf275034b5df27dd68762192f58b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3aa7fcf95484728d577700eaa04f2e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaf3aa7fcf95484728d577700eaa04f2e2">XHdcp1x_SetTimerDelay</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, <a class="el" href="group__hdcp1x__v4__0.html#ga53900843854068ce4c5d0521ee9d4774">XHdcp1x_TimerDelay</a> TimerDelayFunc)</td></tr>
<tr class="separator:gaf3aa7fcf95484728d577700eaa04f2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52085c5f3ece2e12521fe526dbc7742f"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga52085c5f3ece2e12521fe526dbc7742f">XHdcp1x_GetDriverVersion</a> (void)</td></tr>
<tr class="separator:ga52085c5f3ece2e12521fe526dbc7742f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga646e74a29f8d1df441368b9c8ae27241"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga646e74a29f8d1df441368b9c8ae27241">XHdcp1x_GetVersion</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga646e74a29f8d1df441368b9c8ae27241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f8a11ce5614a2541b378f034b3198cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga7f8a11ce5614a2541b378f034b3198cb">XHdcp1x_Info</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga7f8a11ce5614a2541b378f034b3198cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bf591dc879a170beed8edc091ac018f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga8bf591dc879a170beed8edc091ac018f">XHdcp1x_ProcessAKsv</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga8bf591dc879a170beed8edc091ac018f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1030400c6c423608ffd155b9cb4d12ef"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga1030400c6c423608ffd155b9cb4d12ef">XHdcp1x_GetTopology</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga1030400c6c423608ffd155b9cb4d12ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bcdf20c5176355adb31bf0477bcaaca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga3bcdf20c5176355adb31bf0477bcaaca">XHdcp1x_DisableBlank</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga3bcdf20c5176355adb31bf0477bcaaca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78468655ea2782da93ae20bab2e9a680"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga78468655ea2782da93ae20bab2e9a680">XHdcp1x_EnableBlank</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga78468655ea2782da93ae20bab2e9a680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9abe5fb8d1b7663035ceb0250368699"><td class="memItemLeft" align="right" valign="top">u8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaf9abe5fb8d1b7663035ceb0250368699">XHdcp1x_GetTopologyKSVList</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gaf9abe5fb8d1b7663035ceb0250368699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0dc57eed89ceb400350f9d78551946e"><td class="memItemLeft" align="right" valign="top">u8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaa0dc57eed89ceb400350f9d78551946e">XHdcp1x_GetTopologyBKSV</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gaa0dc57eed89ceb400350f9d78551946e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d528cd47bdd818848c2297734fd86bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga9d528cd47bdd818848c2297734fd86bb">XHdcp1x_SetTopologyField</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, <a class="el" href="group__hdcp1x__v4__0.html#ga54976f91c0d29039065ce279b6f6d8ad">XHdcp1x_TopologyField</a> Field, u8 Value)</td></tr>
<tr class="separator:ga9d528cd47bdd818848c2297734fd86bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga410b33d14bb0883e3de81a5f784800b4"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga410b33d14bb0883e3de81a5f784800b4">XHdcp1x_GetTopologyField</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, <a class="el" href="group__hdcp1x__v4__0.html#ga54976f91c0d29039065ce279b6f6d8ad">XHdcp1x_TopologyField</a> Field)</td></tr>
<tr class="separator:ga410b33d14bb0883e3de81a5f784800b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0c5947639623f7b97d9ec1cc712e75f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gac0c5947639623f7b97d9ec1cc712e75f">XHdcp1x_IsRepeater</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gac0c5947639623f7b97d9ec1cc712e75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34d2f8270d1aaf386e38e398a590ca3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga34d2f8270d1aaf386e38e398a590ca3d">XHdcp1x_SetTopology</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, const <a class="el" href="struct_x_hdcp1x___repeater_exchange.html">XHdcp1x_RepeaterExchange</a> *TopologyPtr)</td></tr>
<tr class="separator:ga34d2f8270d1aaf386e38e398a590ca3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad21c705e369902193c9c8b0f0c44027a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gad21c705e369902193c9c8b0f0c44027a">XHdcp1x_SetTopologyKSVList</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u8 *ListPtr, u32 ListSize)</td></tr>
<tr class="separator:gad21c705e369902193c9c8b0f0c44027a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba8f1fa8b28a519d192f1183fae62344"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaba8f1fa8b28a519d192f1183fae62344">XHdcp1x_SetTopologyUpdate</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gaba8f1fa8b28a519d192f1183fae62344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14060c2be4685a3c8d0285e826a2376c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_hdcp1x___config.html">XHdcp1x_Config</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga14060c2be4685a3c8d0285e826a2376c">XHdcp1x_LookupConfig</a> (u16 DeviceId)</td></tr>
<tr class="separator:ga14060c2be4685a3c8d0285e826a2376c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga710df77b22f0b5c728a51747be26ca2e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga710df77b22f0b5c728a51747be26ca2e">XHdcp1x_SelfTest</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga710df77b22f0b5c728a51747be26ca2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga145ec2236143e47dd0bb8e31fbf690e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga145ec2236143e47dd0bb8e31fbf690e4">XHdcp1x_SetCallback</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, <a class="el" href="group__hdcp1x__v4__0.html#gaa46858c4b302cf0e3f9d59d5c5e6bbb9">XHdcp1x_HandlerType</a> HandlerType, void *CallbackFunc, void *CallbackRef)</td></tr>
<tr class="separator:ga145ec2236143e47dd0bb8e31fbf690e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73b8452615938e9aca91f3e87a959b9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga73b8452615938e9aca91f3e87a959b9d">XHdcp1x_CipherIntrHandler</a> (void *InstancePtr)</td></tr>
<tr class="separator:ga73b8452615938e9aca91f3e87a959b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac0a3b497e4974beccb2adfba3d5fa19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaac0a3b497e4974beccb2adfba3d5fa19">XHdcp1x_PortIntrHandler</a> (void *InstancePtr, u32 IntCause)</td></tr>
<tr class="separator:gaac0a3b497e4974beccb2adfba3d5fa19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga458350d13807e4d1c4d3655167ec6f03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga458350d13807e4d1c4d3655167ec6f03">XHdcp1x_CipherInit</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga458350d13807e4d1c4d3655167ec6f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40c4838c730476e98dfcd742eb1d21a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga40c4838c730476e98dfcd742eb1d21a4">XHdcp1x_CipherIsLinkUp</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga40c4838c730476e98dfcd742eb1d21a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3f73058855c8d60cbd588d74e60a668"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaa3f73058855c8d60cbd588d74e60a668">XHdcp1x_CipherEnable</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gaa3f73058855c8d60cbd588d74e60a668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ca06586dc06796fdc31a2f64096a28d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga2ca06586dc06796fdc31a2f64096a28d">XHdcp1x_CipherDisable</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga2ca06586dc06796fdc31a2f64096a28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f0a88da0a794b63e3f6caafa912dc10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga6f0a88da0a794b63e3f6caafa912dc10">XHdcp1x_CipherSetKeySelect</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u8 KeySelect)</td></tr>
<tr class="separator:ga6f0a88da0a794b63e3f6caafa912dc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad44ad72f65d851de50c40053e327ba9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gad44ad72f65d851de50c40053e327ba9e">XHdcp1x_CipherDoRequest</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, <a class="el" href="group__hdcp1x__v4__0.html#ga84500fe19b892af19bd0a2a2657b342b">XHdcp1x_CipherRequestType</a> Request)</td></tr>
<tr class="separator:gad44ad72f65d851de50c40053e327ba9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace24c74db709b523e1aae7e082494022"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gace24c74db709b523e1aae7e082494022">XHdcp1x_CipherIsRequestComplete</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gace24c74db709b523e1aae7e082494022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfeb8a266c1bc554753f93d62eb9a891"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gacfeb8a266c1bc554753f93d62eb9a891">XHdcp1x_CipherGetNumLanes</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gacfeb8a266c1bc554753f93d62eb9a891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad104aebb80bb03cb66c31eaabf21247a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gad104aebb80bb03cb66c31eaabf21247a">XHdcp1x_CipherSetNumLanes</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u32 NumLanes)</td></tr>
<tr class="separator:gad104aebb80bb03cb66c31eaabf21247a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae38ae0f74022763d8650a21fedcd15e5"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gae38ae0f74022763d8650a21fedcd15e5">XHdcp1x_CipherGetEncryption</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gae38ae0f74022763d8650a21fedcd15e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga706d8729ad07f34fad5e20f83c59d69f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga706d8729ad07f34fad5e20f83c59d69f">XHdcp1x_CipherEnableEncryption</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u64 StreamMap)</td></tr>
<tr class="separator:ga706d8729ad07f34fad5e20f83c59d69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49cf0f72f0d918e33d66ff40c91d3073"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga49cf0f72f0d918e33d66ff40c91d3073">XHdcp1x_CipherDisableEncryption</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u64 StreamMap)</td></tr>
<tr class="separator:ga49cf0f72f0d918e33d66ff40c91d3073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc166098738c7aac2703ee0cbd757c01"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gacc166098738c7aac2703ee0cbd757c01">XHdcp1x_CipherGetLocalKsv</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gacc166098738c7aac2703ee0cbd757c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d260acd4a5eb9842f5a4bbb31be0e36"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga9d260acd4a5eb9842f5a4bbb31be0e36">XHdcp1x_CipherGetRemoteKsv</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga9d260acd4a5eb9842f5a4bbb31be0e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga320b0410ab8e10a8bc5c2a6278ed06d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga320b0410ab8e10a8bc5c2a6278ed06d7">XHdcp1x_CipherSetRemoteKsv</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u64 Ksv)</td></tr>
<tr class="separator:ga320b0410ab8e10a8bc5c2a6278ed06d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ecfb468f0917a558f7713ab74903033"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga8ecfb468f0917a558f7713ab74903033">XHdcp1x_CipherGetB</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u32 *X, u32 *Y, u32 *Z)</td></tr>
<tr class="separator:ga8ecfb468f0917a558f7713ab74903033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70bcb7dd61e57e5b33d2213817a80eca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga70bcb7dd61e57e5b33d2213817a80eca">XHdcp1x_CipherSetB</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u32 X, u32 Y, u32 Z)</td></tr>
<tr class="separator:ga70bcb7dd61e57e5b33d2213817a80eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga987fc5a5170470f0bbff214d317aac17"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga987fc5a5170470f0bbff214d317aac17">XHdcp1x_CipherGetK</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u32 *X, u32 *Y, u32 *Z)</td></tr>
<tr class="separator:ga987fc5a5170470f0bbff214d317aac17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89ff306031805dad1e1ff7af0c836873"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga89ff306031805dad1e1ff7af0c836873">XHdcp1x_CipherSetK</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u32 X, u32 Y, u32 Z)</td></tr>
<tr class="separator:ga89ff306031805dad1e1ff7af0c836873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72d8fd0f45ff6424d3aac43e36360fec"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga72d8fd0f45ff6424d3aac43e36360fec">XHdcp1x_CipherGetMi</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga72d8fd0f45ff6424d3aac43e36360fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9719a81dc9b6815f6b616ccc076f03c2"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga9719a81dc9b6815f6b616ccc076f03c2">XHdcp1x_CipherGetRi</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga9719a81dc9b6815f6b616ccc076f03c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8759c2071248b537b7ae18b2a1ec5a6"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gad8759c2071248b537b7ae18b2a1ec5a6">XHdcp1x_CipherGetMo</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gad8759c2071248b537b7ae18b2a1ec5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14ed33ea832900d1022b7a1e8ddba397"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga14ed33ea832900d1022b7a1e8ddba397">XHdcp1x_CipherGetRo</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga14ed33ea832900d1022b7a1e8ddba397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac542620e5aa06df5f83f097a6fc7738"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaac542620e5aa06df5f83f097a6fc7738">XHdcp1x_CipherGetVersion</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gaac542620e5aa06df5f83f097a6fc7738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1075068f7db6bf3b0ae31818534f93e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga1075068f7db6bf3b0ae31818534f93e8">XHdcp1x_CipherEnableBlank</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga1075068f7db6bf3b0ae31818534f93e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2bcbd719e1f2f9b0b5fe6757b5a14b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaa2bcbd719e1f2f9b0b5fe6757b5a14b2">XHdcp1x_CipherDisableBlank</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gaa2bcbd719e1f2f9b0b5fe6757b5a14b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc9a91374b2e78ea1aade28082e354a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gafc9a91374b2e78ea1aade28082e354a7">XHdcp1x_CipherSetCallback</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u32 HandlerType, <a class="el" href="group__hdcp1x__v4__0.html#ga22b9b36c134731fc3c2d450b29095e05">XHdcp1x_Callback</a> CallbackFunc, void *CallbackRef)</td></tr>
<tr class="separator:gafc9a91374b2e78ea1aade28082e354a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3912c6a86498e0559470ce8ce148cd1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gac3912c6a86498e0559470ce8ce148cd1">XHdcp1x_CipherSetLinkStateCheck</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, int IsEnabled)</td></tr>
<tr class="separator:gac3912c6a86498e0559470ce8ce148cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2ae95918ecd46e725812a9bce8f6478"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gae2ae95918ecd46e725812a9bce8f6478">XHdcp1x_CipherSetRiUpdate</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, int IsEnabled)</td></tr>
<tr class="separator:gae2ae95918ecd46e725812a9bce8f6478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a718cbfba0847675523d2a89d8a3755"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga7a718cbfba0847675523d2a89d8a3755">XHdcp1x_CipherHandleInterrupt</a> (void *InstancePtr)</td></tr>
<tr class="separator:ga7a718cbfba0847675523d2a89d8a3755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceb8746cc60b1628b4df76d155f0b6a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaceb8746cc60b1628b4df76d155f0b6a5">XHdcp1x_PlatformIsKsvRevoked</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u64 Ksv)</td></tr>
<tr class="separator:gaceb8746cc60b1628b4df76d155f0b6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga702d5623fb869e3454ce5557b79cca1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga702d5623fb869e3454ce5557b79cca1a">XHdcp1x_PlatformTimerStart</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u16 TimeoutInMs)</td></tr>
<tr class="separator:ga702d5623fb869e3454ce5557b79cca1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c5ac368d276bfd8e6a017b64c90cbf1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga1c5ac368d276bfd8e6a017b64c90cbf1">XHdcp1x_PlatformTimerStop</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga1c5ac368d276bfd8e6a017b64c90cbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f5e4cf832a1dd14f902a2e25043a56e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga0f5e4cf832a1dd14f902a2e25043a56e">XHdcp1x_PlatformTimerBusy</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u16 DelayInMs)</td></tr>
<tr class="separator:ga0f5e4cf832a1dd14f902a2e25043a56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5f729774d507b92940336ef2112939a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__hdcp1x__v4__0.html#gab3390f77e705a54ca5639baa56743d3a">XHdcp1x_PortPhyIfAdaptor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaf5f729774d507b92940336ef2112939a">XHdcp1x_PortDetermineAdaptor</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gaf5f729774d507b92940336ef2112939a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe3971f3a49c69f3a316f3fab58fdf20"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gafe3971f3a49c69f3a316f3fab58fdf20">XHdcp1x_PortEnable</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gafe3971f3a49c69f3a316f3fab58fdf20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga152c8d8f9abdee612ce15f6e914a122a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga152c8d8f9abdee612ce15f6e914a122a">XHdcp1x_PortDisable</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga152c8d8f9abdee612ce15f6e914a122a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1e24817724b0410a9b272343a0ef745"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaf1e24817724b0410a9b272343a0ef745">XHdcp1x_PortIsCapable</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gaf1e24817724b0410a9b272343a0ef745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41b5285a790690159dece6baa5afadf9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga41b5285a790690159dece6baa5afadf9">XHdcp1x_PortIsRepeater</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga41b5285a790690159dece6baa5afadf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ddc37a110b704b91553dea3646d18e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga4ddc37a110b704b91553dea3646d18e2">XHdcp1x_PortSetRepeater</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u8 RptrConf)</td></tr>
<tr class="separator:ga4ddc37a110b704b91553dea3646d18e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8865a6a7279587d2a439f603b78bf35c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga8865a6a7279587d2a439f603b78bf35c">XHdcp1x_PortGetRepeaterInfo</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u16 *InfoPtr)</td></tr>
<tr class="separator:ga8865a6a7279587d2a439f603b78bf35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e36b9c8a021600e2c9e3766f94b6dc7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga6e36b9c8a021600e2c9e3766f94b6dc7">XHdcp1x_PortRead</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u8 Offset, void *Buf, u32 BufSize)</td></tr>
<tr class="separator:ga6e36b9c8a021600e2c9e3766f94b6dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46da74febe033d53ef2420d318fd63b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga46da74febe033d53ef2420d318fd63b9">XHdcp1x_PortWrite</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u8 Offset, const void *Buf, u32 BufSize)</td></tr>
<tr class="separator:ga46da74febe033d53ef2420d318fd63b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f9860359eea1bd7989e76c11888734c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga1f9860359eea1bd7989e76c11888734c">XHdcp1x_PortSetCallback</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u32 HandlerType, <a class="el" href="group__hdcp1x__v4__0.html#ga22b9b36c134731fc3c2d450b29095e05">XHdcp1x_Callback</a> CallbackFunc, void *CallbackRef)</td></tr>
<tr class="separator:ga1f9860359eea1bd7989e76c11888734c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e84960fab8e0598e3dc0ecffd7fa2dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga5e84960fab8e0598e3dc0ecffd7fa2dc">XHdcp1x_PortHandleInterrupt</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u32 IntCause)</td></tr>
<tr class="separator:ga5e84960fab8e0598e3dc0ecffd7fa2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10379d782472233124be66f42559f093"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga10379d782472233124be66f42559f093">XHdcp1x_RxSetCallback</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, <a class="el" href="group__hdcp1x__v4__0.html#gaa46858c4b302cf0e3f9d59d5c5e6bbb9">XHdcp1x_HandlerType</a> HandlerType, void *CallbackFunc, void *CallbackRef)</td></tr>
<tr class="separator:ga10379d782472233124be66f42559f093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45e3bcb6feba3b09d84567db489a8f86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga45e3bcb6feba3b09d84567db489a8f86">XHdcp1x_RxInit</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga45e3bcb6feba3b09d84567db489a8f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ee01293294eecf9f0f2aa2b380e0116"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga5ee01293294eecf9f0f2aa2b380e0116">XHdcp1x_RxPoll</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga5ee01293294eecf9f0f2aa2b380e0116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b43677a8ea30e51ee23b673349d488e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga0b43677a8ea30e51ee23b673349d488e">XHdcp1x_RxSetRepeaterBcaps</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u8 IsRptr)</td></tr>
<tr class="separator:ga0b43677a8ea30e51ee23b673349d488e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddbe71f943e307f5efb356944b0c052d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaddbe71f943e307f5efb356944b0c052d">XHdcp1x_RxReset</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gaddbe71f943e307f5efb356944b0c052d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b3db5316f37aa537c96819ef7892d0e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga5b3db5316f37aa537c96819ef7892d0e">XHdcp1x_RxEnable</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga5b3db5316f37aa537c96819ef7892d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80075a0db87bde2e795072ca8c5d1190"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga80075a0db87bde2e795072ca8c5d1190">XHdcp1x_RxDisable</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga80075a0db87bde2e795072ca8c5d1190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a7a3ac0f4c2abe70a1227c2e40eeda3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga9a7a3ac0f4c2abe70a1227c2e40eeda3">XHdcp1x_RxIsEnabled</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga9a7a3ac0f4c2abe70a1227c2e40eeda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf696741527cfe391ade5d66238b3cf75"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaf696741527cfe391ade5d66238b3cf75">XHdcp1x_RxSetPhysicalState</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, int IsUp)</td></tr>
<tr class="separator:gaf696741527cfe391ade5d66238b3cf75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51b562dcf0e9f5fe995d2ef05f3cc9b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga51b562dcf0e9f5fe995d2ef05f3cc9b1">XHdcp1x_RxSetLaneCount</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, int LaneCount)</td></tr>
<tr class="separator:ga51b562dcf0e9f5fe995d2ef05f3cc9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3938eb7c1586cfe850ec941c36857f22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga3938eb7c1586cfe850ec941c36857f22">XHdcp1x_RxDownstreamReady</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga3938eb7c1586cfe850ec941c36857f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0dcbf2dffdfd9ef4b3d02184f01cab7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaf0dcbf2dffdfd9ef4b3d02184f01cab7">XHdcp1x_RxAuthenticate</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gaf0dcbf2dffdfd9ef4b3d02184f01cab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa617d8a93cb5f75964aa2d0c6a94e1f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaa617d8a93cb5f75964aa2d0c6a94e1f9">XHdcp1x_RxIsInProgress</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gaa617d8a93cb5f75964aa2d0c6a94e1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f314cd6eca64f8953ea54fb6bb93c03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga2f314cd6eca64f8953ea54fb6bb93c03">XHdcp1x_RxIsAuthenticated</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga2f314cd6eca64f8953ea54fb6bb93c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63d2c00e67796620c78474de50c5f4ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga63d2c00e67796620c78474de50c5f4ce">XHdcp1x_RxIsInComputations</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga63d2c00e67796620c78474de50c5f4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3828bd501048526899095762ad7bb97e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga3828bd501048526899095762ad7bb97e">XHdcp1x_RxIsInWaitforready</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga3828bd501048526899095762ad7bb97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga151310d6c13945600dbe10531827a2a3"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga151310d6c13945600dbe10531827a2a3">XHdcp1x_RxGetEncryption</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga151310d6c13945600dbe10531827a2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa97634c0e7aa105f887389101052c62f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaa97634c0e7aa105f887389101052c62f">XHdcp1x_RxHandleTimeout</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gaa97634c0e7aa105f887389101052c62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89cf71a1a7edefa4671fdefa3cc7222b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga89cf71a1a7edefa4671fdefa3cc7222b">XHdcp1x_RxInfo</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga89cf71a1a7edefa4671fdefa3cc7222b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad04a19828d3f0e503ac0a89cfb5e8212"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, <a class="el" href="struct_x_hdcp1x___repeater_exchange.html">XHdcp1x_RepeaterExchange</a> *RepeaterInfoPtr)</td></tr>
<tr class="separator:gad04a19828d3f0e503ac0a89cfb5e8212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb80781bfc840aba969aead350a41e46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaeb80781bfc840aba969aead350a41e46">XHdcp1x_RxSetTopologyUpdate</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gaeb80781bfc840aba969aead350a41e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga424c128017a249fece45572f628c2f83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga424c128017a249fece45572f628c2f83">XHdcp1x_RxSetTopology</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, const <a class="el" href="struct_x_hdcp1x___repeater_exchange.html">XHdcp1x_RepeaterExchange</a> *TopologyPtr)</td></tr>
<tr class="separator:ga424c128017a249fece45572f628c2f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2d20e2c7ccd2e279a5bd4c3400484d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gad2d20e2c7ccd2e279a5bd4c3400484d3">XHdcp1x_RxSetTopologyKSVList</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u8 *ListPtr, u32 ListSize)</td></tr>
<tr class="separator:gad2d20e2c7ccd2e279a5bd4c3400484d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97cc65af5348a4bc57badb185250d39d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga97cc65af5348a4bc57badb185250d39d">XHdcp1x_RxSetTopologyDepth</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u32 Value)</td></tr>
<tr class="separator:ga97cc65af5348a4bc57badb185250d39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfa4b6b01fe73a264da702c451eec590"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gadfa4b6b01fe73a264da702c451eec590">XHdcp1x_RxSetTopologyDeviceCnt</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u32 Value)</td></tr>
<tr class="separator:gadfa4b6b01fe73a264da702c451eec590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3eacc3ce1104040154509de3edd755f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gae3eacc3ce1104040154509de3edd755f">XHdcp1x_RxSetTopologyMaxCascadeExceeded</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u8 Value)</td></tr>
<tr class="separator:gae3eacc3ce1104040154509de3edd755f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e592488862d8a1a599abbcf8bd1b30c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u8 Value)</td></tr>
<tr class="separator:ga9e592488862d8a1a599abbcf8bd1b30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67f8a82df784bef00e7532a43b495d85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga67f8a82df784bef00e7532a43b495d85">XHdcp1x_TxSetCallback</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, <a class="el" href="group__hdcp1x__v4__0.html#gaa46858c4b302cf0e3f9d59d5c5e6bbb9">XHdcp1x_HandlerType</a> HandlerType, void *CallbackFunc, void *CallbackRef)</td></tr>
<tr class="separator:ga67f8a82df784bef00e7532a43b495d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cff233ed850c294c88271be7f76235e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga7cff233ed850c294c88271be7f76235e">XHdcp1x_TxInit</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga7cff233ed850c294c88271be7f76235e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2ceda82b4b6c4e6419e864895109ffa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gac2ceda82b4b6c4e6419e864895109ffa">XHdcp1x_TxPoll</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gac2ceda82b4b6c4e6419e864895109ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f96aea1f54189b92719510de767b768"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga1f96aea1f54189b92719510de767b768">XHdcp1x_TxReset</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga1f96aea1f54189b92719510de767b768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf9b859a4cd68d38f32103a365d48b99"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaaf9b859a4cd68d38f32103a365d48b99">XHdcp1x_TxEnable</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gaaf9b859a4cd68d38f32103a365d48b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88eb2f469cf2a69bcf8a80271a64330c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga88eb2f469cf2a69bcf8a80271a64330c">XHdcp1x_TxDisable</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga88eb2f469cf2a69bcf8a80271a64330c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74a97f4a831692ea2465eb39935ffdcf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga74a97f4a831692ea2465eb39935ffdcf">XHdcp1x_TxIsEnabled</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga74a97f4a831692ea2465eb39935ffdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5540f73bc84858385b40eb85c2471cdc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga5540f73bc84858385b40eb85c2471cdc">XHdcp1x_TxSetPhysicalState</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, int IsUp)</td></tr>
<tr class="separator:ga5540f73bc84858385b40eb85c2471cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4099beda2b952aa7f9ce574cbbc7646"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaf4099beda2b952aa7f9ce574cbbc7646">XHdcp1x_TxSetLaneCount</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, int LaneCount)</td></tr>
<tr class="separator:gaf4099beda2b952aa7f9ce574cbbc7646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec7dcf7e211da3d42dc621cb7d062f6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaec7dcf7e211da3d42dc621cb7d062f6c">XHdcp1x_TxAuthenticate</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gaec7dcf7e211da3d42dc621cb7d062f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf52273c741319df900b9fe2bb51b78d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaf52273c741319df900b9fe2bb51b78d6">XHdcp1x_TxReadDownstream</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gaf52273c741319df900b9fe2bb51b78d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26586d8954b1ed09f365399f6f7fd6b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga26586d8954b1ed09f365399f6f7fd6b8">XHdcp1x_TxIsInProgress</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga26586d8954b1ed09f365399f6f7fd6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c42675e40aba8024237fee77155fce4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga3c42675e40aba8024237fee77155fce4">XHdcp1x_TxIsAuthenticated</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga3c42675e40aba8024237fee77155fce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d0d1dc50d7b95639e72d74b1fa2d064"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga3d0d1dc50d7b95639e72d74b1fa2d064">XHdcp1x_TxIsInComputations</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga3d0d1dc50d7b95639e72d74b1fa2d064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4b47fe66cfc82912ada3df74ade247b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gae4b47fe66cfc82912ada3df74ade247b">XHdcp1x_TxIsInWaitforready</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gae4b47fe66cfc82912ada3df74ade247b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad30b097e8f3ff909c1ad5bd4c6a7d7c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gad30b097e8f3ff909c1ad5bd4c6a7d7c8">XHdcp1x_TxIsDownstrmCapable</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gad30b097e8f3ff909c1ad5bd4c6a7d7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86e8fd4e72f7d913bc7f13ea15f37af7"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga86e8fd4e72f7d913bc7f13ea15f37af7">XHdcp1x_TxGetEncryption</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga86e8fd4e72f7d913bc7f13ea15f37af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49660982a4772c7bc0091f7c88c68e19"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga49660982a4772c7bc0091f7c88c68e19">XHdcp1x_TxEnableEncryption</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u64 StreamMap)</td></tr>
<tr class="separator:ga49660982a4772c7bc0091f7c88c68e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8b45d2c6a594bdb5210c443d1d0020d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gad8b45d2c6a594bdb5210c443d1d0020d">XHdcp1x_TxDisableEncryption</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u64 StreamMap)</td></tr>
<tr class="separator:gad8b45d2c6a594bdb5210c443d1d0020d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79bb13897f9893f9ffbecd6247aea442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga79bb13897f9893f9ffbecd6247aea442">XHdcp1x_TxHandleTimeout</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga79bb13897f9893f9ffbecd6247aea442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee964dc4d6fc103705d6358fc2db9480"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaee964dc4d6fc103705d6358fc2db9480">XHdcp1x_TxIsRepeater</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gaee964dc4d6fc103705d6358fc2db9480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa503ece3533fb6055289ad2dd01ba80b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaa503ece3533fb6055289ad2dd01ba80b">XHdcp1x_TxInfo</a> (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gaa503ece3533fb6055289ad2dd01ba80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga610b320cce6d9ee99a4f8c2380f2c852"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga610b320cce6d9ee99a4f8c2380f2c852">XHdcp1x_TxEnableBlank</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga610b320cce6d9ee99a4f8c2380f2c852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5345387226f345c288ee244f369d8ed5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga5345387226f345c288ee244f369d8ed5">XHdcp1x_TxDisableBlank</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga5345387226f345c288ee244f369d8ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab797b1cff481d823174db2e3fdec666a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth</a> (void *Parameter)</td></tr>
<tr class="separator:gab797b1cff481d823174db2e3fdec666a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad633915b955c6b56fa317e44bf26593a"><td class="memItemLeft" align="right" valign="top">u8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gad633915b955c6b56fa317e44bf26593a">XHdcp1x_TxGetTopologyKSVList</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gad633915b955c6b56fa317e44bf26593a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11572e1f3d8c314380b5442a2edfb4bc"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga11572e1f3d8c314380b5442a2edfb4bc">XHdcp1x_TxGetTopologyDepth</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga11572e1f3d8c314380b5442a2edfb4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4fca1a785fdb5e58b98c8f6619614e9"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gad4fca1a785fdb5e58b98c8f6619614e9">XHdcp1x_TxGetTopologyDeviceCnt</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gad4fca1a785fdb5e58b98c8f6619614e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf854c758691f491c5f80e89a795f2a24"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaf854c758691f491c5f80e89a795f2a24">XHdcp1x_TxGetTopologyMaxCascadeExceeded</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gaf854c758691f491c5f80e89a795f2a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacbe196b64bd19fe98db62e552b89788"><td class="memItemLeft" align="right" valign="top">u8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gaacbe196b64bd19fe98db62e552b89788">XHdcp1x_TxGetTopologyBKSV</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gaacbe196b64bd19fe98db62e552b89788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga029629390d42624ba18930e5d73a948e"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#ga029629390d42624ba18930e5d73a948e">XHdcp1x_TxGetTopologyMaxDevsExceeded</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:ga029629390d42624ba18930e5d73a948e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab22ac8a26a4b60bdeda3be59baacbf39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_hdcp1x___repeater_exchange.html">XHdcp1x_RepeaterExchange</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology</a> (<a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr)</td></tr>
<tr class="separator:gab22ac8a26a4b60bdeda3be59baacbf39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gae578001fe043b4cca7a0edd801cfe9c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DRIVER_VERSION&#160;&#160;&#160;(0x00010023ul)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This defines the version of the software driver. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga52085c5f3ece2e12521fe526dbc7742f">XHdcp1x_GetDriverVersion()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0e5f803c6b3c9f9f0a95fbd20dd0266e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HDCP1X_CIPHER_BIT_REPEATER_ENABLE&#160;&#160;&#160;(1 &lt;&lt; 8)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8h.html">xhdcp1x_cipher.h</a>&gt;</code></p>

<p>Bit in the cipher Bz register to indicate Repeater. </p>

</div>
</div>
<a class="anchor" id="gaf79f131e95519546c77b8fc62abeddc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_BITMASK_BLANK_SEL&#160;&#160;&#160;(0x1u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Cipher blank select bitmask. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gaa2bcbd719e1f2f9b0b5fe6757b5a14b2">XHdcp1x_CipherDisableBlank()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga1075068f7db6bf3b0ae31818534f93e8">XHdcp1x_CipherEnableBlank()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4922903951c850d40666a25feaed783a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_BITMASK_BLANK_VALUE&#160;&#160;&#160;(0x000000FF)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Cipher blank value bitmask, lower 24 bits. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga1075068f7db6bf3b0ae31818534f93e8">XHdcp1x_CipherEnableBlank()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf0b6126446543cb6cb9be5b0aa90801d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_BITMASK_CIPHER_CONTROL_REQUEST&#160;&#160;&#160;(0x07u &lt;&lt;  8)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Request bitmask in Cipher Control register. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad44ad72f65d851de50c40053e327ba9e">XHdcp1x_CipherDoRequest()</a>.</p>

</div>
</div>
<a class="anchor" id="gad79579919909139a889131cfca73eef5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_BITMASK_CIPHER_CONTROL_XOR_ENABLE&#160;&#160;&#160;(0x01u &lt;&lt;  0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>XOR Enable bitmask in Cipher Control register. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga2ca06586dc06796fdc31a2f64096a28d">XHdcp1x_CipherDisable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga49cf0f72f0d918e33d66ff40c91d3073">XHdcp1x_CipherDisableEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa3f73058855c8d60cbd588d74e60a668">XHdcp1x_CipherEnable()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga706d8729ad07f34fad5e20f83c59d69f">XHdcp1x_CipherEnableEncryption()</a>.</p>

</div>
</div>
<a class="anchor" id="ga57d495d46e345da61f512d5c33d3dbd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_BITMASK_CIPHER_STATUS_REQUEST_IN_PROG&#160;&#160;&#160;(0x07u &lt;&lt;  8)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Request In Progress bitmask in Cipher Status register. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad44ad72f65d851de50c40053e327ba9e">XHdcp1x_CipherDoRequest()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gace24c74db709b523e1aae7e082494022">XHdcp1x_CipherIsRequestComplete()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0b6854f289450df142cde1637a13092b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_BITMASK_CIPHER_STATUS_XOR_IN_PROG&#160;&#160;&#160;(0x01u &lt;&lt;  0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>XOR In Progress bitmask in Cipher Status register. </p>

</div>
</div>
<a class="anchor" id="ga10ea0666c02c4c6343b9ae9e251ae6a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_BITMASK_CONTROL_ENABLE&#160;&#160;&#160;(0x01u &lt;&lt;  0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Enable bitmask in Control register. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga2ca06586dc06796fdc31a2f64096a28d">XHdcp1x_CipherDisable()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gaa3f73058855c8d60cbd588d74e60a668">XHdcp1x_CipherEnable()</a>.</p>

</div>
</div>
<a class="anchor" id="gae41022b4dbc46732ab6dcbec56ba7fc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_BITMASK_CONTROL_NUM_LANES&#160;&#160;&#160;(0x07u &lt;&lt;  4)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Num Lanes bitmask in Control register. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gacfeb8a266c1bc554753f93d62eb9a891">XHdcp1x_CipherGetNumLanes()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga458350d13807e4d1c4d3655167ec6f03">XHdcp1x_CipherInit()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gad104aebb80bb03cb66c31eaabf21247a">XHdcp1x_CipherSetNumLanes()</a>.</p>

</div>
</div>
<a class="anchor" id="ga26fcb950b098b95e5e74232357ce158c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_BITMASK_CONTROL_RESET&#160;&#160;&#160;(0x01u &lt;&lt; 31)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Reset bitmask in Control register. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga458350d13807e4d1c4d3655167ec6f03">XHdcp1x_CipherInit()</a>.</p>

</div>
</div>
<a class="anchor" id="ga26e1542eb772b2449973d200297da4f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_BITMASK_CONTROL_UPDATE&#160;&#160;&#160;(0x01u &lt;&lt;  1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Update bitmask in Control register. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga2ca06586dc06796fdc31a2f64096a28d">XHdcp1x_CipherDisable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga49cf0f72f0d918e33d66ff40c91d3073">XHdcp1x_CipherDisableEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad44ad72f65d851de50c40053e327ba9e">XHdcp1x_CipherDoRequest()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa3f73058855c8d60cbd588d74e60a668">XHdcp1x_CipherEnable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga706d8729ad07f34fad5e20f83c59d69f">XHdcp1x_CipherEnableEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga458350d13807e4d1c4d3655167ec6f03">XHdcp1x_CipherInit()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga70bcb7dd61e57e5b33d2213817a80eca">XHdcp1x_CipherSetB()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga89ff306031805dad1e1ff7af0c836873">XHdcp1x_CipherSetK()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga320b0410ab8e10a8bc5c2a6278ed06d7">XHdcp1x_CipherSetRemoteKsv()</a>.</p>

</div>
</div>
<a class="anchor" id="gaabf04c9775bb969435eb0a56a67e8f57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_BITMASK_INTERRUPT_LINK_FAIL&#160;&#160;&#160;(0x01u &lt;&lt;  0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Link Failure bitmask in Interrupt register(s) </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga7a718cbfba0847675523d2a89d8a3755">XHdcp1x_CipherHandleInterrupt()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga40c4838c730476e98dfcd742eb1d21a4">XHdcp1x_CipherIsLinkUp()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gac3912c6a86498e0559470ce8ce148cd1">XHdcp1x_CipherSetLinkStateCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1b2651a6446b10aab2f229e506d75304"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_BITMASK_INTERRUPT_Ri_UPDATE&#160;&#160;&#160;(0x01u &lt;&lt;  1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Ri bitmask in Interrupt register(s) </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga7a718cbfba0847675523d2a89d8a3755">XHdcp1x_CipherHandleInterrupt()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gae2ae95918ecd46e725812a9bce8f6478">XHdcp1x_CipherSetRiUpdate()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0499c0ca032f1fc1230ae9ee10021e32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_BITMASK_KEYMGMT_CONTROL_ABORT_Km&#160;&#160;&#160;(0x01u &lt;&lt;  2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Abort Km bitmask in Key Management Control register. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gacc166098738c7aac2703ee0cbd757c01">XHdcp1x_CipherGetLocalKsv()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9a7b2e5dbaac71ec8ec49eb48d29efc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_BITMASK_KEYMGMT_CONTROL_BEGIN_Km&#160;&#160;&#160;(0x01u &lt;&lt;  1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Being Km bitmask in Key Management Control register. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga320b0410ab8e10a8bc5c2a6278ed06d7">XHdcp1x_CipherSetRemoteKsv()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1d700722a5c16cf1bd605cd010b9383a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_BITMASK_KEYMGMT_CONTROL_LOCAL_KSV&#160;&#160;&#160;(0x01u &lt;&lt;  0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Read Local KSV bitmask in Key Management Control register. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gacc166098738c7aac2703ee0cbd757c01">XHdcp1x_CipherGetLocalKsv()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf042b01ec650012737670869f098b0bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_BITMASK_KEYMGMT_CONTROL_SET_SELECT&#160;&#160;&#160;(0x07u &lt;&lt; 16)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Key Set Select bitmask in Key Management Control register. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga6f0a88da0a794b63e3f6caafa912dc10">XHdcp1x_CipherSetKeySelect()</a>.</p>

</div>
</div>
<a class="anchor" id="ga74f6d8a048e1f8b3c386e5755d77b2bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_BITMASK_KEYMGMT_STATUS_Km_READY&#160;&#160;&#160;(0x01u &lt;&lt;  1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Km Value ready bitmask in Key Management Status register. </p>

</div>
</div>
<a class="anchor" id="ga5ac122eb8e2456759a8207831615cc0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_BITMASK_KEYMGMT_STATUS_KSV_READY&#160;&#160;&#160;(0x01u &lt;&lt;  0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Local KSV ready bitmask in Key Management Status register. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gacc166098738c7aac2703ee0cbd757c01">XHdcp1x_CipherGetLocalKsv()</a>.</p>

</div>
</div>
<a class="anchor" id="ga84b710cd1da8802a7dce1a7a637fb7f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_BITMASK_TYPE_DIRECTION&#160;&#160;&#160;(0x01u &lt;&lt;  2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Direction bitmask in Type register. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga931fc14801a82c9cc3aa870d887bbc07">XHdcp1x_CfgInitialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0798856f180c219e38c507a192e3ae1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_BITMASK_TYPE_PROTOCOL&#160;&#160;&#160;(0x03u &lt;&lt;  0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Protocol bitmask in Type register. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga931fc14801a82c9cc3aa870d887bbc07">XHdcp1x_CfgInitialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga174f462ee750ac162a36a4322b350c64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_H</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8h.html">xhdcp1x_cipher.h</a>&gt;</code></p>

<p>&lt; Prevent circular inclusions by using protection macros </p>

</div>
</div>
<a class="anchor" id="gac375f416684e4c6180a85c3689a149d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_BLANK_SEL&#160;&#160;&#160;(0x00C0u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Cipher blank select register. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gaa2bcbd719e1f2f9b0b5fe6757b5a14b2">XHdcp1x_CipherDisableBlank()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga1075068f7db6bf3b0ae31818534f93e8">XHdcp1x_CipherEnableBlank()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9ac8d8f8ab7abc814ada20ee259aa1d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_BLANK_VALUE&#160;&#160;&#160;(0x00BCu)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Cipher blank value register. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga1075068f7db6bf3b0ae31818534f93e8">XHdcp1x_CipherEnableBlank()</a>.</p>

</div>
</div>
<a class="anchor" id="gac1d454c21b0a16c522875ba13573dee0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_CIPHER_Bx&#160;&#160;&#160;(0x0058u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Cipher Bx register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga8ecfb468f0917a558f7713ab74903033">XHdcp1x_CipherGetB()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga70bcb7dd61e57e5b33d2213817a80eca">XHdcp1x_CipherSetB()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7d2bc6d575edff65961d636f20503d65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_CIPHER_By&#160;&#160;&#160;(0x005Cu)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Cipher By register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga8ecfb468f0917a558f7713ab74903033">XHdcp1x_CipherGetB()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga70bcb7dd61e57e5b33d2213817a80eca">XHdcp1x_CipherSetB()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3d01b54a0fd09d11bbdf0b76180c381e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_CIPHER_Bz&#160;&#160;&#160;(0x0060u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Cipher Bz register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga8ecfb468f0917a558f7713ab74903033">XHdcp1x_CipherGetB()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga70bcb7dd61e57e5b33d2213817a80eca">XHdcp1x_CipherSetB()</a>.</p>

</div>
</div>
<a class="anchor" id="gabdf7f5d97b37f0649c697488cc36bc3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_CIPHER_CONTROL&#160;&#160;&#160;(0x0050u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Cipher Control register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga2ca06586dc06796fdc31a2f64096a28d">XHdcp1x_CipherDisable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga49cf0f72f0d918e33d66ff40c91d3073">XHdcp1x_CipherDisableEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad44ad72f65d851de50c40053e327ba9e">XHdcp1x_CipherDoRequest()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa3f73058855c8d60cbd588d74e60a668">XHdcp1x_CipherEnable()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga706d8729ad07f34fad5e20f83c59d69f">XHdcp1x_CipherEnableEncryption()</a>.</p>

</div>
</div>
<a class="anchor" id="gaad2ec605c8db4820f38ffd88f0273a6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_CIPHER_Kx&#160;&#160;&#160;(0x0064u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Cipher Kx register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga987fc5a5170470f0bbff214d317aac17">XHdcp1x_CipherGetK()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga89ff306031805dad1e1ff7af0c836873">XHdcp1x_CipherSetK()</a>.</p>

</div>
</div>
<a class="anchor" id="gacd07f7fbf273cdc8c00a08fb2f8fb0eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_CIPHER_Ky&#160;&#160;&#160;(0x0068u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Cipher Ky register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga987fc5a5170470f0bbff214d317aac17">XHdcp1x_CipherGetK()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga89ff306031805dad1e1ff7af0c836873">XHdcp1x_CipherSetK()</a>.</p>

</div>
</div>
<a class="anchor" id="gacc91172cce2e873df65a9cfd5b4f6e06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_CIPHER_Kz&#160;&#160;&#160;(0x006Cu)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Cipher Kz register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga987fc5a5170470f0bbff214d317aac17">XHdcp1x_CipherGetK()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga89ff306031805dad1e1ff7af0c836873">XHdcp1x_CipherSetK()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf1add239c0ecfb90a3fc94eaafccbb31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_CIPHER_Mi_H&#160;&#160;&#160;(0x0070u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Cipher Mi (High) register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga72d8fd0f45ff6424d3aac43e36360fec">XHdcp1x_CipherGetMi()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0aa61ee18e89809a5cfc537a72d32eae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_CIPHER_Mi_L&#160;&#160;&#160;(0x0074u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Cipher Mi (Low) register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga72d8fd0f45ff6424d3aac43e36360fec">XHdcp1x_CipherGetMi()</a>.</p>

</div>
</div>
<a class="anchor" id="gac372c841db1b7543feccc7db3d69b589"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_CIPHER_Mo_H&#160;&#160;&#160;(0x0080u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Cipher Mo (High) register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad8759c2071248b537b7ae18b2a1ec5a6">XHdcp1x_CipherGetMo()</a>.</p>

</div>
</div>
<a class="anchor" id="gaafe1da3a001a875beee367e4376b98e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_CIPHER_Mo_L&#160;&#160;&#160;(0x0084u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Cipher Mo (Low) register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad8759c2071248b537b7ae18b2a1ec5a6">XHdcp1x_CipherGetMo()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9f1a35f1da810221d96ba0da2664eda3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_CIPHER_Ri&#160;&#160;&#160;(0x0078u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Cipher Ri register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9719a81dc9b6815f6b616ccc076f03c2">XHdcp1x_CipherGetRi()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4afb7f142a1f9ef42220be416475c2da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_CIPHER_Ro&#160;&#160;&#160;(0x007Cu)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Cipher Ro register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga14ed33ea832900d1022b7a1e8ddba397">XHdcp1x_CipherGetRo()</a>.</p>

</div>
</div>
<a class="anchor" id="gae3972aa89e01893b3fe8f5218625d512"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_CIPHER_STATUS&#160;&#160;&#160;(0x0054u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Cipher Status register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad44ad72f65d851de50c40053e327ba9e">XHdcp1x_CipherDoRequest()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gace24c74db709b523e1aae7e082494022">XHdcp1x_CipherIsRequestComplete()</a>.</p>

</div>
</div>
<a class="anchor" id="ga388ba97163cd68f5e6124a80bd78c30d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_CONTROL&#160;&#160;&#160;(0x000Cu)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Control register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga2ca06586dc06796fdc31a2f64096a28d">XHdcp1x_CipherDisable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga49cf0f72f0d918e33d66ff40c91d3073">XHdcp1x_CipherDisableEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad44ad72f65d851de50c40053e327ba9e">XHdcp1x_CipherDoRequest()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa3f73058855c8d60cbd588d74e60a668">XHdcp1x_CipherEnable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga706d8729ad07f34fad5e20f83c59d69f">XHdcp1x_CipherEnableEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gacfeb8a266c1bc554753f93d62eb9a891">XHdcp1x_CipherGetNumLanes()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga458350d13807e4d1c4d3655167ec6f03">XHdcp1x_CipherInit()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga70bcb7dd61e57e5b33d2213817a80eca">XHdcp1x_CipherSetB()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga89ff306031805dad1e1ff7af0c836873">XHdcp1x_CipherSetK()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad104aebb80bb03cb66c31eaabf21247a">XHdcp1x_CipherSetNumLanes()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga320b0410ab8e10a8bc5c2a6278ed06d7">XHdcp1x_CipherSetRemoteKsv()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9e2aef2d07c6314c854fef365f381036"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_ENCRYPT_ENABLE_H&#160;&#160;&#160;(0x0020u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Encryption Enable (High) register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga2ca06586dc06796fdc31a2f64096a28d">XHdcp1x_CipherDisable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga49cf0f72f0d918e33d66ff40c91d3073">XHdcp1x_CipherDisableEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa3f73058855c8d60cbd588d74e60a668">XHdcp1x_CipherEnable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga706d8729ad07f34fad5e20f83c59d69f">XHdcp1x_CipherEnableEncryption()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gae38ae0f74022763d8650a21fedcd15e5">XHdcp1x_CipherGetEncryption()</a>.</p>

</div>
</div>
<a class="anchor" id="gaefc63f94eea644f969857f99264a9a5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_ENCRYPT_ENABLE_L&#160;&#160;&#160;(0x0024u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Encryption Enable (Low) register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga2ca06586dc06796fdc31a2f64096a28d">XHdcp1x_CipherDisable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga49cf0f72f0d918e33d66ff40c91d3073">XHdcp1x_CipherDisableEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa3f73058855c8d60cbd588d74e60a668">XHdcp1x_CipherEnable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga706d8729ad07f34fad5e20f83c59d69f">XHdcp1x_CipherEnableEncryption()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gae38ae0f74022763d8650a21fedcd15e5">XHdcp1x_CipherGetEncryption()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf2d2522cb49e8fb546d3f19cc27bc550"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_INTERRUPT_MASK&#160;&#160;&#160;(0x0014u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Interrupt Mask register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga2ca06586dc06796fdc31a2f64096a28d">XHdcp1x_CipherDisable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga7a718cbfba0847675523d2a89d8a3755">XHdcp1x_CipherHandleInterrupt()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga458350d13807e4d1c4d3655167ec6f03">XHdcp1x_CipherInit()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gac3912c6a86498e0559470ce8ce148cd1">XHdcp1x_CipherSetLinkStateCheck()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gae2ae95918ecd46e725812a9bce8f6478">XHdcp1x_CipherSetRiUpdate()</a>.</p>

</div>
</div>
<a class="anchor" id="gae606ccf3553446bcdc5910dbae74e07e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_INTERRUPT_STATUS&#160;&#160;&#160;(0x0018u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Interrupt Status register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga7a718cbfba0847675523d2a89d8a3755">XHdcp1x_CipherHandleInterrupt()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga458350d13807e4d1c4d3655167ec6f03">XHdcp1x_CipherInit()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gac3912c6a86498e0559470ce8ce148cd1">XHdcp1x_CipherSetLinkStateCheck()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gae2ae95918ecd46e725812a9bce8f6478">XHdcp1x_CipherSetRiUpdate()</a>.</p>

</div>
</div>
<a class="anchor" id="gaed0d27e72d03245fa63cd14fa678d44c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_KEYMGMT_CONTROL&#160;&#160;&#160;(0x002Cu)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Key Management Control register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gacc166098738c7aac2703ee0cbd757c01">XHdcp1x_CipherGetLocalKsv()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga6f0a88da0a794b63e3f6caafa912dc10">XHdcp1x_CipherSetKeySelect()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga320b0410ab8e10a8bc5c2a6278ed06d7">XHdcp1x_CipherSetRemoteKsv()</a>.</p>

</div>
</div>
<a class="anchor" id="gae54c355c17e6c20cff27fb271d4a311f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_KEYMGMT_STATUS&#160;&#160;&#160;(0x0030u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Key Management Status register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gacc166098738c7aac2703ee0cbd757c01">XHdcp1x_CipherGetLocalKsv()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2b043d7a07fbab96bdef50de9d3d8ffd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_Km_H&#160;&#160;&#160;(0x0048u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Km (High) register offset. </p>

</div>
</div>
<a class="anchor" id="gac39b8b595cf8a79c08b196de5a11e5ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_Km_L&#160;&#160;&#160;(0x004Cu)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Km (Low) register offset. </p>

</div>
</div>
<a class="anchor" id="gad33df471264ecb7ad47c56b1965c32e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_KSV_LOCAL_H&#160;&#160;&#160;(0x0038u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Local KSV (High) register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gacc166098738c7aac2703ee0cbd757c01">XHdcp1x_CipherGetLocalKsv()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa0daeba5517cd7489c1c30982867d4c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_KSV_LOCAL_L&#160;&#160;&#160;(0x003Cu)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Local KSV (Low) register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gacc166098738c7aac2703ee0cbd757c01">XHdcp1x_CipherGetLocalKsv()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2229a2994fb98bd78c61c91e8556c33c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_KSV_REMOTE_H&#160;&#160;&#160;(0x0040u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Remote KSV (High) offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9d260acd4a5eb9842f5a4bbb31be0e36">XHdcp1x_CipherGetRemoteKsv()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga320b0410ab8e10a8bc5c2a6278ed06d7">XHdcp1x_CipherSetRemoteKsv()</a>.</p>

</div>
</div>
<a class="anchor" id="ga129daeee5e3119a9c1607a0ab0b6de63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_KSV_REMOTE_L&#160;&#160;&#160;(0x0044u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Remote KSV (Low) register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9d260acd4a5eb9842f5a4bbb31be0e36">XHdcp1x_CipherGetRemoteKsv()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga320b0410ab8e10a8bc5c2a6278ed06d7">XHdcp1x_CipherSetRemoteKsv()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3d29fa022935e0bc6e45f42d089bcfae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_SCRATCH&#160;&#160;&#160;(0x0008u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Scratch pad register offset. </p>

</div>
</div>
<a class="anchor" id="ga47125197300d8d534c2ac141686a23c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_STATUS&#160;&#160;&#160;(0x0010u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Status register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga40c4838c730476e98dfcd742eb1d21a4">XHdcp1x_CipherIsLinkUp()</a>.</p>

</div>
</div>
<a class="anchor" id="gaed76d9474c5b8112f70540b4b13430cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_TYPE&#160;&#160;&#160;(0x0004u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Type register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga931fc14801a82c9cc3aa870d887bbc07">XHdcp1x_CfgInitialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga45c93818933d05bc03a38d74aaf33721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_REG_VERSION&#160;&#160;&#160;(0x0000u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Version register offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gaac542620e5aa06df5f83f097a6fc7738">XHdcp1x_CipherGetVersion()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga710df77b22f0b5c728a51747be26ca2e">XHdcp1x_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga325ae78cb623a0eea61b1e4de1a26d2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_VALUE_CIPHER_CONTROL_REQUEST_BLOCK&#160;&#160;&#160;(0x01u &lt;&lt;  8)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Block Request value in Cipher Control register. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad44ad72f65d851de50c40053e327ba9e">XHdcp1x_CipherDoRequest()</a>.</p>

</div>
</div>
<a class="anchor" id="gae94bf604302490591a7255f06f2b759a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_VALUE_CIPHER_CONTROL_REQUEST_REKEY&#160;&#160;&#160;(0x01u &lt;&lt;  9)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>ReKey Request value in Cipher Control register. </p>

</div>
</div>
<a class="anchor" id="ga37e61c92d34794e986023f506feadd5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_VALUE_CIPHER_CONTROL_REQUEST_RNG&#160;&#160;&#160;(0x01u &lt;&lt; 10)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>RNG Request value in Cipher Control register. </p>

</div>
</div>
<a class="anchor" id="ga7ed6efb073f7ca9454407f78461a1967"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_VALUE_TYPE_DIRECTION_RX&#160;&#160;&#160;(0x00u &lt;&lt;  2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>RX Direction value in Type register. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga931fc14801a82c9cc3aa870d887bbc07">XHdcp1x_CfgInitialize()</a>.</p>

</div>
</div>
<a class="anchor" id="gaadbc4627cd5bf1f2f2c0726f8375b5ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_VALUE_TYPE_DIRECTION_TX&#160;&#160;&#160;(0x01u &lt;&lt;  2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>TX Direction value in Type register. </p>

</div>
</div>
<a class="anchor" id="ga5ed9ffd759a96f662221c27cfca0b985"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_VALUE_TYPE_PROTOCOL_DP&#160;&#160;&#160;(0x00u &lt;&lt;  0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>DP Protocol value in Type register. </p>

</div>
</div>
<a class="anchor" id="ga680a297bf1b072fd0d516a07e311d4de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_CIPHER_VALUE_TYPE_PROTOCOL_HDMI&#160;&#160;&#160;(0x01u &lt;&lt;  0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>HDMI Protocol value in Type register. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga931fc14801a82c9cc3aa870d887bbc07">XHdcp1x_CfgInitialize()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa99360d2e6f5cc2071ff95729c222344"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHdcp1x_CipherIsEnabled</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">((<a class="code" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress, \</div><div class="line">        <a class="code" href="group__hdcp1x__v4__0.html#ga388ba97163cd68f5e6124a80bd78c30d">XHDCP1X_CIPHER_REG_CONTROL</a>) &amp; <a class="code" href="group__hdcp1x__v4__0.html#ga10ea0666c02c4c6343b9ae9e251ae6a3">\</a></div><div class="line"><a class="code" href="group__hdcp1x__v4__0.html#ga10ea0666c02c4c6343b9ae9e251ae6a3">	XHDCP1X_CIPHER_BITMASK_CONTROL_ENABLE</a>) != 0)</div><div class="ttc" id="group__hdcp1x__v4__0_html_ga388ba97163cd68f5e6124a80bd78c30d"><div class="ttname"><a href="group__hdcp1x__v4__0.html#ga388ba97163cd68f5e6124a80bd78c30d">XHDCP1X_CIPHER_REG_CONTROL</a></div><div class="ttdeci">#define XHDCP1X_CIPHER_REG_CONTROL</div><div class="ttdoc">Control register offset. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:79</div></div>
<div class="ttc" id="group__hdcp1x__v4__0_html_ga10ea0666c02c4c6343b9ae9e251ae6a3"><div class="ttname"><a href="group__hdcp1x__v4__0.html#ga10ea0666c02c4c6343b9ae9e251ae6a3">XHDCP1X_CIPHER_BITMASK_CONTROL_ENABLE</a></div><div class="ttdeci">#define XHDCP1X_CIPHER_BITMASK_CONTROL_ENABLE</div><div class="ttdoc">Enable bitmask in Control register. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:187</div></div>
<div class="ttc" id="group__hdcp1x__v4__0_html_ga5477e830e157f72072a2a7f470365682"><div class="ttname"><a href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a></div><div class="ttdeci">#define XHdcp1x_ReadReg(BaseAddress, RegOffset)</div><div class="ttdoc">This macro reads a value from a HDCP cipher register. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:338</div></div>
</div><!-- fragment -->
<p>This queries a cipher to determine if it is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the instance to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating transmitter (TRUE) or not (FALSE).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga49cf0f72f0d918e33d66ff40c91d3073">XHdcp1x_CipherDisableEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad44ad72f65d851de50c40053e327ba9e">XHdcp1x_CipherDoRequest()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa3f73058855c8d60cbd588d74e60a668">XHdcp1x_CipherEnable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga706d8729ad07f34fad5e20f83c59d69f">XHdcp1x_CipherEnableEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga8ecfb468f0917a558f7713ab74903033">XHdcp1x_CipherGetB()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae38ae0f74022763d8650a21fedcd15e5">XHdcp1x_CipherGetEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga987fc5a5170470f0bbff214d317aac17">XHdcp1x_CipherGetK()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gacc166098738c7aac2703ee0cbd757c01">XHdcp1x_CipherGetLocalKsv()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga72d8fd0f45ff6424d3aac43e36360fec">XHdcp1x_CipherGetMi()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad8759c2071248b537b7ae18b2a1ec5a6">XHdcp1x_CipherGetMo()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gacfeb8a266c1bc554753f93d62eb9a891">XHdcp1x_CipherGetNumLanes()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9719a81dc9b6815f6b616ccc076f03c2">XHdcp1x_CipherGetRi()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga14ed33ea832900d1022b7a1e8ddba397">XHdcp1x_CipherGetRo()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga40c4838c730476e98dfcd742eb1d21a4">XHdcp1x_CipherIsLinkUp()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga70bcb7dd61e57e5b33d2213817a80eca">XHdcp1x_CipherSetB()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga89ff306031805dad1e1ff7af0c836873">XHdcp1x_CipherSetK()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga320b0410ab8e10a8bc5c2a6278ed06d7">XHdcp1x_CipherSetRemoteKsv()</a>.</p>

</div>
</div>
<a class="anchor" id="gac433f89288e18ce7be66f0871bf285e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHdcp1x_CipherKmReady</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">((<a class="code" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress, \</div><div class="line">        <a class="code" href="group__hdcp1x__v4__0.html#gae54c355c17e6c20cff27fb271d4a311f">XHDCP1X_CIPHER_REG_KEYMGMT_STATUS</a>) &amp; <a class="code" href="group__hdcp1x__v4__0.html#ga74f6d8a048e1f8b3c386e5755d77b2bc">\</a></div><div class="line"><a class="code" href="group__hdcp1x__v4__0.html#ga74f6d8a048e1f8b3c386e5755d77b2bc">	XHDCP1X_CIPHER_BITMASK_KEYMGMT_STATUS_Km_READY</a>) != 0)</div><div class="ttc" id="group__hdcp1x__v4__0_html_ga74f6d8a048e1f8b3c386e5755d77b2bc"><div class="ttname"><a href="group__hdcp1x__v4__0.html#ga74f6d8a048e1f8b3c386e5755d77b2bc">XHDCP1X_CIPHER_BITMASK_KEYMGMT_STATUS_Km_READY</a></div><div class="ttdeci">#define XHDCP1X_CIPHER_BITMASK_KEYMGMT_STATUS_Km_READY</div><div class="ttdoc">Km Value ready bitmask in Key Management Status register. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:244</div></div>
<div class="ttc" id="group__hdcp1x__v4__0_html_gae54c355c17e6c20cff27fb271d4a311f"><div class="ttname"><a href="group__hdcp1x__v4__0.html#gae54c355c17e6c20cff27fb271d4a311f">XHDCP1X_CIPHER_REG_KEYMGMT_STATUS</a></div><div class="ttdeci">#define XHDCP1X_CIPHER_REG_KEYMGMT_STATUS</div><div class="ttdoc">Key Management Status register offset. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:105</div></div>
<div class="ttc" id="group__hdcp1x__v4__0_html_ga5477e830e157f72072a2a7f470365682"><div class="ttname"><a href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a></div><div class="ttdeci">#define XHdcp1x_ReadReg(BaseAddress, RegOffset)</div><div class="ttdoc">This macro reads a value from a HDCP cipher register. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:338</div></div>
</div><!-- fragment -->
<p>This queries a cipher to determine if the Km value is ready. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the instance to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating ready (TRUE) or not (FALSE).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga320b0410ab8e10a8bc5c2a6278ed06d7">XHdcp1x_CipherSetRemoteKsv()</a>.</p>

</div>
</div>
<a class="anchor" id="gae90182b983742cb8e2fa091cffc83aaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHdcp1x_CipherLocalKsvReady</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">((<a class="code" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress, \</div><div class="line">        <a class="code" href="group__hdcp1x__v4__0.html#gae54c355c17e6c20cff27fb271d4a311f">XHDCP1X_CIPHER_REG_KEYMGMT_STATUS</a>) &amp; <a class="code" href="group__hdcp1x__v4__0.html#ga5ac122eb8e2456759a8207831615cc0c">\</a></div><div class="line"><a class="code" href="group__hdcp1x__v4__0.html#ga5ac122eb8e2456759a8207831615cc0c">	XHDCP1X_CIPHER_BITMASK_KEYMGMT_STATUS_KSV_READY</a>) != 0)</div><div class="ttc" id="group__hdcp1x__v4__0_html_ga5ac122eb8e2456759a8207831615cc0c"><div class="ttname"><a href="group__hdcp1x__v4__0.html#ga5ac122eb8e2456759a8207831615cc0c">XHDCP1X_CIPHER_BITMASK_KEYMGMT_STATUS_KSV_READY</a></div><div class="ttdeci">#define XHDCP1X_CIPHER_BITMASK_KEYMGMT_STATUS_KSV_READY</div><div class="ttdoc">Local KSV ready bitmask in Key Management Status register. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:238</div></div>
<div class="ttc" id="group__hdcp1x__v4__0_html_gae54c355c17e6c20cff27fb271d4a311f"><div class="ttname"><a href="group__hdcp1x__v4__0.html#gae54c355c17e6c20cff27fb271d4a311f">XHDCP1X_CIPHER_REG_KEYMGMT_STATUS</a></div><div class="ttdeci">#define XHDCP1X_CIPHER_REG_KEYMGMT_STATUS</div><div class="ttdoc">Key Management Status register offset. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:105</div></div>
<div class="ttc" id="group__hdcp1x__v4__0_html_ga5477e830e157f72072a2a7f470365682"><div class="ttname"><a href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a></div><div class="ttdeci">#define XHdcp1x_ReadReg(BaseAddress, RegOffset)</div><div class="ttdoc">This macro reads a value from a HDCP cipher register. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:338</div></div>
</div><!-- fragment -->
<p>This queries a cipher to determine if the local KSV is ready to read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the instance to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating ready (TRUE) or not (FALSE).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gacc166098738c7aac2703ee0cbd757c01">XHdcp1x_CipherGetLocalKsv()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9d98f541dd4fe90543190e24a4f6b5cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHdcp1x_CipherXorInProgress</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">((<a class="code" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress, \</div><div class="line">        <a class="code" href="group__hdcp1x__v4__0.html#gae3972aa89e01893b3fe8f5218625d512">XHDCP1X_CIPHER_REG_CIPHER_STATUS</a>) &amp; <a class="code" href="group__hdcp1x__v4__0.html#ga0b6854f289450df142cde1637a13092b">\</a></div><div class="line"><a class="code" href="group__hdcp1x__v4__0.html#ga0b6854f289450df142cde1637a13092b">	XHDCP1X_CIPHER_BITMASK_CIPHER_STATUS_XOR_IN_PROG</a>) != 0)</div><div class="ttc" id="group__hdcp1x__v4__0_html_gae3972aa89e01893b3fe8f5218625d512"><div class="ttname"><a href="group__hdcp1x__v4__0.html#gae3972aa89e01893b3fe8f5218625d512">XHDCP1X_CIPHER_REG_CIPHER_STATUS</a></div><div class="ttdeci">#define XHDCP1X_CIPHER_REG_CIPHER_STATUS</div><div class="ttdoc">Cipher Status register offset. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:131</div></div>
<div class="ttc" id="group__hdcp1x__v4__0_html_ga5477e830e157f72072a2a7f470365682"><div class="ttname"><a href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a></div><div class="ttdeci">#define XHdcp1x_ReadReg(BaseAddress, RegOffset)</div><div class="ttdoc">This macro reads a value from a HDCP cipher register. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:338</div></div>
<div class="ttc" id="group__hdcp1x__v4__0_html_ga0b6854f289450df142cde1637a13092b"><div class="ttname"><a href="group__hdcp1x__v4__0.html#ga0b6854f289450df142cde1637a13092b">XHDCP1X_CIPHER_BITMASK_CIPHER_STATUS_XOR_IN_PROG</a></div><div class="ttdeci">#define XHDCP1X_CIPHER_BITMASK_CIPHER_STATUS_XOR_IN_PROG</div><div class="ttdoc">XOR In Progress bitmask in Cipher Status register. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:260</div></div>
</div><!-- fragment -->
<p>This queries a cipher to determine if the XOR (encryption) function is currently in progress. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the instance to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating in progress (TRUE) or not (FALSE).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga706d8729ad07f34fad5e20f83c59d69f">XHdcp1x_CipherEnableEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae38ae0f74022763d8650a21fedcd15e5">XHdcp1x_CipherGetEncryption()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="ga23b1e82440c42ddc2ff5f54aa40932c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_DEBUG_H</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__debug_8h.html">xhdcp1x_debug.h</a>&gt;</code></p>

<p>&lt; Prevent circular inclusions by using protection macros </p>

</div>
</div>
<a class="anchor" id="ga83e87d466be18c22a62503f408c341cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_DEBUG_LOGMSG&#160;&#160;&#160;if (<a class="el" href="group__hdcp1x__v4__0.html#ga2c89c757bb1b6bb6c904b67afad4f624">XHdcp1xDebugLogMsg</a> != NULL) <a class="el" href="group__hdcp1x__v4__0.html#ga2c89c757bb1b6bb6c904b67afad4f624">XHdcp1xDebugLogMsg</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__debug_8h.html">xhdcp1x_debug.h</a>&gt;</code></p>

<p>Instance of the function interface used for debug log messages. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga5345387226f345c288ee244f369d8ed5">XHdcp1x_TxDisableBlank()</a>.</p>

</div>
</div>
<a class="anchor" id="ga66e1b425725213dd4d5231bf5710e04f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_DEBUG_PRINTF&#160;&#160;&#160;if (<a class="el" href="group__hdcp1x__v4__0.html#ga9edfb21b66722d61af03129b4dcbb734">XHdcp1xDebugPrintf</a> != NULL) <a class="el" href="group__hdcp1x__v4__0.html#ga9edfb21b66722d61af03129b4dcbb734">XHdcp1xDebugPrintf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__debug_8h.html">xhdcp1x_debug.h</a>&gt;</code></p>

<p>Instance of the function interface used for debug print statements. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga1030400c6c423608ffd155b9cb4d12ef">XHdcp1x_GetTopology()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga7f8a11ce5614a2541b378f034b3198cb">XHdcp1x_Info()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gac0c5947639623f7b97d9ec1cc712e75f">XHdcp1x_IsRepeater()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga89cf71a1a7edefa4671fdefa3cc7222b">XHdcp1x_RxInfo()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaba8f1fa8b28a519d192f1183fae62344">XHdcp1x_SetTopologyUpdate()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gaa503ece3533fb6055289ad2dd01ba80b">XHdcp1x_TxInfo()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf843d589f3817803c0b55743ed4681a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_H</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>&lt; Prevent circular inclusions by using protection macros </p>

</div>
</div>
<a class="anchor" id="ga8262573a0c348ed5cec9f44b279c3356"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_HW_H</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>&lt; Prevent circular inclusions by using protection macros </p>

</div>
</div>
<a class="anchor" id="ga97852d12d6d27dbf95f755aa5e3c44e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHdcp1x_In32&#160;&#160;&#160;Xil_In32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Input Operations. </p>

</div>
</div>
<a class="anchor" id="ga2870575e04b7a20bca6801f47f1f2169"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHdcp1x_IsDP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">((<a class="code" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress, \</div><div class="line">        <a class="code" href="group__hdcp1x__v4__0.html#gaed76d9474c5b8112f70540b4b13430cf">XHDCP1X_CIPHER_REG_TYPE</a>) &amp; <a class="code" href="group__hdcp1x__v4__0.html#ga0798856f180c219e38c507a192e3ae1f">XHDCP1X_CIPHER_BITMASK_TYPE_PROTOCOL</a>) \</div><div class="line">        == <a class="code" href="group__hdcp1x__v4__0.html#ga5ed9ffd759a96f662221c27cfca0b985">XHDCP1X_CIPHER_VALUE_TYPE_PROTOCOL_DP</a>)</div><div class="ttc" id="group__hdcp1x__v4__0_html_ga0798856f180c219e38c507a192e3ae1f"><div class="ttname"><a href="group__hdcp1x__v4__0.html#ga0798856f180c219e38c507a192e3ae1f">XHDCP1X_CIPHER_BITMASK_TYPE_PROTOCOL</a></div><div class="ttdeci">#define XHDCP1X_CIPHER_BITMASK_TYPE_PROTOCOL</div><div class="ttdoc">Protocol bitmask in Type register. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:178</div></div>
<div class="ttc" id="group__hdcp1x__v4__0_html_gaed76d9474c5b8112f70540b4b13430cf"><div class="ttname"><a href="group__hdcp1x__v4__0.html#gaed76d9474c5b8112f70540b4b13430cf">XHDCP1X_CIPHER_REG_TYPE</a></div><div class="ttdeci">#define XHDCP1X_CIPHER_REG_TYPE</div><div class="ttdoc">Type register offset. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:75</div></div>
<div class="ttc" id="group__hdcp1x__v4__0_html_ga5477e830e157f72072a2a7f470365682"><div class="ttname"><a href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a></div><div class="ttdeci">#define XHdcp1x_ReadReg(BaseAddress, RegOffset)</div><div class="ttdoc">This macro reads a value from a HDCP cipher register. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:338</div></div>
<div class="ttc" id="group__hdcp1x__v4__0_html_ga5ed9ffd759a96f662221c27cfca0b985"><div class="ttname"><a href="group__hdcp1x__v4__0.html#ga5ed9ffd759a96f662221c27cfca0b985">XHDCP1X_CIPHER_VALUE_TYPE_PROTOCOL_DP</a></div><div class="ttdeci">#define XHDCP1X_CIPHER_VALUE_TYPE_PROTOCOL_DP</div><div class="ttdoc">DP Protocol value in Type register. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:283</div></div>
</div><!-- fragment -->
<p>This macro checks if a core supports the Display Port protocol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_hdcp1x.html" title="This typedef contains an instance of an HDCP interface. ">XHdcp1x</a> core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating DP (TRUE) or not (FALSE) </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga458350d13807e4d1c4d3655167ec6f03">XHdcp1x_CipherInit()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gac3912c6a86498e0559470ce8ce148cd1">XHdcp1x_CipherSetLinkStateCheck()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga710df77b22f0b5c728a51747be26ca2e">XHdcp1x_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga43765c1afc08c59a03b619d0c822e8b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHdcp1x_IsHDMI</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">((<a class="code" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress, \</div><div class="line">        <a class="code" href="group__hdcp1x__v4__0.html#gaed76d9474c5b8112f70540b4b13430cf">XHDCP1X_CIPHER_REG_TYPE</a>) &amp; <a class="code" href="group__hdcp1x__v4__0.html#ga0798856f180c219e38c507a192e3ae1f">XHDCP1X_CIPHER_BITMASK_TYPE_PROTOCOL</a>) \</div><div class="line">        == <a class="code" href="group__hdcp1x__v4__0.html#ga680a297bf1b072fd0d516a07e311d4de">XHDCP1X_CIPHER_VALUE_TYPE_PROTOCOL_HDMI</a>)</div><div class="ttc" id="group__hdcp1x__v4__0_html_ga0798856f180c219e38c507a192e3ae1f"><div class="ttname"><a href="group__hdcp1x__v4__0.html#ga0798856f180c219e38c507a192e3ae1f">XHDCP1X_CIPHER_BITMASK_TYPE_PROTOCOL</a></div><div class="ttdeci">#define XHDCP1X_CIPHER_BITMASK_TYPE_PROTOCOL</div><div class="ttdoc">Protocol bitmask in Type register. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:178</div></div>
<div class="ttc" id="group__hdcp1x__v4__0_html_ga680a297bf1b072fd0d516a07e311d4de"><div class="ttname"><a href="group__hdcp1x__v4__0.html#ga680a297bf1b072fd0d516a07e311d4de">XHDCP1X_CIPHER_VALUE_TYPE_PROTOCOL_HDMI</a></div><div class="ttdeci">#define XHDCP1X_CIPHER_VALUE_TYPE_PROTOCOL_HDMI</div><div class="ttdoc">HDMI Protocol value in Type register. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:287</div></div>
<div class="ttc" id="group__hdcp1x__v4__0_html_gaed76d9474c5b8112f70540b4b13430cf"><div class="ttname"><a href="group__hdcp1x__v4__0.html#gaed76d9474c5b8112f70540b4b13430cf">XHDCP1X_CIPHER_REG_TYPE</a></div><div class="ttdeci">#define XHDCP1X_CIPHER_REG_TYPE</div><div class="ttdoc">Type register offset. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:75</div></div>
<div class="ttc" id="group__hdcp1x__v4__0_html_ga5477e830e157f72072a2a7f470365682"><div class="ttname"><a href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a></div><div class="ttdeci">#define XHdcp1x_ReadReg(BaseAddress, RegOffset)</div><div class="ttdoc">This macro reads a value from a HDCP cipher register. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:338</div></div>
</div><!-- fragment -->
<p>This macro checks if a core supports the HDMI protocol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_hdcp1x.html" title="This typedef contains an instance of an HDCP interface. ">XHdcp1x</a> core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating HDMI (TRUE) or not (FALSE) </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga49cf0f72f0d918e33d66ff40c91d3073">XHdcp1x_CipherDisableEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad104aebb80bb03cb66c31eaabf21247a">XHdcp1x_CipherSetNumLanes()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae2ae95918ecd46e725812a9bce8f6478">XHdcp1x_CipherSetRiUpdate()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga710df77b22f0b5c728a51747be26ca2e">XHdcp1x_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="gae45c2870e08ccd6d6e51409ede847c80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHdcp1x_IsRX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">((<a class="code" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress, \</div><div class="line">        <a class="code" href="group__hdcp1x__v4__0.html#gaed76d9474c5b8112f70540b4b13430cf">XHDCP1X_CIPHER_REG_TYPE</a>) &amp; <a class="code" href="group__hdcp1x__v4__0.html#ga84b710cd1da8802a7dce1a7a637fb7f4">XHDCP1X_CIPHER_BITMASK_TYPE_DIRECTION</a>) \</div><div class="line">        == <a class="code" href="group__hdcp1x__v4__0.html#ga7ed6efb073f7ca9454407f78461a1967">XHDCP1X_CIPHER_VALUE_TYPE_DIRECTION_RX</a>)</div><div class="ttc" id="group__hdcp1x__v4__0_html_ga7ed6efb073f7ca9454407f78461a1967"><div class="ttname"><a href="group__hdcp1x__v4__0.html#ga7ed6efb073f7ca9454407f78461a1967">XHDCP1X_CIPHER_VALUE_TYPE_DIRECTION_RX</a></div><div class="ttdeci">#define XHDCP1X_CIPHER_VALUE_TYPE_DIRECTION_RX</div><div class="ttdoc">RX Direction value in Type register. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:292</div></div>
<div class="ttc" id="group__hdcp1x__v4__0_html_ga84b710cd1da8802a7dce1a7a637fb7f4"><div class="ttname"><a href="group__hdcp1x__v4__0.html#ga84b710cd1da8802a7dce1a7a637fb7f4">XHDCP1X_CIPHER_BITMASK_TYPE_DIRECTION</a></div><div class="ttdeci">#define XHDCP1X_CIPHER_BITMASK_TYPE_DIRECTION</div><div class="ttdoc">Direction bitmask in Type register. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:182</div></div>
<div class="ttc" id="group__hdcp1x__v4__0_html_gaed76d9474c5b8112f70540b4b13430cf"><div class="ttname"><a href="group__hdcp1x__v4__0.html#gaed76d9474c5b8112f70540b4b13430cf">XHDCP1X_CIPHER_REG_TYPE</a></div><div class="ttdeci">#define XHDCP1X_CIPHER_REG_TYPE</div><div class="ttdoc">Type register offset. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:75</div></div>
<div class="ttc" id="group__hdcp1x__v4__0_html_ga5477e830e157f72072a2a7f470365682"><div class="ttname"><a href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a></div><div class="ttdeci">#define XHdcp1x_ReadReg(BaseAddress, RegOffset)</div><div class="ttdoc">This macro reads a value from a HDCP cipher register. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:338</div></div>
</div><!-- fragment -->
<p>This macro checks if a core supports the receive direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_hdcp1x.html" title="This typedef contains an instance of an HDCP interface. ">XHdcp1x</a> core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating receive (TRUE) or not (FALSE) </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga49cf0f72f0d918e33d66ff40c91d3073">XHdcp1x_CipherDisableEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa3f73058855c8d60cbd588d74e60a668">XHdcp1x_CipherEnable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga706d8729ad07f34fad5e20f83c59d69f">XHdcp1x_CipherEnableEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gac3912c6a86498e0559470ce8ce148cd1">XHdcp1x_CipherSetLinkStateCheck()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga710df77b22f0b5c728a51747be26ca2e">XHdcp1x_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0eb257e3b2af7d84e72e89dd93703d3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHdcp1x_IsTX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">((<a class="code" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress, \</div><div class="line">        <a class="code" href="group__hdcp1x__v4__0.html#gaed76d9474c5b8112f70540b4b13430cf">XHDCP1X_CIPHER_REG_TYPE</a>) &amp; <a class="code" href="group__hdcp1x__v4__0.html#ga84b710cd1da8802a7dce1a7a637fb7f4">XHDCP1X_CIPHER_BITMASK_TYPE_DIRECTION</a>) \</div><div class="line">        == <a class="code" href="group__hdcp1x__v4__0.html#gaadbc4627cd5bf1f2f2c0726f8375b5ce">XHDCP1X_CIPHER_VALUE_TYPE_DIRECTION_TX</a>)</div><div class="ttc" id="group__hdcp1x__v4__0_html_ga84b710cd1da8802a7dce1a7a637fb7f4"><div class="ttname"><a href="group__hdcp1x__v4__0.html#ga84b710cd1da8802a7dce1a7a637fb7f4">XHDCP1X_CIPHER_BITMASK_TYPE_DIRECTION</a></div><div class="ttdeci">#define XHDCP1X_CIPHER_BITMASK_TYPE_DIRECTION</div><div class="ttdoc">Direction bitmask in Type register. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:182</div></div>
<div class="ttc" id="group__hdcp1x__v4__0_html_gaed76d9474c5b8112f70540b4b13430cf"><div class="ttname"><a href="group__hdcp1x__v4__0.html#gaed76d9474c5b8112f70540b4b13430cf">XHDCP1X_CIPHER_REG_TYPE</a></div><div class="ttdeci">#define XHDCP1X_CIPHER_REG_TYPE</div><div class="ttdoc">Type register offset. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:75</div></div>
<div class="ttc" id="group__hdcp1x__v4__0_html_gaadbc4627cd5bf1f2f2c0726f8375b5ce"><div class="ttname"><a href="group__hdcp1x__v4__0.html#gaadbc4627cd5bf1f2f2c0726f8375b5ce">XHDCP1X_CIPHER_VALUE_TYPE_DIRECTION_TX</a></div><div class="ttdeci">#define XHDCP1X_CIPHER_VALUE_TYPE_DIRECTION_TX</div><div class="ttdoc">TX Direction value in Type register. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:296</div></div>
<div class="ttc" id="group__hdcp1x__v4__0_html_ga5477e830e157f72072a2a7f470365682"><div class="ttname"><a href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a></div><div class="ttdeci">#define XHdcp1x_ReadReg(BaseAddress, RegOffset)</div><div class="ttdoc">This macro reads a value from a HDCP cipher register. </div><div class="ttdef"><b>Definition:</b> xhdcp1x_hw.h:338</div></div>
</div><!-- fragment -->
<p>This macro checks if a core supports the transmit direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_hdcp1x.html" title="This typedef contains an instance of an HDCP interface. ">XHdcp1x</a> core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating transmit (TRUE) or not (FALSE) </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga710df77b22f0b5c728a51747be26ca2e">XHdcp1x_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="gadc5bb3b8c7dfb1a9b6ce34853cd04823"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_KSV_SIZE&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>Size of each hdcp 1.4 Public Key in bytes. </p>

</div>
</div>
<a class="anchor" id="ga4797628ed0ce1674c0e34d410185e29c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHdcp1x_Out32&#160;&#160;&#160;Xil_Out32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>Output Operations. </p>

</div>
</div>
<a class="anchor" id="ga6d720dad094a6cd5b5bfbd81d97086a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PLATFORM_H</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__platform_8h.html">xhdcp1x_platform.h</a>&gt;</code></p>

<p>&lt; Prevent circular inclusions by using protection macros </p>

</div>
</div>
<a class="anchor" id="gad2baf460af0b886a5b2aedcc3085049b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BCLR_IN_BUF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bitnum&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;buf[(bitnum) &gt;&gt; 3] &amp;= ~(1u &lt;&lt; ((bitnum) &amp; 0x07u));</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port_8h.html">xhdcp1x_port.h</a>&gt;</code></p>

<p>This macro clears a bit within a little endian formatted buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer to write to </td></tr>
    <tr><td class="paramname">bitnum</td><td>the bit to clear</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3e0e68475a7bc3c4c23dd0eee76f242a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BINFO_BIT_DEPTH_ERR&#160;&#160;&#160;(1u &lt;&lt; 11)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>BInfo Depth Error Mask. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gaf854c758691f491c5f80e89a795f2a24">XHdcp1x_TxGetTopologyMaxCascadeExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="gab88032bfe3c80ce9595f52f48091914d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BINFO_BIT_DEPTH_NO_ERR&#160;&#160;&#160;(0u &lt;&lt; 11)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>BInfo Depth Error for No Error Mask. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6aff792c7dfb910015f1ebced29ce96f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BINFO_BIT_DEV_CNT_ERR&#160;&#160;&#160;(1u &lt;&lt; 7)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>BInfo Device Count Error Mask. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga029629390d42624ba18930e5d73a948e">XHdcp1x_TxGetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="ga37f36590f4f72b858001b286ce2278d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BINFO_BIT_DEV_CNT_NO_ERR&#160;&#160;&#160;(0u &lt;&lt; 7)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>BInfo Device Count for No Error Mask. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="ga16aec39989dd4deb2e7bf9a7ce1af17a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BINFO_DEPTH_ERR_SHIFT&#160;&#160;&#160;(11)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>BStatus Depth Error Shift Mask. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gae3eacc3ce1104040154509de3edd755f">XHdcp1x_RxSetTopologyMaxCascadeExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="ga044856b96d20dd177bae15e708edd3c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BINFO_DEPTH_SHIFT&#160;&#160;&#160;(8)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>BInfo Device Count Error Mask. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga98c8466e4c104803303ac96d9f2382ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BINFO_DEV_CNT_ERR_SHIFT&#160;&#160;&#160;(7)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>BStatus Device Count Error Shift Mask. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8f35c083b68c84c215d3a4a8a9d7ea12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BINFO_DEV_CNT_MASK&#160;&#160;&#160;(0x7F)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>BInfo Device Count Error Mask. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="gabc5605e0134f25ba2bfd1361bd8d4fbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BIT_AINFO_ENABLE_1d1_FEATURES&#160;&#160;&#160;(1u &lt;&lt;  1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>AInfo Enable 1.1 Features. </p>

</div>
</div>
<a class="anchor" id="ga47f6f33ea4c3abe2a3a85d945329322c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BIT_AINFO_REAUTH_ENABLE_IRQ&#160;&#160;&#160;(1u &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>Ainfo Reauth Enable Mask. </p>

</div>
</div>
<a class="anchor" id="ga202ae17a0584674740d1a4699a5def21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BIT_BCAPS_1d1_FEATURES&#160;&#160;&#160;(1u &lt;&lt;  1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>BCaps HDCP 1.1 Features Support Mask. </p>

</div>
</div>
<a class="anchor" id="gaabed626effe32e0cc5e15057186b8d82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BIT_BCAPS_FAST&#160;&#160;&#160;(1u &lt;&lt;  4)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>BCaps Fast Transfers Mask. </p>

</div>
</div>
<a class="anchor" id="ga85dfd24486175c8ce81f4682edce0d3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BIT_BCAPS_FAST_REAUTH&#160;&#160;&#160;(1u &lt;&lt;  0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>BCaps Fast Reauth Mask. </p>

</div>
</div>
<a class="anchor" id="ga02a0dbcd0f3992f72f3010d44c6741fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BIT_BCAPS_HDCP_CAPABLE&#160;&#160;&#160;(1u &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>BCaps HDCP Capable Mask. </p>

</div>
</div>
<a class="anchor" id="ga31524e8f55bab5db26ee1a8b32b85691"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BIT_BCAPS_HDMI&#160;&#160;&#160;(1u &lt;&lt;  7)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>BCaps HDMI Supported Mask. </p>

</div>
</div>
<a class="anchor" id="ga7343134ccbd4456a19c5789f9226e621"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BIT_BCAPS_READY&#160;&#160;&#160;(1u &lt;&lt;  5)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>BCaps KSV FIFO Ready bit Mask. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="gac91ed4187e3ebfed3c10c66c1ab07234"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BIT_BCAPS_REPEATER&#160;&#160;&#160;(1u &lt;&lt;  6)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>BCaps Repeater Capable Mask. </p>

</div>
</div>
<a class="anchor" id="gac91ed4187e3ebfed3c10c66c1ab07234"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BIT_BCAPS_REPEATER&#160;&#160;&#160;(1u &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>BCaps HDCP Repeater Mask. </p>

</div>
</div>
<a class="anchor" id="ga0c3f0ec04bdfb89e59ff25412971d907"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BIT_BSTATUS_HDMI_MODE&#160;&#160;&#160;(1u &lt;&lt; 12)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>These constants specify the bit definitions within the various fields and/or attributes within the hdcp port. </p>
<p>BStatus HDMI Mode Mask </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="gac77206fca08d48df639b64d9848dd846"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BIT_BSTATUS_LINK_FAILURE&#160;&#160;&#160;(1u &lt;&lt; 2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>BStatus Link Failure Mask. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="ga238771cd5536c2cf6ee36c2b300ac2bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BIT_BSTATUS_READY&#160;&#160;&#160;(1u &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>These constants specify the bit definitions within the various fields and/or attributes within the hdcp port. </p>
<p>BStatus Ready Mask </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9a419d4ab3665f947107e562cbe9f769"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BIT_BSTATUS_REAUTH_REQUEST&#160;&#160;&#160;(1u &lt;&lt; 3)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>BStatus Reauth Request Mask. </p>

</div>
</div>
<a class="anchor" id="gab4c3aec7795d024dd2c37e672d552f1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BIT_BSTATUS_RO_AVAILABLE&#160;&#160;&#160;(1u &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>BStatus Ro available Mask. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf15471088fda7450a5b6c24c5c65e8da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BSET_IN_BUF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bitnum&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;buf[(bitnum) &gt;&gt; 3] |=  (1u &lt;&lt; ((bitnum) &amp; 0x07u));</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port_8h.html">xhdcp1x_port.h</a>&gt;</code></p>

<p>This macro sets a bit within a little endian formatted buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer to write to </td></tr>
    <tr><td class="paramname">bitnum</td><td>the bit to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1f61304755f675caa5adfa5dfaa7d766"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BSTATUS_BIT_DEPTH_ERR&#160;&#160;&#160;(1u &lt;&lt; 11)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>BStatus Depth Error Mask. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gaf854c758691f491c5f80e89a795f2a24">XHdcp1x_TxGetTopologyMaxCascadeExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="ga26b1813e56a378c9a828b078708c3b8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BSTATUS_BIT_DEPTH_NO_ERR&#160;&#160;&#160;(0u &lt;&lt; 11)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>BStatus Depth Error for No Error Mask. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9760b101a94e3f360a0c37b3622d8084"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BSTATUS_BIT_DEV_CNT_ERR&#160;&#160;&#160;(1u &lt;&lt; 7)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>BStatus Device Count Error Mask. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga029629390d42624ba18930e5d73a948e">XHdcp1x_TxGetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf0af4fd4db896ef96b51efecb4edc8be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BSTATUS_BIT_DEV_CNT_NO_ERR&#160;&#160;&#160;(0u &lt;&lt; 7)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>BStatus Device Count for No Error Mask. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6f209255730ba389a6b2ed44a0ba7489"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BSTATUS_DEPTH_ERR_SHIFT&#160;&#160;&#160;(11)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>BStatus Depth Error Shift Mask. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gae3eacc3ce1104040154509de3edd755f">XHdcp1x_RxSetTopologyMaxCascadeExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="ga61336767f855dbc9fe977f855d6cfcd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BSTATUS_DEPTH_SHIFT&#160;&#160;&#160;(8)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>BStatus Device Count Error Mask. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="gaebc022d267ef57dd08d861ff38671fdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BSTATUS_DEV_CNT_ERR_SHIFT&#160;&#160;&#160;(7)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>BStatus Device Count Error Shift Mask. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9fce1aa364b0da511db36570f96f074e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BSTATUS_DEV_CNT_MASK&#160;&#160;&#160;(0x7F)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>BStatus Device Count Error Mask. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="gae20b7b34529b50d90577913851201bf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BTST_IN_BUF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bitnum&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(buf[(bitnum) &gt;&gt; 3] &amp; (1u &lt;&lt; ((bitnum) &amp; 0x07u)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port_8h.html">xhdcp1x_port.h</a>&gt;</code></p>

<p>This macro tests a bit within a little endian formatted buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer containing the bit to test </td></tr>
    <tr><td class="paramname">bitnum</td><td>the bit to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b4d815c1d172e921b83f3685d54012b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_BUF_TO_UINT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">uint, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">numbits&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port_8h.html">xhdcp1x_port.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">if</span> ((numbits) &gt; 0) {                                            \</div><div class="line">                int byte;                                               \</div><div class="line">                uint = 0;                                               \</div><div class="line">                for (byte = (((numbits) - 1) &gt;&gt; 3); byte &gt;= 0; byte--) { \</div><div class="line">                        uint &lt;&lt;= 8;                                     \</div><div class="line">                        uint  |= buf[byte];                             \</div><div class="line">                }                                                       \</div><div class="line">        }</div></div><!-- fragment -->
<p>This macro converts from a little endian formatted buffer to an unsigned integer value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint</td><td>the unsigned integer to write </td></tr>
    <tr><td class="paramname">buf</td><td>the buffer to convert </td></tr>
    <tr><td class="paramname">numbits</td><td>the number of bits within the buffer to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaacbe196b64bd19fe98db62e552b89788">XHdcp1x_TxGetTopologyBKSV()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1a7b2c66b4316eb4ac3d9472a4c3fe32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_DP_H</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>&lt; Prevent circular inclusions by using protection macros </p>

</div>
</div>
<a class="anchor" id="gaec57e0843c8887964dae8ef00c3c3634"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_DPCD_BASE&#160;&#160;&#160;(0x68000u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>This constant defines the base address of the hdcp port within the DPCD address space. </p>
<p>Base Addr in DPCD </p>

</div>
</div>
<a class="anchor" id="ga031431383ebf79ac5230c51596872619"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_H</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port_8h.html">xhdcp1x_port.h</a>&gt;</code></p>

<p>&lt; Prevent circular inclusions by using protection macros </p>

</div>
</div>
<a class="anchor" id="ga76ea6af219c93dc97fa1c5fd3aef6cbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_HDCP_RESET_KSV&#160;&#160;&#160;(0xD0u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>KSV FIFO Read pointer reset Offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="ga317abcf43fb57d32be6b775f0281098e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_HDCP_RESET_KSV_RST&#160;&#160;&#160;(1u &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>KSV FIFO pointer Reset Mask. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="gad7ce2f1b1b2e8f643453a5fc0bcce37a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_HDMI_H</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>&lt; Prevent circular inclusions by using protection macros </p>

</div>
</div>
<a class="anchor" id="ga99893f9f0385518d617593982a8aad71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_AINFO&#160;&#160;&#160;(0x15u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>Ainfo Offset. </p>

</div>
</div>
<a class="anchor" id="ga99893f9f0385518d617593982a8aad71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_AINFO&#160;&#160;&#160;(0x3Bu)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>Ainfo Offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0cf254f7b06dddaade9b80d1474a37d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_AKSV&#160;&#160;&#160;(0x10u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>Aksv Offset. </p>

</div>
</div>
<a class="anchor" id="ga0cf254f7b06dddaade9b80d1474a37d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_AKSV&#160;&#160;&#160;(0x07u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>Aksv Offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="gafc793c58510855ab8647e1b46966ae91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_AN&#160;&#160;&#160;(0x18u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>An Offset. </p>

</div>
</div>
<a class="anchor" id="gafc793c58510855ab8647e1b46966ae91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_AN&#160;&#160;&#160;(0x0Cu)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>An Offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf08fd8380ae111b2568e8663aa673190"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_BCAPS&#160;&#160;&#160;(0x40u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>Bcaps Offset. </p>

</div>
</div>
<a class="anchor" id="gaf08fd8380ae111b2568e8663aa673190"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_BCAPS&#160;&#160;&#160;(0x28u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>Bcaps Offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="ga340474589062fb395d755c3df36b03f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_BINFO&#160;&#160;&#160;(0x2Au)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>Binfo Offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gae3eacc3ce1104040154509de3edd755f">XHdcp1x_RxSetTopologyMaxCascadeExceeded()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf854c758691f491c5f80e89a795f2a24">XHdcp1x_TxGetTopologyMaxCascadeExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga029629390d42624ba18930e5d73a948e">XHdcp1x_TxGetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1865cffebcba3167ab0867e3a276fe12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_BKSV&#160;&#160;&#160;(0x00u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>These constants specify the offsets for the various fields and/or attributes within the hdcp port. </p>
<p>Bksv Offset </p>

</div>
</div>
<a class="anchor" id="ga1865cffebcba3167ab0867e3a276fe12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_BKSV&#160;&#160;&#160;(0x00u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>These constants specify the offsets for the various fields and/or attributes within the hdcp port. </p>
<p>Bksv Offset </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaacbe196b64bd19fe98db62e552b89788">XHdcp1x_TxGetTopologyBKSV()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga735d88629a20a22d8edc3527877160f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_BSTATUS&#160;&#160;&#160;(0x41u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>Bstatus Offset. </p>

</div>
</div>
<a class="anchor" id="ga735d88629a20a22d8edc3527877160f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_BSTATUS&#160;&#160;&#160;(0x29u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>Bstatus Offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae3eacc3ce1104040154509de3edd755f">XHdcp1x_RxSetTopologyMaxCascadeExceeded()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf854c758691f491c5f80e89a795f2a24">XHdcp1x_TxGetTopologyMaxCascadeExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga029629390d42624ba18930e5d73a948e">XHdcp1x_TxGetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="gac15bff7c30598aeb630fec73152050c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_DBG&#160;&#160;&#160;(0xC0u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>Debug Space Offset. </p>

</div>
</div>
<a class="anchor" id="gac15bff7c30598aeb630fec73152050c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_DBG&#160;&#160;&#160;(0xC0u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>Debug Space Offset. </p>

</div>
</div>
<a class="anchor" id="ga89f673f0c9256a50eaef4c136cce3b4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_KSVFIFO&#160;&#160;&#160;(0x43u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>KSV FIFO Offset. </p>

</div>
</div>
<a class="anchor" id="ga89f673f0c9256a50eaef4c136cce3b4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_KSVFIFO&#160;&#160;&#160;(0x2Cu)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>KSV FIFO Offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1845d44ac4816bfd240001a997980a14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_PJ&#160;&#160;&#160;(0x0Au)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>Pj' Offset. </p>

</div>
</div>
<a class="anchor" id="ga232b0f643c7651084bf3b565c5b444ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_RO&#160;&#160;&#160;(0x08u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>Ri'/Ro' Offset. </p>

</div>
</div>
<a class="anchor" id="ga232b0f643c7651084bf3b565c5b444ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_RO&#160;&#160;&#160;(0x05u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>R0' Offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga00bc49959ffae99012af1f81ddc80668"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_VH0&#160;&#160;&#160;(0x20u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>V'.H0 Offset. </p>

</div>
</div>
<a class="anchor" id="ga00bc49959ffae99012af1f81ddc80668"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_VH0&#160;&#160;&#160;(0x14u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>V'.H0 Offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga73cb0b44e5ae774b8c2b6dd5ccca646e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_VH1&#160;&#160;&#160;(0x24u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>V'.H1 Offset. </p>

</div>
</div>
<a class="anchor" id="ga73cb0b44e5ae774b8c2b6dd5ccca646e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_VH1&#160;&#160;&#160;(0x18u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>V'.H1 Offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>.</p>

</div>
</div>
<a class="anchor" id="gae69272331b9a16e7bdf1a5bd0a409ef2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_VH2&#160;&#160;&#160;(0x28u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>V'.H2 Offset. </p>

</div>
</div>
<a class="anchor" id="gae69272331b9a16e7bdf1a5bd0a409ef2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_VH2&#160;&#160;&#160;(0x1Cu)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>V'.H2 Offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>.</p>

</div>
</div>
<a class="anchor" id="ga862d61a28bb713632e726d1d0465e8d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_VH3&#160;&#160;&#160;(0x2Cu)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>V'.H3 Offset. </p>

</div>
</div>
<a class="anchor" id="ga862d61a28bb713632e726d1d0465e8d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_VH3&#160;&#160;&#160;(0x20u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>V'.H3 Offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>.</p>

</div>
</div>
<a class="anchor" id="gae8b5750c01e6b867c5774aa7ca2b81ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_VH4&#160;&#160;&#160;(0x30u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>V'.H4 Offset. </p>

</div>
</div>
<a class="anchor" id="gae8b5750c01e6b867c5774aa7ca2b81ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_OFFSET_VH4&#160;&#160;&#160;(0x24u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>V'.H4 Offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>.</p>

</div>
</div>
<a class="anchor" id="ga61b9d23c4ec1165434d8111157fe8e4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_PRIMARY_I2C_ADDR&#160;&#160;&#160;(0x74u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>This constant defines the i2c address of the hdcp port. </p>
<p>I2C Addr Primary Link </p>

</div>
</div>
<a class="anchor" id="gae50b1553c779f0d7f5996b611746434d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SECONDARY_I2C_ADDR&#160;&#160;&#160;(0x76u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>I2C Addr Secondary Link. </p>

</div>
</div>
<a class="anchor" id="gae46b665a4147e46b47f82189f4930f77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_AINFO&#160;&#160;&#160;(0x01u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>Ainfo Size. </p>

</div>
</div>
<a class="anchor" id="gae46b665a4147e46b47f82189f4930f77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_AINFO&#160;&#160;&#160;(0x01u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>Ainfo Offset. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1b3e2eeb2a7f7ed7c7054bf387e16a10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_AKSV&#160;&#160;&#160;(0x05u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>Aksv Size. </p>

</div>
</div>
<a class="anchor" id="ga1b3e2eeb2a7f7ed7c7054bf387e16a10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_AKSV&#160;&#160;&#160;(0x05u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>Aksv Size. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa49a07e54b5cf34b332e11e7784ef81e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_AN&#160;&#160;&#160;(0x08u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>An Size. </p>

</div>
</div>
<a class="anchor" id="gaa49a07e54b5cf34b332e11e7784ef81e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_AN&#160;&#160;&#160;(0x08u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>An Size. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf1e0df1c7715eebca1993241bb566721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_BCAPS&#160;&#160;&#160;(0x01u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>Bcaps Size. </p>

</div>
</div>
<a class="anchor" id="gaf1e0df1c7715eebca1993241bb566721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_BCAPS&#160;&#160;&#160;(0x01u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>Bcaps Size. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="gab06658de2c710ab133093ac51411f77a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_BINFO&#160;&#160;&#160;(0x02u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>Binfo Size. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gae3eacc3ce1104040154509de3edd755f">XHdcp1x_RxSetTopologyMaxCascadeExceeded()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf854c758691f491c5f80e89a795f2a24">XHdcp1x_TxGetTopologyMaxCascadeExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga029629390d42624ba18930e5d73a948e">XHdcp1x_TxGetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8f589bb54a9c7295aa522dcf5f25fbf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_BKSV&#160;&#160;&#160;(0x05u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>These constants specify the sizes for the various fields and/or attributes within the hdcp port. </p>
<p>Bksv Size </p>

</div>
</div>
<a class="anchor" id="ga8f589bb54a9c7295aa522dcf5f25fbf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_BKSV&#160;&#160;&#160;(0x05u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>These constants specify the sizes for the various fields and/or attributes within the hdcp port. </p>
<p>Bksv Size </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad2d20e2c7ccd2e279a5bd4c3400484d3">XHdcp1x_RxSetTopologyKSVList()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaacbe196b64bd19fe98db62e552b89788">XHdcp1x_TxGetTopologyBKSV()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f5c58db160f9afd130570f0111d094d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_BSTATUS&#160;&#160;&#160;(0x02u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>Bstatus Size. </p>

</div>
</div>
<a class="anchor" id="ga1f5c58db160f9afd130570f0111d094d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_BSTATUS&#160;&#160;&#160;(0x01u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>Bstatus Size. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae3eacc3ce1104040154509de3edd755f">XHdcp1x_RxSetTopologyMaxCascadeExceeded()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf854c758691f491c5f80e89a795f2a24">XHdcp1x_TxGetTopologyMaxCascadeExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga029629390d42624ba18930e5d73a948e">XHdcp1x_TxGetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf16abd16f07a64c8b61e4afc75a12d0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_DBG&#160;&#160;&#160;(0xC0u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>Debug Space Size. </p>

</div>
</div>
<a class="anchor" id="gaf16abd16f07a64c8b61e4afc75a12d0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_DBG&#160;&#160;&#160;(0x40u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>Debug Space Size. </p>

</div>
</div>
<a class="anchor" id="gabfc39119e30fc4f207e32244643d4164"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_HDCP_RESET_KSV&#160;&#160;&#160;(0x40u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>KSV FIFO pointer reset Size. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6fad60e8cce1de54c9496e79c4cf8aa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_KSVFIFO&#160;&#160;&#160;(0x01u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>KSV FIFO Size. </p>

</div>
</div>
<a class="anchor" id="ga6fad60e8cce1de54c9496e79c4cf8aa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_KSVFIFO&#160;&#160;&#160;(0x0Fu)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>KSV FIFO Size. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9298ae53e76f731c30e420d3105b390a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_PJ&#160;&#160;&#160;(0x01u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>Pj' Size. </p>

</div>
</div>
<a class="anchor" id="ga54b1d34de005b41d4cdc3ee4731b4da4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_RO&#160;&#160;&#160;(0x02u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>Ri' Size. </p>

</div>
</div>
<a class="anchor" id="ga54b1d34de005b41d4cdc3ee4731b4da4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_RO&#160;&#160;&#160;(0x02u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>R0' Size. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="gaaf16f91e2feb9a5228c684fd288d7d62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_VH0&#160;&#160;&#160;(0x04u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>V'.H0 Size. </p>

</div>
</div>
<a class="anchor" id="gaaf16f91e2feb9a5228c684fd288d7d62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_VH0&#160;&#160;&#160;(0x04u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>V'.H0 Size. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2adda3ea717e8cb0852072e863e134fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_VH1&#160;&#160;&#160;(0x04u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>V'.H1 Size. </p>

</div>
</div>
<a class="anchor" id="ga2adda3ea717e8cb0852072e863e134fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_VH1&#160;&#160;&#160;(0x04u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>V'.H1 Size. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>.</p>

</div>
</div>
<a class="anchor" id="ga05c100e07d844f50d235266c718a6ebb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_VH2&#160;&#160;&#160;(0x04u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>V'.H2 Size. </p>

</div>
</div>
<a class="anchor" id="ga05c100e07d844f50d235266c718a6ebb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_VH2&#160;&#160;&#160;(0x04u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>V'.H2 Size. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa1a7ca2f7760912e2381fce10a5e4d3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_VH3&#160;&#160;&#160;(0x04u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>V'.H3 Size. </p>

</div>
</div>
<a class="anchor" id="gaa1a7ca2f7760912e2381fce10a5e4d3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_VH3&#160;&#160;&#160;(0x04u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>V'.H3 Size. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>.</p>

</div>
</div>
<a class="anchor" id="gabebfe755929a4b4ca891648334c7aeca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_VH4&#160;&#160;&#160;(0x04u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__hdmi_8h.html">xhdcp1x_port_hdmi.h</a>&gt;</code></p>

<p>V'.H4 Size. </p>

</div>
</div>
<a class="anchor" id="gabebfe755929a4b4ca891648334c7aeca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_SIZE_VH4&#160;&#160;&#160;(0x04u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port__dp_8h.html">xhdcp1x_port_dp.h</a>&gt;</code></p>

<p>V'.H4 Size. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>.</p>

</div>
</div>
<a class="anchor" id="ga62b350f20404434a855f46c62ee888ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_PORT_UINT_TO_BUF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">uint, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">numbits&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port_8h.html">xhdcp1x_port.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">if</span> ((numbits) &gt; 0) {                                            \</div><div class="line">                int byte;                                               \</div><div class="line">                for (byte = 0; byte &lt;= (((numbits) - 1) &gt;&gt; 3); byte++) { \</div><div class="line">                        buf[byte] = (uint8_t) (uint &amp; 0xFFu);           \</div><div class="line">                        uint &gt;&gt;= 8;                                     \</div><div class="line">                }                                                       \</div><div class="line">        }</div></div><!-- fragment -->
<p>This macro converts from an unsigned integer to a little endian formatted buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer to write to </td></tr>
    <tr><td class="paramname">uint</td><td>the unsigned integer to convert </td></tr>
    <tr><td class="paramname">numbits</td><td>the number of bits within the unsigned integer to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The value of the "uint" parameter is destroyed by a call to this macro </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5477e830e157f72072a2a7f470365682"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHdcp1x_ReadReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegOffset&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__hdcp1x__v4__0.html#ga97852d12d6d27dbf95f755aa5e3c44e0">XHdcp1x_In32</a>((BaseAddress) + ((u32)RegOffset))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>This macro reads a value from a HDCP cipher register. </p>
<p>A 32 bit read is always performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the HDCP cipher core instance. </td></tr>
    <tr><td class="paramname">RegOffset</td><td>is the register offset of the register</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32-bit value of the register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style: u32 <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682" title="This macro reads a value from a HDCP cipher register. ">XHdcp1x_ReadReg(UINTPTR BaseAddress, u32 RegOffset)</a> </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga931fc14801a82c9cc3aa870d887bbc07">XHdcp1x_CfgInitialize()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga2ca06586dc06796fdc31a2f64096a28d">XHdcp1x_CipherDisable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa2bcbd719e1f2f9b0b5fe6757b5a14b2">XHdcp1x_CipherDisableBlank()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga49cf0f72f0d918e33d66ff40c91d3073">XHdcp1x_CipherDisableEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad44ad72f65d851de50c40053e327ba9e">XHdcp1x_CipherDoRequest()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa3f73058855c8d60cbd588d74e60a668">XHdcp1x_CipherEnable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga1075068f7db6bf3b0ae31818534f93e8">XHdcp1x_CipherEnableBlank()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga706d8729ad07f34fad5e20f83c59d69f">XHdcp1x_CipherEnableEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga8ecfb468f0917a558f7713ab74903033">XHdcp1x_CipherGetB()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae38ae0f74022763d8650a21fedcd15e5">XHdcp1x_CipherGetEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga987fc5a5170470f0bbff214d317aac17">XHdcp1x_CipherGetK()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gacc166098738c7aac2703ee0cbd757c01">XHdcp1x_CipherGetLocalKsv()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga72d8fd0f45ff6424d3aac43e36360fec">XHdcp1x_CipherGetMi()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad8759c2071248b537b7ae18b2a1ec5a6">XHdcp1x_CipherGetMo()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gacfeb8a266c1bc554753f93d62eb9a891">XHdcp1x_CipherGetNumLanes()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9d260acd4a5eb9842f5a4bbb31be0e36">XHdcp1x_CipherGetRemoteKsv()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9719a81dc9b6815f6b616ccc076f03c2">XHdcp1x_CipherGetRi()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga14ed33ea832900d1022b7a1e8ddba397">XHdcp1x_CipherGetRo()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaac542620e5aa06df5f83f097a6fc7738">XHdcp1x_CipherGetVersion()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga7a718cbfba0847675523d2a89d8a3755">XHdcp1x_CipherHandleInterrupt()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga458350d13807e4d1c4d3655167ec6f03">XHdcp1x_CipherInit()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga40c4838c730476e98dfcd742eb1d21a4">XHdcp1x_CipherIsLinkUp()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gace24c74db709b523e1aae7e082494022">XHdcp1x_CipherIsRequestComplete()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga70bcb7dd61e57e5b33d2213817a80eca">XHdcp1x_CipherSetB()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga89ff306031805dad1e1ff7af0c836873">XHdcp1x_CipherSetK()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga6f0a88da0a794b63e3f6caafa912dc10">XHdcp1x_CipherSetKeySelect()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gac3912c6a86498e0559470ce8ce148cd1">XHdcp1x_CipherSetLinkStateCheck()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad104aebb80bb03cb66c31eaabf21247a">XHdcp1x_CipherSetNumLanes()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga320b0410ab8e10a8bc5c2a6278ed06d7">XHdcp1x_CipherSetRemoteKsv()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae2ae95918ecd46e725812a9bce8f6478">XHdcp1x_CipherSetRiUpdate()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga710df77b22f0b5c728a51747be26ca2e">XHdcp1x_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga217bbf2604a76a1003c907376d4b8710"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_RPTR_MAX_CASCADE&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>Maximum depth that the Repeater can support on the downstream interface. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf421a5651c89ab4e8ff970ff04d60971"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_RPTR_MAX_DEVS_COUNT&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>Maximum devices that can be cascaded to the Repeater. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="gaeb6bb31b2d908a4269f6d6faa536d91c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_RX_H</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8h.html">xhdcp1x_rx.h</a>&gt;</code></p>

<p>&lt; Prevent circular inclusions by using protection macros </p>

</div>
</div>
<a class="anchor" id="gaee0d3b90542ca2c3e1cab416b5cc6071"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHdcp1x_SetCallBack&#160;&#160;&#160;<a class="el" href="group__hdcp1x__v4__0.html#ga145ec2236143e47dd0bb8e31fbf690e4">XHdcp1x_SetCallback</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>Alternative name for the function to set callback for HDCP functions. </p>

</div>
</div>
<a class="anchor" id="ga88e26cb09f1d931e500cdc461b97db45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHDCP1X_TX_H</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8h.html">xhdcp1x_tx.h</a>&gt;</code></p>

<p>&lt; Prevent circular inclusions by using protection macros </p>

</div>
</div>
<a class="anchor" id="ga8e356b098ccbcf8c2a851425e884ac00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XHdcp1x_WriteReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegOffset, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__hdcp1x__v4__0.html#ga4797628ed0ce1674c0e34d410185e29c">XHdcp1x_Out32</a>((BaseAddress) + ((u32)RegOffset), (u32)(Data))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__hw_8h.html">xhdcp1x_hw.h</a>&gt;</code></p>

<p>This macro writes a value to a HDCP cipher register. </p>
<p>A 32 bit write is always performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the HDCP cipher core instance. </td></tr>
    <tr><td class="paramname">RegOffset</td><td>is the register offset of the register </td></tr>
    <tr><td class="paramname">Data</td><td>is the 32-bit value to write into the register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style: void <a class="el" href="group__hdcp1x__v4__0.html#ga8e356b098ccbcf8c2a851425e884ac00" title="This macro writes a value to a HDCP cipher register. ">XHdcp1x_WriteReg(UINTPTR BaseAddress, u32 RegOffset, u32 Data)</a> </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga2ca06586dc06796fdc31a2f64096a28d">XHdcp1x_CipherDisable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa2bcbd719e1f2f9b0b5fe6757b5a14b2">XHdcp1x_CipherDisableBlank()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga49cf0f72f0d918e33d66ff40c91d3073">XHdcp1x_CipherDisableEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad44ad72f65d851de50c40053e327ba9e">XHdcp1x_CipherDoRequest()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa3f73058855c8d60cbd588d74e60a668">XHdcp1x_CipherEnable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga1075068f7db6bf3b0ae31818534f93e8">XHdcp1x_CipherEnableBlank()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga706d8729ad07f34fad5e20f83c59d69f">XHdcp1x_CipherEnableEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gacc166098738c7aac2703ee0cbd757c01">XHdcp1x_CipherGetLocalKsv()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga7a718cbfba0847675523d2a89d8a3755">XHdcp1x_CipherHandleInterrupt()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga458350d13807e4d1c4d3655167ec6f03">XHdcp1x_CipherInit()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga70bcb7dd61e57e5b33d2213817a80eca">XHdcp1x_CipherSetB()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga89ff306031805dad1e1ff7af0c836873">XHdcp1x_CipherSetK()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga6f0a88da0a794b63e3f6caafa912dc10">XHdcp1x_CipherSetKeySelect()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gac3912c6a86498e0559470ce8ce148cd1">XHdcp1x_CipherSetLinkStateCheck()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad104aebb80bb03cb66c31eaabf21247a">XHdcp1x_CipherSetNumLanes()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga320b0410ab8e10a8bc5c2a6278ed06d7">XHdcp1x_CipherSetRemoteKsv()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gae2ae95918ecd46e725812a9bce8f6478">XHdcp1x_CipherSetRiUpdate()</a>.</p>

</div>
</div>
<a class="anchor" id="ga92acc39f4ff403d71aad1122fe939664"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XPAR_XHDCP_NUM_INSTANCES&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__sinit_8c.html">xhdcp1x_sinit.c</a>&gt;</code></p>

<p>Number of HDCP Instances. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga14060c2be4685a3c8d0285e826a2376c">XHdcp1x_LookupConfig()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2d64ba19dac4365d7a379994dd3bbf9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XVPHY_FLAG_IS_REPEATER&#160;&#160;&#160;(1u &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>Flag to track repeater state. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga689829fd2689d3b67c0f4133179979e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XVPHY_FLAG_PHY_UP&#160;&#160;&#160;(1u &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>Flag to track physical state. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>.</p>

</div>
</div>
<a class="anchor" id="ga689829fd2689d3b67c0f4133179979e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XVPHY_FLAG_PHY_UP&#160;&#160;&#160;(1u &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>Flag to track physical state. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="gae0a88c92b220f5a14f3539f90632fedc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XVPHY_TMO_100MS&#160;&#160;&#160;(100u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>Timeout value for 100ms. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>.</p>

</div>
</div>
<a class="anchor" id="gae0a88c92b220f5a14f3539f90632fedc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XVPHY_TMO_100MS&#160;&#160;&#160;(100u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>Timeout value for 100ms. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1166cc4f5ef31f3764bdc10408cfd2b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XVPHY_TMO_1SECOND&#160;&#160;&#160;(1000u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>Timeout value for 1s. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1166cc4f5ef31f3764bdc10408cfd2b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XVPHY_TMO_1SECOND&#160;&#160;&#160;(1000u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>Timeout value for 1s. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="ga21578c4367ba5e7c3648671ae8e5e033"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XVPHY_TMO_5MS&#160;&#160;&#160;(5u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>Timeout value for 5ms. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga21578c4367ba5e7c3648671ae8e5e033"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XVPHY_TMO_5MS&#160;&#160;&#160;(5u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>Timeout value for 5ms. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga22b9b36c134731fc3c2d450b29095e05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XHdcp1x_Callback) (void *CallbackRef)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>This typedef defines the callback interface that is to be used for interrupts within this driver. </p>

</div>
</div>
<a class="anchor" id="gac7c48c250790835096c9df58f4663e3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef u32(* XHdcp1x_GetDdcHandler) (void *HandlerRef)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>This typedef defines the function interface that is to be used to get the DDC handler for implementation of HDCP functionality over HDMI within this driver. </p>

</div>
</div>
<a class="anchor" id="gadbd91cd33664e62ecbb56f01f844632e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef u64 <a class="el" href="group__hdcp1x__v4__0.html#gadbd91cd33664e62ecbb56f01f844632e">XHdcp1x_Ksv</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>This typedef defines a memory to store a Key Selection Vector (KSV) </p>

</div>
</div>
<a class="anchor" id="ga268b0b51f0fc7b58d8c1e21829b52800"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* XHdcp1x_KsvRevokeCheck) (const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *InstancePtr, u64 Ksv)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>This typedef defines the function interface that is to be used for checking a specific KSV against the platforms revocation list. </p>

</div>
</div>
<a class="anchor" id="gaba9f04ac9a482bd9b3696df05868a598"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XHdcp1x_LogMsg) (const char *fmt,...)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>This typedef defines the function interface that is to be used for debug log message statements within this driver. </p>

</div>
</div>
<a class="anchor" id="ga6681326e2357df0dfce67e24c0fa34f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_x_hdcp1x___port_struct.html">XHdcp1x_PortStruct</a>  <a class="el" href="group__hdcp1x__v4__0.html#ga6681326e2357df0dfce67e24c0fa34f3">XHdcp1x_Port</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>This typedef contains an instance of the HDCP port. </p>

</div>
</div>
<a class="anchor" id="gab3390f77e705a54ca5639baa56743d3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_x_hdcp1x___port_phy_if_adaptor_s.html">XHdcp1x_PortPhyIfAdaptorS</a>  <a class="el" href="group__hdcp1x__v4__0.html#gab3390f77e705a54ca5639baa56743d3a">XHdcp1x_PortPhyIfAdaptor</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port_8h.html">xhdcp1x_port.h</a>&gt;</code></p>

<p>The typedef defines the HDCP port adaptor table. </p>
<p>This contains a series of functions that map the external interface of the HDCP port device to the underlying physical interface that it is running over </p>

</div>
</div>
<a class="anchor" id="gaa14ea51a98757da9f24e489130804846"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XHdcp1x_Printf) (const char *fmt,...)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>This typedef defines the function interface that is to be used for debug print statements within this driver. </p>

</div>
</div>
<a class="anchor" id="gaa65e249fd6658172ea7255838d58f434"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* XHdcp1x_RunDdcHandler) (u8 DeviceAddress, u16 ByteCount, u8 *BufferPtr, u8 Stop, void *RefPtr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>Callback type used for calling DDC read and write functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceAddress</td><td>is the (i2c) device address of the HDCP port. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>is the amount of data bytes in the buffer to read or write. </td></tr>
    <tr><td class="paramname">BufferPtr</td><td>is a pointer to a buffer that is used for reading or writing. </td></tr>
    <tr><td class="paramname">Stop</td><td>is a flag to control if a stop token is set or not. </td></tr>
    <tr><td class="paramname">RefPtr</td><td>is a callback reference passed in by the upper layer when setting the DDC reading and writing functions, and passed back to the upper layer when the callback is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS The read action was successful.</li>
<li>XST_FAILURE The read action failed.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf1db793430e747ea474c92fd1939b92d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XHdcp1x_SetDdcHandler) (void *HandlerRef, u32 Data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>This typedef defines the function interface that is to be used for setting the DDC handler for HDMI implementation of HDCP functionality over HDMI within this driver. </p>

</div>
</div>
<a class="anchor" id="ga53900843854068ce4c5d0521ee9d4774"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* XHdcp1x_TimerDelay) (void *InstancePtr, u16 DelayInMs)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>This typedef defines the function interface that is to be used for performing a busy delay on behalf of an HDCP interface. </p>

</div>
</div>
<a class="anchor" id="ga38b1342cb63780a12f13f244c46e315f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* XHdcp1x_TimerStart) (void *InstancePtr, u16 TmoInMs)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>This typedef defines the function interface that is to be used for starting a one shot timer on behalf of an HDCP interface within the underlying platform. </p>

</div>
</div>
<a class="anchor" id="gaea02f57423e496bb1bf659cd6652dd90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* XHdcp1x_TimerStop) (void *InstancePtr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>This typedef defines the function interface that is to be used for stopping a timer on behalf of an HDCP interface. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga72130f310516a6cb153c988dc4cffc40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hdcp1x__v4__0.html#ga72130f310516a6cb153c988dc4cffc40">XHdcp1x_CipherHandlerType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8h.html">xhdcp1x_cipher.h</a>&gt;</code></p>

<p>These constants specify different types of handler and used to differentiate interrupt requests from peripheral. </p>

</div>
</div>
<a class="anchor" id="ga84500fe19b892af19bd0a2a2657b342b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hdcp1x__v4__0.html#ga84500fe19b892af19bd0a2a2657b342b">XHdcp1x_CipherRequestType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8h.html">xhdcp1x_cipher.h</a>&gt;</code></p>

<p>These constants specify different types of authentication requests that can be initiated within a peripheral. </p>

</div>
</div>
<a class="anchor" id="gad497ff7e5f58c2f7aca85eac63aa1ead"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hdcp1x__v4__0.html#gad497ff7e5f58c2f7aca85eac63aa1ead">XHdcp1x_EventType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This enumerates the Event Types for HDCP Transmitter state machine. </p>

</div>
</div>
<a class="anchor" id="gad497ff7e5f58c2f7aca85eac63aa1ead"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hdcp1x__v4__0.html#gad497ff7e5f58c2f7aca85eac63aa1ead">XHdcp1x_EventType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This enumerates the Event Types for HDCP Receiver state machine. </p>

</div>
</div>
<a class="anchor" id="gaa46858c4b302cf0e3f9d59d5c5e6bbb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hdcp1x__v4__0.html#gaa46858c4b302cf0e3f9d59d5c5e6bbb9">XHdcp1x_HandlerType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>These constants are used to identify callback functions. </p>

</div>
</div>
<a class="anchor" id="ga758e8028b33a9204cabc6b8327eacaf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hdcp1x__v4__0.html#ga758e8028b33a9204cabc6b8327eacaf3">XHdcp1x_PortHandlerType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port_8h.html">xhdcp1x_port.h</a>&gt;</code></p>

<p>This typedef defines the different types of handlers that can be registered to service interrupt requests from the HDCP port instance. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga758e8028b33a9204cabc6b8327eacaf3a1763ad0694adf51c42870df78089ec87"></a>XHDCP1X_PORT_HANDLER_AUTHENTICATE&#160;</td><td class="fielddoc">
<p>An (re)auth request. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga302f0754a67536f8c3c55d67be258b6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hdcp1x__v4__0.html#ga302f0754a67536f8c3c55d67be258b6c">XHdcp1x_RepeaterStateMachineHandlerType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>This enumerates the call back for the HDCP Repeater Tx state machine. </p>

</div>
</div>
<a class="anchor" id="ga77e08bb89f104ed64a706a922da5896f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hdcp1x__v4__0.html#ga77e08bb89f104ed64a706a922da5896f">XHdcp1x_Rx_StateType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>This enumerates the State Types for HDCP Receiver state machine. </p>

</div>
</div>
<a class="anchor" id="ga43fd07ca5f1fc3a5d69530b3cc8557ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hdcp1x__v4__0.html#ga43fd07ca5f1fc3a5d69530b3cc8557ff">XHdcp1x_StateType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This enumerates the Event Types for HDCP Transmitter state machine. </p>

</div>
</div>
<a class="anchor" id="ga43fd07ca5f1fc3a5d69530b3cc8557ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hdcp1x__v4__0.html#ga43fd07ca5f1fc3a5d69530b3cc8557ff">XHdcp1x_StateType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This enumerates the State Types for HDCP Receiver state machine. </p>

</div>
</div>
<a class="anchor" id="ga54976f91c0d29039065ce279b6f6d8ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hdcp1x__v4__0.html#ga54976f91c0d29039065ce279b6f6d8ad">XHdcp1x_TopologyField</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>These constants are used to identify fields inside the topology structure. </p>

</div>
</div>
<a class="anchor" id="gace20051fd96dff740475d870b2993468"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hdcp1x__v4__0.html#gace20051fd96dff740475d870b2993468">XHdcp1x_Tx_StateType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>This enumerates the Event Types for HDCP Transmitter state machine. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga103ae62cd1207e7566bf4f39ce946f67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_Authenticate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function initiates authentication of an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to initiate authentication on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf0dcbf2dffdfd9ef4b3d02184f01cab7">XHdcp1x_RxAuthenticate()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gaec7dcf7e211da3d42dc621cb7d062f6c">XHdcp1x_TxAuthenticate()</a>.</p>

</div>
</div>
<a class="anchor" id="ga931fc14801a82c9cc3aa870d887bbc07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x___config.html">XHdcp1x_Config</a> *&#160;</td>
          <td class="paramname"><em>CfgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>PhyIfPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>EffectiveAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function retrieves the configuration for this HDCP instance and fills in the InstancePtr-&gt;Config structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device whose adaptor is to be determined. </td></tr>
    <tr><td class="paramname">CfgPtr</td><td>is the configuration of the instance. </td></tr>
    <tr><td class="paramname">PhyIfPtr</td><td>is pointer to the underlying physical interface. </td></tr>
    <tr><td class="paramname">EffectiveAddr</td><td>is the device base address in the virtual memory space. If the address translation is not used, then the physical address is passed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___port_struct.html#a5c94bb21f0376bd33fe7513be4103d91">XHdcp1x_PortStruct::Adaptor</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a13e72aa53d494ecce37f3d8921e1003d">XHdcp1x_Tx::AuthenticatedCallback</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a2ed2aea26d867cc8b32c23446a8b356f">XHdcp1x_Rx::AuthenticatedCallback</a>, <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a3ebbd48e5bd71035d4c720482f451cb7">XHdcp1x_Rx::DdcGetDataCallback</a>, <a class="el" href="struct_x_hdcp1x___tx.html#afcdeddb51718ba23ccbc9bf5f40b00e1">XHdcp1x_Tx::DdcRead</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a390b07d7f8547e353f2e316e26320829">XHdcp1x_Rx::DdcSetAddressCallback</a>, <a class="el" href="struct_x_hdcp1x___rx.html#ac0d254b702690871c60db2724a071a74">XHdcp1x_Rx::DdcSetDataCallback</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a5f80ddbc1b84614ccbbbf6aa12399c8e">XHdcp1x_Tx::DdcWrite</a>, <a class="el" href="struct_x_hdcp1x___rx.html#afe55c0a1ba26412a5b1671e46e181347">XHdcp1x_Rx::EncryptionUpdateCallback</a>, <a class="el" href="struct_x_hdcp1x___port_phy_if_adaptor_s.html#ad3ea2f8637a70869ff3b0241a54c49a4">XHdcp1x_PortPhyIfAdaptorS::Init</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a70af322f00eac53a663529097cb26235">XHdcp1x_Tx::IsAuthenticatedCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a5037a2415dafe5f92b225bffcf410e81">XHdcp1x_Rx::IsAuthenticatedCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___rx.html#ab5533c3626a8379739bfeb9023771e1f">XHdcp1x_Rx::IsDdcGetDataCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a5c978bfee6f5eb921661efbed3bb58f5">XHdcp1x_Tx::IsDdcReadSet</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a328c110db56d453bf13d63006fe0b342">XHdcp1x_Rx::IsDdcSetAddressCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a71563daf4a5ba6da5d61538de804716e">XHdcp1x_Rx::IsDdcSetDataCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___tx.html#aff2f62fca46ff41d487edf0fe34dc2a6">XHdcp1x_Tx::IsDdcWriteSet</a>, <a class="el" href="struct_x_hdcp1x___rx.html#aab743cb5c6259e89858dce2bac9d01b6">XHdcp1x_Rx::IsEncryptionUpdateCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___config.html#a737c4d0a7a9ceb9297a7383bf87a00c9">XHdcp1x_Config::IsHDMI</a>, <a class="el" href="struct_x_hdcp1x.html#a0486da7e6f9a79ef7a2a86ffce168d0c">XHdcp1x::IsReady</a>, <a class="el" href="struct_x_hdcp1x___rx.html#ac6f5ed90fdcf991e41131d1937bf2f56">XHdcp1x_Rx::IsRepeaterDownstreamAuthCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a3e2bb59f4101bf76db71060e0e2f310e">XHdcp1x_Tx::IsRepeaterExchangeCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a9f414f91312d6753b5f704030051bc19">XHdcp1x_Rx::IsTopologyUpdateCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___tx.html#af22151e0777ff7de84b9ae6e3da0561d">XHdcp1x_Tx::IsUnauthenticatedCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___rx.html#aba6af280761ee6bb27641062363c9ed6">XHdcp1x_Rx::IsUnauthenticatedCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___port_struct.html#a145e6dcca2e8b57b000b3ef843decd67">XHdcp1x_PortStruct::PhyIfPtr</a>, <a class="el" href="struct_x_hdcp1x.html#a8234eabad6b1c38cb2cb725ef0ab9b47">XHdcp1x::Port</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a1f9029cd792e5539b37eb2f3f8f5dce4">XHdcp1x_Rx::RepeaterDownstreamAuthCallback</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a447d308ccbf30a72a603ebdeb534d3ce">XHdcp1x_Tx::RepeaterExchangeCallback</a>, <a class="el" href="struct_x_hdcp1x.html#a0a37ba675983dce379385f3f84db9172">XHdcp1x::Rx</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a090a75d1f1d6d838d55d4d8d8eb4de7e">XHdcp1x_Rx::TopologyUpdateCallback</a>, <a class="el" href="struct_x_hdcp1x.html#af50e04f7bdf73163fb7632b0ab004d8a">XHdcp1x::Tx</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a67bc52721c7f0780e6a2e9cc80b82340">XHdcp1x_Tx::UnauthenticatedCallback</a>, <a class="el" href="struct_x_hdcp1x___rx.html#ae328e636837cd6fbe4488153f69b4c3f">XHdcp1x_Rx::UnauthenticatedCallback</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga84b710cd1da8802a7dce1a7a637fb7f4">XHDCP1X_CIPHER_BITMASK_TYPE_DIRECTION</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga0798856f180c219e38c507a192e3ae1f">XHDCP1X_CIPHER_BITMASK_TYPE_PROTOCOL</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaed76d9474c5b8112f70540b4b13430cf">XHDCP1X_CIPHER_REG_TYPE</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga7ed6efb073f7ca9454407f78461a1967">XHDCP1X_CIPHER_VALUE_TYPE_DIRECTION_RX</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga680a297bf1b072fd0d516a07e311d4de">XHDCP1X_CIPHER_VALUE_TYPE_PROTOCOL_HDMI</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga458350d13807e4d1c4d3655167ec6f03">XHdcp1x_CipherInit()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf5f729774d507b92940336ef2112939a">XHdcp1x_PortDetermineAdaptor()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga45e3bcb6feba3b09d84567db489a8f86">XHdcp1x_RxInit()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga7cff233ed850c294c88271be7f76235e">XHdcp1x_TxInit()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2ca06586dc06796fdc31a2f64096a28d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_CipherDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function disables a HDCP cipher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad79579919909139a889131cfca73eef5">XHDCP1X_CIPHER_BITMASK_CIPHER_CONTROL_XOR_ENABLE</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga10ea0666c02c4c6343b9ae9e251ae6a3">XHDCP1X_CIPHER_BITMASK_CONTROL_ENABLE</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga26e1542eb772b2449973d200297da4f4">XHDCP1X_CIPHER_BITMASK_CONTROL_UPDATE</a>, <a class="el" href="group__hdcp1x__v4__0.html#gabdf7f5d97b37f0649c697488cc36bc3b">XHDCP1X_CIPHER_REG_CIPHER_CONTROL</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga388ba97163cd68f5e6124a80bd78c30d">XHDCP1X_CIPHER_REG_CONTROL</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9e2aef2d07c6314c854fef365f381036">XHDCP1X_CIPHER_REG_ENCRYPT_ENABLE_H</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaefc63f94eea644f969857f99264a9a5a">XHDCP1X_CIPHER_REG_ENCRYPT_ENABLE_L</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf2d2522cb49e8fb546d3f19cc27bc550">XHDCP1X_CIPHER_REG_INTERRUPT_MASK</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga8e356b098ccbcf8c2a851425e884ac00">XHdcp1x_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa2bcbd719e1f2f9b0b5fe6757b5a14b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_CipherDisableBlank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function sets the cipher blank select to FALSE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf79f131e95519546c77b8fc62abeddc4">XHDCP1X_CIPHER_BITMASK_BLANK_SEL</a>, <a class="el" href="group__hdcp1x__v4__0.html#gac375f416684e4c6180a85c3689a149d4">XHDCP1X_CIPHER_REG_BLANK_SEL</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga8e356b098ccbcf8c2a851425e884ac00">XHdcp1x_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga5345387226f345c288ee244f369d8ed5">XHdcp1x_TxDisableBlank()</a>.</p>

</div>
</div>
<a class="anchor" id="ga49cf0f72f0d918e33d66ff40c91d3073"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_CipherDisableEncryption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>StreamMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function disables encryption on a set of streams. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to configure. </td></tr>
    <tr><td class="paramname">StreamMap</td><td>is the bit map of streams to disable encryption on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_NOT_ENABLE if the core is not enabled.</li>
<li>XST_FAILURE otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad79579919909139a889131cfca73eef5">XHDCP1X_CIPHER_BITMASK_CIPHER_CONTROL_XOR_ENABLE</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga26e1542eb772b2449973d200297da4f4">XHDCP1X_CIPHER_BITMASK_CONTROL_UPDATE</a>, <a class="el" href="group__hdcp1x__v4__0.html#gabdf7f5d97b37f0649c697488cc36bc3b">XHDCP1X_CIPHER_REG_CIPHER_CONTROL</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga388ba97163cd68f5e6124a80bd78c30d">XHDCP1X_CIPHER_REG_CONTROL</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9e2aef2d07c6314c854fef365f381036">XHDCP1X_CIPHER_REG_ENCRYPT_ENABLE_H</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaefc63f94eea644f969857f99264a9a5a">XHDCP1X_CIPHER_REG_ENCRYPT_ENABLE_L</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa99360d2e6f5cc2071ff95729c222344">XHdcp1x_CipherIsEnabled</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga43765c1afc08c59a03b619d0c822e8b7">XHdcp1x_IsHDMI</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae45c2870e08ccd6d6e51409ede847c80">XHdcp1x_IsRX</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga8e356b098ccbcf8c2a851425e884ac00">XHdcp1x_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad8b45d2c6a594bdb5210c443d1d0020d">XHdcp1x_TxDisableEncryption()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="gad44ad72f65d851de50c40053e327ba9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_CipherDoRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hdcp1x__v4__0.html#ga84500fe19b892af19bd0a2a2657b342b">XHdcp1x_CipherRequestType</a>&#160;</td>
          <td class="paramname"><em>Request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function initiates a request within the HDCP cipher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to submit the request to. </td></tr>
    <tr><td class="paramname">Request</td><td>is the request to submit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_NOT_ENABLE if the core is disabled.</li>
<li>XST_DEVICE_BUSY if the core is busy.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf0b6126446543cb6cb9be5b0aa90801d">XHDCP1X_CIPHER_BITMASK_CIPHER_CONTROL_REQUEST</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga57d495d46e345da61f512d5c33d3dbd9">XHDCP1X_CIPHER_BITMASK_CIPHER_STATUS_REQUEST_IN_PROG</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga26e1542eb772b2449973d200297da4f4">XHDCP1X_CIPHER_BITMASK_CONTROL_UPDATE</a>, <a class="el" href="group__hdcp1x__v4__0.html#gabdf7f5d97b37f0649c697488cc36bc3b">XHDCP1X_CIPHER_REG_CIPHER_CONTROL</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae3972aa89e01893b3fe8f5218625d512">XHDCP1X_CIPHER_REG_CIPHER_STATUS</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga388ba97163cd68f5e6124a80bd78c30d">XHDCP1X_CIPHER_REG_CONTROL</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga325ae78cb623a0eea61b1e4de1a26d2c">XHDCP1X_CIPHER_VALUE_CIPHER_CONTROL_REQUEST_BLOCK</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa99360d2e6f5cc2071ff95729c222344">XHdcp1x_CipherIsEnabled</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga8e356b098ccbcf8c2a851425e884ac00">XHdcp1x_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa3f73058855c8d60cbd588d74e60a668"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_CipherEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function enables a HDCP cipher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad79579919909139a889131cfca73eef5">XHDCP1X_CIPHER_BITMASK_CIPHER_CONTROL_XOR_ENABLE</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga10ea0666c02c4c6343b9ae9e251ae6a3">XHDCP1X_CIPHER_BITMASK_CONTROL_ENABLE</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga26e1542eb772b2449973d200297da4f4">XHDCP1X_CIPHER_BITMASK_CONTROL_UPDATE</a>, <a class="el" href="group__hdcp1x__v4__0.html#gabdf7f5d97b37f0649c697488cc36bc3b">XHDCP1X_CIPHER_REG_CIPHER_CONTROL</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga388ba97163cd68f5e6124a80bd78c30d">XHDCP1X_CIPHER_REG_CONTROL</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9e2aef2d07c6314c854fef365f381036">XHDCP1X_CIPHER_REG_ENCRYPT_ENABLE_H</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaefc63f94eea644f969857f99264a9a5a">XHDCP1X_CIPHER_REG_ENCRYPT_ENABLE_L</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa99360d2e6f5cc2071ff95729c222344">XHdcp1x_CipherIsEnabled</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae45c2870e08ccd6d6e51409ede847c80">XHdcp1x_IsRX</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga8e356b098ccbcf8c2a851425e884ac00">XHdcp1x_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1075068f7db6bf3b0ae31818534f93e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_CipherEnableBlank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function sets the cipher blank value to 0x0000FF (blue), and sets the cipher blank select to TRUE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf79f131e95519546c77b8fc62abeddc4">XHDCP1X_CIPHER_BITMASK_BLANK_SEL</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga4922903951c850d40666a25feaed783a">XHDCP1X_CIPHER_BITMASK_BLANK_VALUE</a>, <a class="el" href="group__hdcp1x__v4__0.html#gac375f416684e4c6180a85c3689a149d4">XHDCP1X_CIPHER_REG_BLANK_SEL</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9ac8d8f8ab7abc814ada20ee259aa1d2">XHDCP1X_CIPHER_REG_BLANK_VALUE</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga8e356b098ccbcf8c2a851425e884ac00">XHdcp1x_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga610b320cce6d9ee99a4f8c2380f2c852">XHdcp1x_TxEnableBlank()</a>.</p>

</div>
</div>
<a class="anchor" id="ga706d8729ad07f34fad5e20f83c59d69f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_CipherEnableEncryption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>StreamMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function enables encryption on a set of streams. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to configure. </td></tr>
    <tr><td class="paramname">StreamMap</td><td>is the bit map of streams to enable encryption on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_NOT_ENABLE if the core is not enabled.</li>
<li>XST_FAILURE otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad79579919909139a889131cfca73eef5">XHDCP1X_CIPHER_BITMASK_CIPHER_CONTROL_XOR_ENABLE</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga26e1542eb772b2449973d200297da4f4">XHDCP1X_CIPHER_BITMASK_CONTROL_UPDATE</a>, <a class="el" href="group__hdcp1x__v4__0.html#gabdf7f5d97b37f0649c697488cc36bc3b">XHDCP1X_CIPHER_REG_CIPHER_CONTROL</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga388ba97163cd68f5e6124a80bd78c30d">XHDCP1X_CIPHER_REG_CONTROL</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9e2aef2d07c6314c854fef365f381036">XHDCP1X_CIPHER_REG_ENCRYPT_ENABLE_H</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaefc63f94eea644f969857f99264a9a5a">XHDCP1X_CIPHER_REG_ENCRYPT_ENABLE_L</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa99360d2e6f5cc2071ff95729c222344">XHdcp1x_CipherIsEnabled</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9d98f541dd4fe90543190e24a4f6b5cc">XHdcp1x_CipherXorInProgress</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae45c2870e08ccd6d6e51409ede847c80">XHdcp1x_IsRX</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga0f5e4cf832a1dd14f902a2e25043a56e">XHdcp1x_PlatformTimerBusy()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga8e356b098ccbcf8c2a851425e884ac00">XHdcp1x_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8ecfb468f0917a558f7713ab74903033"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_CipherGetB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function reads the contents of the B register in BM0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to query. </td></tr>
    <tr><td class="paramname">X</td><td>is to be loaded with the contents of Bx. </td></tr>
    <tr><td class="paramname">Y</td><td>is to be loaded with the contents of By. </td></tr>
    <tr><td class="paramname">Z</td><td>is to be loaded with the contents of Bz.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_NOT_ENABLED otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A NULL pointer can be passed in any of X, Y and Z. If so, then this portion of the B register is not returned to the caller. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#gac1d454c21b0a16c522875ba13573dee0">XHDCP1X_CIPHER_REG_CIPHER_Bx</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga7d2bc6d575edff65961d636f20503d65">XHDCP1X_CIPHER_REG_CIPHER_By</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga3d01b54a0fd09d11bbdf0b76180c381e">XHDCP1X_CIPHER_REG_CIPHER_Bz</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa99360d2e6f5cc2071ff95729c222344">XHdcp1x_CipherIsEnabled</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="gae38ae0f74022763d8650a21fedcd15e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XHdcp1x_CipherGetEncryption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function retrieves the current encryption stream map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current encryption stream map.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In the case of the receiver version of this core, the XOR in progress bit needs to be checked as well as the encryption map to fully determine if encryption is enabled for the SST case. This is the reason for the additional check in this code. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9e2aef2d07c6314c854fef365f381036">XHDCP1X_CIPHER_REG_ENCRYPT_ENABLE_H</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaefc63f94eea644f969857f99264a9a5a">XHDCP1X_CIPHER_REG_ENCRYPT_ENABLE_L</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa99360d2e6f5cc2071ff95729c222344">XHdcp1x_CipherIsEnabled</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9d98f541dd4fe90543190e24a4f6b5cc">XHdcp1x_CipherXorInProgress</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga151310d6c13945600dbe10531827a2a3">XHdcp1x_RxGetEncryption()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga987fc5a5170470f0bbff214d317aac17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_CipherGetK </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function reads the contents of the K register in BM0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to query. </td></tr>
    <tr><td class="paramname">X</td><td>is to be loaded with the contents of Kx. </td></tr>
    <tr><td class="paramname">Y</td><td>is to be loaded with the contents of Ky. </td></tr>
    <tr><td class="paramname">Z</td><td>is to be loaded with the contents of Kz.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_NOT_ENABLED otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A NULL pointer can be passed in any of X, Y and Z. If so, then this portion of the K register is not returned to the caller. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaad2ec605c8db4820f38ffd88f0273a6a">XHDCP1X_CIPHER_REG_CIPHER_Kx</a>, <a class="el" href="group__hdcp1x__v4__0.html#gacd07f7fbf273cdc8c00a08fb2f8fb0eb">XHDCP1X_CIPHER_REG_CIPHER_Ky</a>, <a class="el" href="group__hdcp1x__v4__0.html#gacc91172cce2e873df65a9cfd5b4f6e06">XHDCP1X_CIPHER_REG_CIPHER_Kz</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa99360d2e6f5cc2071ff95729c222344">XHdcp1x_CipherIsEnabled</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="gacc166098738c7aac2703ee0cbd757c01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XHdcp1x_CipherGetLocalKsv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function reads the local KSV value from the cipher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The local KSV value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga0499c0ca032f1fc1230ae9ee10021e32">XHDCP1X_CIPHER_BITMASK_KEYMGMT_CONTROL_ABORT_Km</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga1d700722a5c16cf1bd605cd010b9383a">XHDCP1X_CIPHER_BITMASK_KEYMGMT_CONTROL_LOCAL_KSV</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga5ac122eb8e2456759a8207831615cc0c">XHDCP1X_CIPHER_BITMASK_KEYMGMT_STATUS_KSV_READY</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaed0d27e72d03245fa63cd14fa678d44c">XHDCP1X_CIPHER_REG_KEYMGMT_CONTROL</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae54c355c17e6c20cff27fb271d4a311f">XHDCP1X_CIPHER_REG_KEYMGMT_STATUS</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad33df471264ecb7ad47c56b1965c32e2">XHDCP1X_CIPHER_REG_KSV_LOCAL_H</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa0daeba5517cd7489c1c30982867d4c8">XHDCP1X_CIPHER_REG_KSV_LOCAL_L</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa99360d2e6f5cc2071ff95729c222344">XHdcp1x_CipherIsEnabled</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae90182b983742cb8e2fa091cffc83aaa">XHdcp1x_CipherLocalKsvReady</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga8e356b098ccbcf8c2a851425e884ac00">XHdcp1x_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga320b0410ab8e10a8bc5c2a6278ed06d7">XHdcp1x_CipherSetRemoteKsv()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga89cf71a1a7edefa4671fdefa3cc7222b">XHdcp1x_RxInfo()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa503ece3533fb6055289ad2dd01ba80b">XHdcp1x_TxInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga72d8fd0f45ff6424d3aac43e36360fec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XHdcp1x_CipherGetMi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function reads the contents of the Mi/An register of BM0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contents of the register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf1add239c0ecfb90a3fc94eaafccbb31">XHDCP1X_CIPHER_REG_CIPHER_Mi_H</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga0aa61ee18e89809a5cfc537a72d32eae">XHDCP1X_CIPHER_REG_CIPHER_Mi_L</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa99360d2e6f5cc2071ff95729c222344">XHdcp1x_CipherIsEnabled</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="gad8759c2071248b537b7ae18b2a1ec5a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XHdcp1x_CipherGetMo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function reads the contents of the Mo register of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contents of the Mo register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#gac372c841db1b7543feccc7db3d69b589">XHDCP1X_CIPHER_REG_CIPHER_Mo_H</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaafe1da3a001a875beee367e4376b98e9">XHDCP1X_CIPHER_REG_CIPHER_Mo_L</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa99360d2e6f5cc2071ff95729c222344">XHdcp1x_CipherIsEnabled</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="gacfeb8a266c1bc554753f93d62eb9a891"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XHdcp1x_CipherGetNumLanes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function retrieves the current number of lanes of the HDCP cipher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current number of lanes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae41022b4dbc46732ab6dcbec56ba7fc8">XHDCP1X_CIPHER_BITMASK_CONTROL_NUM_LANES</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga388ba97163cd68f5e6124a80bd78c30d">XHDCP1X_CIPHER_REG_CONTROL</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa99360d2e6f5cc2071ff95729c222344">XHdcp1x_CipherIsEnabled</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga9d260acd4a5eb9842f5a4bbb31be0e36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XHdcp1x_CipherGetRemoteKsv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function reads the remote KSV value from the cipher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The remote KSV value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga2229a2994fb98bd78c61c91e8556c33c">XHDCP1X_CIPHER_REG_KSV_REMOTE_H</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga129daeee5e3119a9c1607a0ab0b6de63">XHDCP1X_CIPHER_REG_KSV_REMOTE_L</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga9719a81dc9b6815f6b616ccc076f03c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XHdcp1x_CipherGetRi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function reads the contents of the Ri register of BM0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contents of the register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9f1a35f1da810221d96ba0da2664eda3">XHDCP1X_CIPHER_REG_CIPHER_Ri</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa99360d2e6f5cc2071ff95729c222344">XHdcp1x_CipherIsEnabled</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga14ed33ea832900d1022b7a1e8ddba397"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XHdcp1x_CipherGetRo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function reads the contents of the Ro register of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contents of the Ro register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga4afb7f142a1f9ef42220be416475c2da">XHDCP1X_CIPHER_REG_CIPHER_Ro</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa99360d2e6f5cc2071ff95729c222344">XHdcp1x_CipherIsEnabled</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="gaac542620e5aa06df5f83f097a6fc7738"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XHdcp1x_CipherGetVersion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function reads the version of the HDCP cipher core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The version of the HDCP cipher device.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga45c93818933d05bc03a38d74aaf33721">XHDCP1X_CIPHER_REG_VERSION</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga646e74a29f8d1df441368b9c8ae27241">XHdcp1x_GetVersion()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga89cf71a1a7edefa4671fdefa3cc7222b">XHdcp1x_RxInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gaa503ece3533fb6055289ad2dd01ba80b">XHdcp1x_TxInfo()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7a718cbfba0847675523d2a89d8a3755"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_CipherHandleInterrupt </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8h.html">xhdcp1x_cipher.h</a>&gt;</code></p>

<p>This function is the interrupt handler for the cipher core driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the cipher core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#ac4680b598dc6987ff0f60f8faaf91f0a">XHdcp1x::Cipher</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___cipher_stats.html#a105f3fd602c69a8fdcddb02b7b716440">XHdcp1x_CipherStats::IntCount</a>, <a class="el" href="struct_x_hdcp1x___cipher.html#a2a65b2975cc1fd0db6dca06da579da5a">XHdcp1x_Cipher::IsLinkFailCallbackSet</a>, <a class="el" href="struct_x_hdcp1x.html#a0486da7e6f9a79ef7a2a86ffce168d0c">XHdcp1x::IsReady</a>, <a class="el" href="struct_x_hdcp1x___cipher.html#a6d88e9f47ede5f03ddf972e034e547d7">XHdcp1x_Cipher::IsRiUpdateCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___cipher.html#a0e54dbb3c7e4e8557b0b827380490292">XHdcp1x_Cipher::LinkFailCallback</a>, <a class="el" href="struct_x_hdcp1x___cipher.html#a1263eceef9d391e95ae832e31897a745">XHdcp1x_Cipher::LinkFailRef</a>, <a class="el" href="struct_x_hdcp1x___cipher.html#a72c9b8c8298e1c4fdb76b0c0bcb10d9b">XHdcp1x_Cipher::RiUpdateCallback</a>, <a class="el" href="struct_x_hdcp1x___cipher.html#a47c45835fd9b9d730755099a72eb6214">XHdcp1x_Cipher::RiUpdateRef</a>, <a class="el" href="struct_x_hdcp1x___cipher.html#a5f777760902410ea791790862f150e91">XHdcp1x_Cipher::Stats</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaabf04c9775bb969435eb0a56a67e8f57">XHDCP1X_CIPHER_BITMASK_INTERRUPT_LINK_FAIL</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga1b2651a6446b10aab2f229e506d75304">XHDCP1X_CIPHER_BITMASK_INTERRUPT_Ri_UPDATE</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf2d2522cb49e8fb546d3f19cc27bc550">XHDCP1X_CIPHER_REG_INTERRUPT_MASK</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae606ccf3553446bcdc5910dbae74e07e">XHDCP1X_CIPHER_REG_INTERRUPT_STATUS</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga8e356b098ccbcf8c2a851425e884ac00">XHdcp1x_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga73b8452615938e9aca91f3e87a959b9d">XHdcp1x_CipherIntrHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga458350d13807e4d1c4d3655167ec6f03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_CipherInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function initializes an HDCP cipher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to initialize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae41022b4dbc46732ab6dcbec56ba7fc8">XHDCP1X_CIPHER_BITMASK_CONTROL_NUM_LANES</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga26fcb950b098b95e5e74232357ce158c">XHDCP1X_CIPHER_BITMASK_CONTROL_RESET</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga26e1542eb772b2449973d200297da4f4">XHDCP1X_CIPHER_BITMASK_CONTROL_UPDATE</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga388ba97163cd68f5e6124a80bd78c30d">XHDCP1X_CIPHER_REG_CONTROL</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf2d2522cb49e8fb546d3f19cc27bc550">XHDCP1X_CIPHER_REG_INTERRUPT_MASK</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae606ccf3553446bcdc5910dbae74e07e">XHDCP1X_CIPHER_REG_INTERRUPT_STATUS</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga2870575e04b7a20bca6801f47f1f2169">XHdcp1x_IsDP</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga8e356b098ccbcf8c2a851425e884ac00">XHdcp1x_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga931fc14801a82c9cc3aa870d887bbc07">XHdcp1x_CfgInitialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga73b8452615938e9aca91f3e87a959b9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_CipherIntrHandler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>This function is the cipher interrupt handler for the HDCP module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device instance that just interrupted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function just forwards the interrupt along to the corresponding cipher core. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a0486da7e6f9a79ef7a2a86ffce168d0c">XHdcp1x::IsReady</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga7a718cbfba0847675523d2a89d8a3755">XHdcp1x_CipherHandleInterrupt()</a>.</p>

</div>
</div>
<a class="anchor" id="ga40c4838c730476e98dfcd742eb1d21a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_CipherIsLinkUp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function queries the link state of a cipher device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaabf04c9775bb969435eb0a56a67e8f57">XHDCP1X_CIPHER_BITMASK_INTERRUPT_LINK_FAIL</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga47125197300d8d534c2ac141686a23c2">XHDCP1X_CIPHER_REG_STATUS</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa99360d2e6f5cc2071ff95729c222344">XHdcp1x_CipherIsEnabled</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="gace24c74db709b523e1aae7e082494022"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_CipherIsRequestComplete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function queries the progress of the current request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga57d495d46e345da61f512d5c33d3dbd9">XHDCP1X_CIPHER_BITMASK_CIPHER_STATUS_REQUEST_IN_PROG</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae3972aa89e01893b3fe8f5218625d512">XHDCP1X_CIPHER_REG_CIPHER_STATUS</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga70bcb7dd61e57e5b33d2213817a80eca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_CipherSetB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function writes the contents of the B register in BM0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to write to. </td></tr>
    <tr><td class="paramname">X</td><td>is the value to be written to Bx. </td></tr>
    <tr><td class="paramname">Y</td><td>is the value to be written to By. </td></tr>
    <tr><td class="paramname">Z</td><td>is the value to be written to Bz.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_NOT_ENABLED otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga26e1542eb772b2449973d200297da4f4">XHDCP1X_CIPHER_BITMASK_CONTROL_UPDATE</a>, <a class="el" href="group__hdcp1x__v4__0.html#gac1d454c21b0a16c522875ba13573dee0">XHDCP1X_CIPHER_REG_CIPHER_Bx</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga7d2bc6d575edff65961d636f20503d65">XHDCP1X_CIPHER_REG_CIPHER_By</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga3d01b54a0fd09d11bbdf0b76180c381e">XHDCP1X_CIPHER_REG_CIPHER_Bz</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga388ba97163cd68f5e6124a80bd78c30d">XHDCP1X_CIPHER_REG_CONTROL</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa99360d2e6f5cc2071ff95729c222344">XHdcp1x_CipherIsEnabled</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga8e356b098ccbcf8c2a851425e884ac00">XHdcp1x_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="gafc9a91374b2e78ea1aade28082e354a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_CipherSetCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>HandlerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hdcp1x__v4__0.html#ga22b9b36c134731fc3c2d450b29095e05">XHdcp1x_Callback</a>&#160;</td>
          <td class="paramname"><em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallbackRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8h.html">xhdcp1x_cipher.h</a>&gt;</code></p>

<p>This function installs an asynchronous callback function for the given HandlerType: </p>
<pre>
HandlerType                             Callback Function Type
-----------------------------------     -----------------------------------
(XHDCP1X_CIPHER_HANDLER_LINK_FAILURE)   LinkFailCallback
(XHDCP1X_CIPHER_HANDLER_Ri_UPDATE)      RiUpdateCallback
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the HDCP cipher core instance. </td></tr>
    <tr><td class="paramname">HandlerType</td><td>specifies the type of handler. </td></tr>
    <tr><td class="paramname">CallbackFunc</td><td>is the address of the callback function. </td></tr>
    <tr><td class="paramname">CallbackRef</td><td>is a user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if callback function installed successfully.</li>
<li>XST_INVALID_PARAM when HandlerType is invalid.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Invoking this function for a handler that already has been installed replaces it with the new handler. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#ac4680b598dc6987ff0f60f8faaf91f0a">XHdcp1x::Cipher</a>, <a class="el" href="struct_x_hdcp1x___cipher.html#a2a65b2975cc1fd0db6dca06da579da5a">XHdcp1x_Cipher::IsLinkFailCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___cipher.html#a6d88e9f47ede5f03ddf972e034e547d7">XHdcp1x_Cipher::IsRiUpdateCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___cipher.html#a0e54dbb3c7e4e8557b0b827380490292">XHdcp1x_Cipher::LinkFailCallback</a>, <a class="el" href="struct_x_hdcp1x___cipher.html#a1263eceef9d391e95ae832e31897a745">XHdcp1x_Cipher::LinkFailRef</a>, <a class="el" href="struct_x_hdcp1x___cipher.html#a72c9b8c8298e1c4fdb76b0c0bcb10d9b">XHdcp1x_Cipher::RiUpdateCallback</a>, and <a class="el" href="struct_x_hdcp1x___cipher.html#a47c45835fd9b9d730755099a72eb6214">XHdcp1x_Cipher::RiUpdateRef</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga89ff306031805dad1e1ff7af0c836873"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_CipherSetK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function writes the contents of the K register in BM0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to write to. </td></tr>
    <tr><td class="paramname">X</td><td>is the value to be written to Kx. </td></tr>
    <tr><td class="paramname">Y</td><td>is the value to be written to Ky. </td></tr>
    <tr><td class="paramname">Z</td><td>is the value to be written to Kz.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_NOT_ENABLED otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga26e1542eb772b2449973d200297da4f4">XHDCP1X_CIPHER_BITMASK_CONTROL_UPDATE</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaad2ec605c8db4820f38ffd88f0273a6a">XHDCP1X_CIPHER_REG_CIPHER_Kx</a>, <a class="el" href="group__hdcp1x__v4__0.html#gacd07f7fbf273cdc8c00a08fb2f8fb0eb">XHDCP1X_CIPHER_REG_CIPHER_Ky</a>, <a class="el" href="group__hdcp1x__v4__0.html#gacc91172cce2e873df65a9cfd5b4f6e06">XHDCP1X_CIPHER_REG_CIPHER_Kz</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga388ba97163cd68f5e6124a80bd78c30d">XHDCP1X_CIPHER_REG_CONTROL</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa99360d2e6f5cc2071ff95729c222344">XHdcp1x_CipherIsEnabled</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga8e356b098ccbcf8c2a851425e884ac00">XHdcp1x_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga6f0a88da0a794b63e3f6caafa912dc10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_CipherSetKeySelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>KeySelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function configures the key selection value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to configure. </td></tr>
    <tr><td class="paramname">KeySelect</td><td>is the desired key select value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf042b01ec650012737670869f098b0bc">XHDCP1X_CIPHER_BITMASK_KEYMGMT_CONTROL_SET_SELECT</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaed0d27e72d03245fa63cd14fa678d44c">XHDCP1X_CIPHER_REG_KEYMGMT_CONTROL</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga8e356b098ccbcf8c2a851425e884ac00">XHdcp1x_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga405e80474c58ef82e4c27ab99ae70f54">XHdcp1x_SetKeySelect()</a>.</p>

</div>
</div>
<a class="anchor" id="gac3912c6a86498e0559470ce8ce148cd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_CipherSetLinkStateCheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>IsEnabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8h.html">xhdcp1x_cipher.h</a>&gt;</code></p>

<p>This function enables/disables the reporting of link check state changes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the cipher core instance. </td></tr>
    <tr><td class="paramname">IsEnabled</td><td>enables/disables link state change notifications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaabf04c9775bb969435eb0a56a67e8f57">XHDCP1X_CIPHER_BITMASK_INTERRUPT_LINK_FAIL</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf2d2522cb49e8fb546d3f19cc27bc550">XHDCP1X_CIPHER_REG_INTERRUPT_MASK</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae606ccf3553446bcdc5910dbae74e07e">XHDCP1X_CIPHER_REG_INTERRUPT_STATUS</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga2870575e04b7a20bca6801f47f1f2169">XHdcp1x_IsDP</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae45c2870e08ccd6d6e51409ede847c80">XHdcp1x_IsRX</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga8e356b098ccbcf8c2a851425e884ac00">XHdcp1x_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>.</p>

</div>
</div>
<a class="anchor" id="gad104aebb80bb03cb66c31eaabf21247a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_CipherSetNumLanes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>NumLanes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function configures the number of lanes of the HDCP cipher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to configure. </td></tr>
    <tr><td class="paramname">NumLanes</td><td>is the number of lanes to configure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae41022b4dbc46732ab6dcbec56ba7fc8">XHDCP1X_CIPHER_BITMASK_CONTROL_NUM_LANES</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga388ba97163cd68f5e6124a80bd78c30d">XHDCP1X_CIPHER_REG_CONTROL</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga43765c1afc08c59a03b619d0c822e8b7">XHdcp1x_IsHDMI</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga8e356b098ccbcf8c2a851425e884ac00">XHdcp1x_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga51b562dcf0e9f5fe995d2ef05f3cc9b1">XHdcp1x_RxSetLaneCount()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gaf4099beda2b952aa7f9ce574cbbc7646">XHdcp1x_TxSetLaneCount()</a>.</p>

</div>
</div>
<a class="anchor" id="ga320b0410ab8e10a8bc5c2a6278ed06d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_CipherSetRemoteKsv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>Ksv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8c.html">xhdcp1x_cipher.c</a>&gt;</code></p>

<p>This function writes the remote KSV value to the cipher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to write to. </td></tr>
    <tr><td class="paramname">Ksv</td><td>is the remote KSV value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_NOT_ENABLED otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Whenever this function is called, the underlying driver will initiate the calculation of the Km value and wait for it to complete. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga26e1542eb772b2449973d200297da4f4">XHDCP1X_CIPHER_BITMASK_CONTROL_UPDATE</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9a7b2e5dbaac71ec8ec49eb48d29efc5">XHDCP1X_CIPHER_BITMASK_KEYMGMT_CONTROL_BEGIN_Km</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga388ba97163cd68f5e6124a80bd78c30d">XHDCP1X_CIPHER_REG_CONTROL</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaed0d27e72d03245fa63cd14fa678d44c">XHDCP1X_CIPHER_REG_KEYMGMT_CONTROL</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga2229a2994fb98bd78c61c91e8556c33c">XHDCP1X_CIPHER_REG_KSV_REMOTE_H</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga129daeee5e3119a9c1607a0ab0b6de63">XHDCP1X_CIPHER_REG_KSV_REMOTE_L</a>, <a class="el" href="group__hdcp1x__v4__0.html#gacc166098738c7aac2703ee0cbd757c01">XHdcp1x_CipherGetLocalKsv()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa99360d2e6f5cc2071ff95729c222344">XHdcp1x_CipherIsEnabled</a>, <a class="el" href="group__hdcp1x__v4__0.html#gac433f89288e18ce7be66f0871bf285e4">XHdcp1x_CipherKmReady</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga8e356b098ccbcf8c2a851425e884ac00">XHdcp1x_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="gae2ae95918ecd46e725812a9bce8f6478"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_CipherSetRiUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>IsEnabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__cipher_8h.html">xhdcp1x_cipher.h</a>&gt;</code></p>

<p>This function enables/disables the reporting of Ri update notifications. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the cipher core instance. </td></tr>
    <tr><td class="paramname">IsEnabled</td><td>enables/disables Ri update notifications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga1b2651a6446b10aab2f229e506d75304">XHDCP1X_CIPHER_BITMASK_INTERRUPT_Ri_UPDATE</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf2d2522cb49e8fb546d3f19cc27bc550">XHDCP1X_CIPHER_REG_INTERRUPT_MASK</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae606ccf3553446bcdc5910dbae74e07e">XHDCP1X_CIPHER_REG_INTERRUPT_STATUS</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga43765c1afc08c59a03b619d0c822e8b7">XHdcp1x_IsHDMI</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga8e356b098ccbcf8c2a851425e884ac00">XHdcp1x_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="gab081c08c9cc4edb8c35c85fb27554b3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_Disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function disables an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga80075a0db87bde2e795072ca8c5d1190">XHdcp1x_RxDisable()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga88eb2f469cf2a69bcf8a80271a64330c">XHdcp1x_TxDisable()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3bcdf20c5176355adb31bf0477bcaaca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_DisableBlank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function disables the blank output for the cipher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XHdcp14 core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga5345387226f345c288ee244f369d8ed5">XHdcp1x_TxDisableBlank()</a>.</p>

</div>
</div>
<a class="anchor" id="gaad9f3acb0f7df366481d4261542ba2c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_DisableEncryption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>Map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function disables encryption on a series of streams within an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to configure. </td></tr>
    <tr><td class="paramname">Map</td><td>is the stream map to disable encryption on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gad8b45d2c6a594bdb5210c443d1d0020d">XHdcp1x_TxDisableEncryption()</a>.</p>

</div>
</div>
<a class="anchor" id="ga52caa4f761f34ccb7ad92a40a075ad1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_DownstreamReady </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function posts a DOWNSTREAMREADY event to an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to reset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.<ul>
<li>XST_FAILURE otherwise.</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga3938eb7c1586cfe850ec941c36857f22">XHdcp1x_RxDownstreamReady()</a>.</p>

</div>
</div>
<a class="anchor" id="ga72fafe0eef23bbe5dbbc07a260b8d6b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function enables an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga5b3db5316f37aa537c96819ef7892d0e">XHdcp1x_RxEnable()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gaaf9b859a4cd68d38f32103a365d48b99">XHdcp1x_TxEnable()</a>.</p>

</div>
</div>
<a class="anchor" id="ga78468655ea2782da93ae20bab2e9a680"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_EnableBlank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function enables the blank output for the cipher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XHdcp14 core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga610b320cce6d9ee99a4f8c2380f2c852">XHdcp1x_TxEnableBlank()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7ace40ed3ad14f22e3cce4bc8bf6249c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_EnableEncryption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>Map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function enables encryption on a series of streams within an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to configure. </td></tr>
    <tr><td class="paramname">Map</td><td>is the stream map to enable encryption on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga49660982a4772c7bc0091f7c88c68e19">XHdcp1x_TxEnableEncryption()</a>.</p>

</div>
</div>
<a class="anchor" id="ga52085c5f3ece2e12521fe526dbc7742f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XHdcp1x_GetDriverVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function retrieves the version of the HDCP driver software. </p>
<dl class="section return"><dt>Returns</dt><dd>The software driver version.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__hdcp1x__v4__0.html#gae578001fe043b4cca7a0edd801cfe9c4">DRIVER_VERSION</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga89cf71a1a7edefa4671fdefa3cc7222b">XHdcp1x_RxInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gaa503ece3533fb6055289ad2dd01ba80b">XHdcp1x_TxInfo()</a>.</p>

</div>
</div>
<a class="anchor" id="ga60f6a284a49f0e381c353180ec5bebdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XHdcp1x_GetEncryption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function retrieves the current encryption map of the video streams traversing an hdcp interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current encryption map.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga151310d6c13945600dbe10531827a2a3">XHdcp1x_RxGetEncryption()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga86e8fd4e72f7d913bc7f13ea15f37af7">XHdcp1x_TxGetEncryption()</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gaf8d484e140ba4935f33b7fd14b9c5c2a">XHdcp1x_IsEncrypted()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6650255cee4d6285275448cfa0e5664e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_GetRepeaterInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x___repeater_exchange.html">XHdcp1x_RepeaterExchange</a> *&#160;</td>
          <td class="paramname"><em>RepeaterInfoPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function copies the V'H0, V'H1, V'H2, V'H3, V'H4, KSVList and BInfo values in the HDCP RX HDCP Instance for Repeater validation . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the receiver instance. </td></tr>
    <tr><td class="paramname">RepeaterInfoPtr</td><td>is the Repeater information in the transmitter instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.<ul>
<li>XST_FAILURE otherwise.</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1030400c6c423608ffd155b9cb4d12ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * XHdcp1x_GetTopology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function returns a pointer to the downstream Topology structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XHdcp14 core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the XHdcp14 Topology structure or NULL when the topology info is invalid.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga66e1b425725213dd4d5231bf5710e04f">XHDCP1X_DEBUG_PRINTF</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa0dc57eed89ceb400350f9d78551946e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 * XHdcp1x_GetTopologyBKSV </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function returns the value of KSV of the device attached to the downstream interface of the repeater. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XHdcp14 core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE if MAX_DEPTH_EXCEEDED</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gaacbe196b64bd19fe98db62e552b89788">XHdcp1x_TxGetTopologyBKSV()</a>.</p>

</div>
</div>
<a class="anchor" id="ga410b33d14bb0883e3de81a5f784800b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XHdcp1x_GetTopologyField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hdcp1x__v4__0.html#ga54976f91c0d29039065ce279b6f6d8ad">XHdcp1x_TopologyField</a>&#160;</td>
          <td class="paramname"><em>Field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function is used to get various fields inside the topology structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_hdcp1x.html" title="This typedef contains an instance of an HDCP interface. ">XHdcp1x</a> core instance. </td></tr>
    <tr><td class="paramname">Field</td><td>indicates what field of the topology structure to update.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__hdcp1x__v4__0.html#ga11572e1f3d8c314380b5442a2edfb4bc">XHdcp1x_TxGetTopologyDepth()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad4fca1a785fdb5e58b98c8f6619614e9">XHdcp1x_TxGetTopologyDeviceCnt()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf854c758691f491c5f80e89a795f2a24">XHdcp1x_TxGetTopologyMaxCascadeExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga029629390d42624ba18930e5d73a948e">XHdcp1x_TxGetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf9abe5fb8d1b7663035ceb0250368699"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 * XHdcp1x_GetTopologyKSVList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function returns the value of KSV List read in the downstream interface of the repeater topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XHdcp14 core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>List of KSVs of the downstream devices</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gad633915b955c6b56fa317e44bf26593a">XHdcp1x_TxGetTopologyKSVList()</a>.</p>

</div>
</div>
<a class="anchor" id="ga646e74a29f8d1df441368b9c8ae27241"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XHdcp1x_GetVersion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function retrieves the cipher version of an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cipher version used by the interface</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__hdcp1x__v4__0.html#gaac542620e5aa06df5f83f097a6fc7738">XHdcp1x_CipherGetVersion()</a>.</p>

</div>
</div>
<a class="anchor" id="gadefd696ca95f00b16f9af353a0f7d2e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_HandleTimeout </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function handles a timeout on an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa97634c0e7aa105f887389101052c62f">XHdcp1x_RxHandleTimeout()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga79bb13897f9893f9ffbecd6247aea442">XHdcp1x_TxHandleTimeout()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7f8a11ce5614a2541b378f034b3198cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_Info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function performs a debug display of an HDCP instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to display.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga66e1b425725213dd4d5231bf5710e04f">XHDCP1X_DEBUG_PRINTF</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga89cf71a1a7edefa4671fdefa3cc7222b">XHdcp1x_RxInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gaa503ece3533fb6055289ad2dd01ba80b">XHdcp1x_TxInfo()</a>.</p>

</div>
</div>
<a class="anchor" id="gacce89db1cfc0e9cd5c632f3499bff690"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_IsAuthenticated </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function queries an interface to determine if it has successfully completed authentication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating authenticated (TRUE) or not (FALSE).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga2f314cd6eca64f8953ea54fb6bb93c03">XHdcp1x_RxIsAuthenticated()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga3c42675e40aba8024237fee77155fce4">XHdcp1x_TxIsAuthenticated()</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gaf8d484e140ba4935f33b7fd14b9c5c2a">XHdcp1x_IsEncrypted()</a>.</p>

</div>
</div>
<a class="anchor" id="gae8389541cb1c23695221b17789eb945c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_IsDwnstrmCapable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function queries the device connected to the downstream interface to determine if it supports hdcp or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating HDCP capability (TRUE) or not (FALSE).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gad30b097e8f3ff909c1ad5bd4c6a7d7c8">XHdcp1x_TxIsDownstrmCapable()</a>.</p>

</div>
</div>
<a class="anchor" id="gac175508b95f7a2d101630aca5b55e8e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_IsEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function queries an interface to determine if it is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating enabled (TRUE) or not (FALSE).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9a7a3ac0f4c2abe70a1227c2e40eeda3">XHdcp1x_RxIsEnabled()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga74a97f4a831692ea2465eb39935ffdcf">XHdcp1x_TxIsEnabled()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf8d484e140ba4935f33b7fd14b9c5c2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_IsEncrypted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function determines if the video stream is encrypted. </p>
<p>The traffic is encrypted if the encryption bit map is non-zero and the interface is authenticated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the HDCP instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating encrypted (TRUE) or not (FALSE).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__hdcp1x__v4__0.html#ga60f6a284a49f0e381c353180ec5bebdc">XHdcp1x_GetEncryption()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gacce89db1cfc0e9cd5c632f3499bff690">XHdcp1x_IsAuthenticated()</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga89cf71a1a7edefa4671fdefa3cc7222b">XHdcp1x_RxInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gaa503ece3533fb6055289ad2dd01ba80b">XHdcp1x_TxInfo()</a>.</p>

</div>
</div>
<a class="anchor" id="gad264c967aebfe269ea6e40f675886c9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_IsInComputations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function queries an interface to determine if it is in the state of computations or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating authenticated (TRUE) or not (FALSE).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga63d2c00e67796620c78474de50c5f4ce">XHdcp1x_RxIsInComputations()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga3d0d1dc50d7b95639e72d74b1fa2d064">XHdcp1x_TxIsInComputations()</a>.</p>

</div>
</div>
<a class="anchor" id="ga934f616f1b538de0f90a343bc1185380"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_IsInProgress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function queries an interface to determine if authentication is in progress. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating authentication in progress (TRUE) or not (FALSE).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga26586d8954b1ed09f365399f6f7fd6b8">XHdcp1x_TxIsInProgress()</a>.</p>

</div>
</div>
<a class="anchor" id="ga93df0cf3372141a9fd419a02c753196c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_IsInWaitforready </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function queries an interface to determine if it is in the wait-for-ready state or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating authenticated (TRUE) or not (FALSE).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga3828bd501048526899095762ad7bb97e">XHdcp1x_RxIsInWaitforready()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gae4b47fe66cfc82912ada3df74ade247b">XHdcp1x_TxIsInWaitforready()</a>.</p>

</div>
</div>
<a class="anchor" id="gac0c5947639623f7b97d9ec1cc712e75f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_IsRepeater </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function return if the HDCP interface is a repeater in case of Rx or is connected to a repeater in case of Tx. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the transmitter instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE if Repeater.</li>
<li>FALSE if not Repeater,</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x.html#ac977d9a53ad6777e4c4bcae29d58c4c4">XHdcp1x::IsRepeater</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga66e1b425725213dd4d5231bf5710e04f">XHDCP1X_DEBUG_PRINTF</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gaee964dc4d6fc103705d6358fc2db9480">XHdcp1x_TxIsRepeater()</a>.</p>

</div>
</div>
<a class="anchor" id="ga14060c2be4685a3c8d0285e826a2376c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_hdcp1x___config.html">XHdcp1x_Config</a> * XHdcp1x_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>DeviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>This function returns a reference to an <a class="el" href="struct_x_hdcp1x___config.html" title="This typedef contains configuration information for the HDCP core. ">XHdcp1x_Config</a> structure based on specified device ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceId</td><td>is the unique core ID of the HDCP interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the config record in the configuration table (in xhdcp_g.c) corresponding the specified DeviceId. NULL if no match is found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__hdcp1x__v4__0.html#ga92acc39f4ff403d71aad1122fe939664">XPAR_XHDCP_NUM_INSTANCES</a>.</p>

</div>
</div>
<a class="anchor" id="gaceb8746cc60b1628b4df76d155f0b6a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_PlatformIsKsvRevoked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>Ksv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__platform_8c.html">xhdcp1x_platform.c</a>&gt;</code></p>

<p>This function checks a KSV value to determine if it has been revoked or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the HDCP interface. </td></tr>
    <tr><td class="paramname">Ksv</td><td>is the KSV to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating the KSV is revoked (TRUE) or not (FALSE)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__hdcp1x__v4__0.html#ga8669f2b83df6c835492036a201fbae27">XHdcp1xKsvRevokeCheck</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0f5e4cf832a1dd14f902a2e25043a56e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_PlatformTimerBusy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>DelayInMs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__platform_8c.html">xhdcp1x_platform.c</a>&gt;</code></p>

<p>This function busy waits on a timer for a number of milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the hdcp interface. </td></tr>
    <tr><td class="paramname">DelayInMs</td><td>is the delay time in milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#aff7bd50973bcc42ab5540bd9c9d8a709">XHdcp1x::XHdcp1xTimerDelay</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga706d8729ad07f34fad5e20f83c59d69f">XHdcp1x_CipherEnableEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga5345387226f345c288ee244f369d8ed5">XHdcp1x_TxDisableBlank()</a>.</p>

</div>
</div>
<a class="anchor" id="ga702d5623fb869e3454ce5557b79cca1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_PlatformTimerStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>TimeoutInMs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__platform_8c.html">xhdcp1x_platform.c</a>&gt;</code></p>

<p>This function starts a timer on behalf of an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the hdcp interface. </td></tr>
    <tr><td class="paramname">TimeoutInMs</td><td>is the duration of the timer in milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a72c9f45f22ce6f84365adebdb31f3211">XHdcp1x::XHdcp1xTimerStart</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga5345387226f345c288ee244f369d8ed5">XHdcp1x_TxDisableBlank()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1c5ac368d276bfd8e6a017b64c90cbf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_PlatformTimerStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__platform_8c.html">xhdcp1x_platform.c</a>&gt;</code></p>

<p>This function stop a timer on behalf of an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the HDCP interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4d8be50f6a3e7200a1a09af3ecc2aa2f">XHdcp1x::XHdcp1xTimerStop</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga5345387226f345c288ee244f369d8ed5">XHdcp1x_TxDisableBlank()</a>.</p>

</div>
</div>
<a class="anchor" id="ga81768260ec0f02284c294051c56e328e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_Poll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function polls an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to poll.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga5ee01293294eecf9f0f2aa2b380e0116">XHdcp1x_RxPoll()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gac2ceda82b4b6c4e6419e864895109ffa">XHdcp1x_TxPoll()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf5f729774d507b92940336ef2112939a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__hdcp1x__v4__0.html#gab3390f77e705a54ca5639baa56743d3a">XHdcp1x_PortPhyIfAdaptor</a> * XHdcp1x_PortDetermineAdaptor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port_8c.html">xhdcp1x_port.c</a>&gt;</code></p>

<p>This function determines the adaptor for a specified port device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device whose adaptor is to be determined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the adaptor table. NULL if not found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a737c4d0a7a9ceb9297a7383bf87a00c9">XHdcp1x_Config::IsHDMI</a>, and <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga931fc14801a82c9cc3aa870d887bbc07">XHdcp1x_CfgInitialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga152c8d8f9abdee612ce15f6e914a122a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_PortDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port_8c.html">xhdcp1x_port.c</a>&gt;</code></p>

<p>This function disables a port device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to disables.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_NO_FEATURE if the port lacks a Disable function.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___port_struct.html#a5c94bb21f0376bd33fe7513be4103d91">XHdcp1x_PortStruct::Adaptor</a>, <a class="el" href="struct_x_hdcp1x___port_phy_if_adaptor_s.html#a905f9d64808141ae50c0c96c9d15e399">XHdcp1x_PortPhyIfAdaptorS::Disable</a>, and <a class="el" href="struct_x_hdcp1x.html#a8234eabad6b1c38cb2cb725ef0ab9b47">XHdcp1x::Port</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="gafe3971f3a49c69f3a316f3fab58fdf20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_PortEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port_8c.html">xhdcp1x_port.c</a>&gt;</code></p>

<p>This function enables a port device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to enables.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_NO_FEATURE if the port lacks an Enable function.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___port_struct.html#a5c94bb21f0376bd33fe7513be4103d91">XHdcp1x_PortStruct::Adaptor</a>, <a class="el" href="struct_x_hdcp1x___port_phy_if_adaptor_s.html#a4b1b24d15dc0d72331b63aaf715a1dfd">XHdcp1x_PortPhyIfAdaptorS::Enable</a>, and <a class="el" href="struct_x_hdcp1x.html#a8234eabad6b1c38cb2cb725ef0ab9b47">XHdcp1x::Port</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8865a6a7279587d2a439f603b78bf35c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_PortGetRepeaterInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&#160;</td>
          <td class="paramname"><em>InfoPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port_8c.html">xhdcp1x_port.c</a>&gt;</code></p>

<p>This function retrieves the repeater information from the connected device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to query. </td></tr>
    <tr><td class="paramname">InfoPtr</td><td>is the repeater info.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_NO_FEATURE if the port lacks a GetRepeaterInfo function.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___port_struct.html#a5c94bb21f0376bd33fe7513be4103d91">XHdcp1x_PortStruct::Adaptor</a>, <a class="el" href="struct_x_hdcp1x___port_phy_if_adaptor_s.html#a76b0cd0947177d051616409b2e26d9fd">XHdcp1x_PortPhyIfAdaptorS::GetRepeaterInfo</a>, and <a class="el" href="struct_x_hdcp1x.html#a8234eabad6b1c38cb2cb725ef0ab9b47">XHdcp1x::Port</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5e84960fab8e0598e3dc0ecffd7fa2dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_PortHandleInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>IntCause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port_8h.html">xhdcp1x_port.h</a>&gt;</code></p>

<p>This handles an interrupt generated by a HDCP port device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to write to. </td></tr>
    <tr><td class="paramname">IntCause</td><td>is the interrupt cause bit map.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___port_struct.html#a5c94bb21f0376bd33fe7513be4103d91">XHdcp1x_PortStruct::Adaptor</a>, <a class="el" href="struct_x_hdcp1x___port_stats.html#a5e09862f792ac5882b922a58a4d78e72">XHdcp1x_PortStats::IntCount</a>, <a class="el" href="struct_x_hdcp1x___port_phy_if_adaptor_s.html#a9f9b8c44a55b6cc10372ef33115aaf99">XHdcp1x_PortPhyIfAdaptorS::IntrHandler</a>, <a class="el" href="struct_x_hdcp1x.html#a8234eabad6b1c38cb2cb725ef0ab9b47">XHdcp1x::Port</a>, and <a class="el" href="struct_x_hdcp1x___port_struct.html#a316391664c4d927846ef9169bf723e0f">XHdcp1x_PortStruct::Stats</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gaac0a3b497e4974beccb2adfba3d5fa19">XHdcp1x_PortIntrHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="gaac0a3b497e4974beccb2adfba3d5fa19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_PortIntrHandler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>IntCause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>This function is the port interrupt handler for the HDCP module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device instance that just interrupted. </td></tr>
    <tr><td class="paramname">IntCause</td><td>is the interrupt cause bit map.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function just forwards the interrupt along to the corresponding cipher core. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a0486da7e6f9a79ef7a2a86ffce168d0c">XHdcp1x::IsReady</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga5e84960fab8e0598e3dc0ecffd7fa2dc">XHdcp1x_PortHandleInterrupt()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf1e24817724b0410a9b272343a0ef745"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_PortIsCapable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port_8c.html">xhdcp1x_port.c</a>&gt;</code></p>

<p>This function queries a port device to determine if hdcp is supported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___port_struct.html#a5c94bb21f0376bd33fe7513be4103d91">XHdcp1x_PortStruct::Adaptor</a>, <a class="el" href="struct_x_hdcp1x___port_phy_if_adaptor_s.html#a5fd6e71a7d6d4c88c6ee76b8b49aeb83">XHdcp1x_PortPhyIfAdaptorS::IsCapable</a>, and <a class="el" href="struct_x_hdcp1x.html#a8234eabad6b1c38cb2cb725ef0ab9b47">XHdcp1x::Port</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad30b097e8f3ff909c1ad5bd4c6a7d7c8">XHdcp1x_TxIsDownstrmCapable()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga41b5285a790690159dece6baa5afadf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_PortIsRepeater </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port_8c.html">xhdcp1x_port.c</a>&gt;</code></p>

<p>This function queries a port device to determine if it is connected to a repeater. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___port_struct.html#a5c94bb21f0376bd33fe7513be4103d91">XHdcp1x_PortStruct::Adaptor</a>, <a class="el" href="struct_x_hdcp1x___port_phy_if_adaptor_s.html#a4e706b58cddd81a63f8c698eddb58aa7">XHdcp1x_PortPhyIfAdaptorS::IsRepeater</a>, and <a class="el" href="struct_x_hdcp1x.html#a8234eabad6b1c38cb2cb725ef0ab9b47">XHdcp1x::Port</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaee964dc4d6fc103705d6358fc2db9480">XHdcp1x_TxIsRepeater()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6e36b9c8a021600e2c9e3766f94b6dc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_PortRead </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port_8c.html">xhdcp1x_port.c</a>&gt;</code></p>

<p>This function reads a register from a HDCP port device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to read from. </td></tr>
    <tr><td class="paramname">Offset</td><td>is the offset to start reading from. </td></tr>
    <tr><td class="paramname">Buf</td><td>is the buffer to copy the data read. </td></tr>
    <tr><td class="paramname">BufSize</td><td>is the size of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___port_struct.html#a5c94bb21f0376bd33fe7513be4103d91">XHdcp1x_PortStruct::Adaptor</a>, <a class="el" href="struct_x_hdcp1x.html#a8234eabad6b1c38cb2cb725ef0ab9b47">XHdcp1x::Port</a>, and <a class="el" href="struct_x_hdcp1x___port_phy_if_adaptor_s.html#a845a4332014339259568da72585c11aa">XHdcp1x_PortPhyIfAdaptorS::Read</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae3eacc3ce1104040154509de3edd755f">XHdcp1x_RxSetTopologyMaxCascadeExceeded()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gab22ac8a26a4b60bdeda3be59baacbf39">XHdcp1x_TxGetTopology()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaacbe196b64bd19fe98db62e552b89788">XHdcp1x_TxGetTopologyBKSV()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf854c758691f491c5f80e89a795f2a24">XHdcp1x_TxGetTopologyMaxCascadeExceeded()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga029629390d42624ba18930e5d73a948e">XHdcp1x_TxGetTopologyMaxDevsExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f9860359eea1bd7989e76c11888734c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_PortSetCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>HandlerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hdcp1x__v4__0.html#ga22b9b36c134731fc3c2d450b29095e05">XHdcp1x_Callback</a>&#160;</td>
          <td class="paramname"><em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallbackRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port_8h.html">xhdcp1x_port.h</a>&gt;</code></p>

<p>This function installs an asynchronous callback function for the given HandlerType: </p>
<pre>
HandlerType                           Callback Function Type
------------------------------------  -------------------------------------
(XHDCP1X_PORT_HANDLER_AUTHENTICATE)   AuthCallback
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the HDCP port instance. </td></tr>
    <tr><td class="paramname">HandlerType</td><td>specifies the type of handler. </td></tr>
    <tr><td class="paramname">CallbackFunc</td><td>is the address of the callback function. </td></tr>
    <tr><td class="paramname">CallbackRef</td><td>is a user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if callback function installed successfully.</li>
<li>XST_INVALID_PARAM when HandlerType is invalid.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Invoking this function for a handler that already has been installed replaces it with the new handler. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___port_struct.html#a0b9372be6bbed654eb7809a3c571aac6">XHdcp1x_PortStruct::AuthCallback</a>, <a class="el" href="struct_x_hdcp1x___port_struct.html#add20260f047759cae3278e3c7721d870">XHdcp1x_PortStruct::AuthRef</a>, <a class="el" href="struct_x_hdcp1x___port_struct.html#a0236b727093565833b9902c0d6df5fdd">XHdcp1x_PortStruct::IsAuthCallbackSet</a>, <a class="el" href="struct_x_hdcp1x.html#a8234eabad6b1c38cb2cb725ef0ab9b47">XHdcp1x::Port</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gga758e8028b33a9204cabc6b8327eacaf3a1763ad0694adf51c42870df78089ec87">XHDCP1X_PORT_HANDLER_AUTHENTICATE</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4ddc37a110b704b91553dea3646d18e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_PortSetRepeater </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>RptrConf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port_8c.html">xhdcp1x_port.c</a>&gt;</code></p>

<p>This function set the REPEATER information in the connected device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to query. </td></tr>
    <tr><td class="paramname">RptrConf</td><td>is the configuration of the device as repeater.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_NO_FEATURE if the port fails to set the Repeater value.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___port_struct.html#a5c94bb21f0376bd33fe7513be4103d91">XHdcp1x_PortStruct::Adaptor</a>, <a class="el" href="struct_x_hdcp1x.html#a8234eabad6b1c38cb2cb725ef0ab9b47">XHdcp1x::Port</a>, and <a class="el" href="struct_x_hdcp1x___port_phy_if_adaptor_s.html#a18c25a1d8a6ce79e8524cd1b2c5b055e">XHdcp1x_PortPhyIfAdaptorS::SetRepeater</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga0b43677a8ea30e51ee23b673349d488e">XHdcp1x_RxSetRepeaterBcaps()</a>.</p>

</div>
</div>
<a class="anchor" id="ga46da74febe033d53ef2420d318fd63b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_PortWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__port_8c.html">xhdcp1x_port.c</a>&gt;</code></p>

<p>This function writes a register within a HDCP port device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the device to write to. </td></tr>
    <tr><td class="paramname">Offset</td><td>is the offset to start writing at. </td></tr>
    <tr><td class="paramname">Buf</td><td>is the buffer containing the data to write. </td></tr>
    <tr><td class="paramname">BufSize</td><td>is the size of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___port_struct.html#a5c94bb21f0376bd33fe7513be4103d91">XHdcp1x_PortStruct::Adaptor</a>, <a class="el" href="struct_x_hdcp1x.html#a8234eabad6b1c38cb2cb725ef0ab9b47">XHdcp1x::Port</a>, and <a class="el" href="struct_x_hdcp1x___port_phy_if_adaptor_s.html#a43698c768a14d0097a9e00628ce2c4af">XHdcp1x_PortPhyIfAdaptorS::Write</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad04a19828d3f0e503ac0a89cfb5e8212">XHdcp1x_RxGetRepeaterInfo()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae3eacc3ce1104040154509de3edd755f">XHdcp1x_RxSetTopologyMaxCascadeExceeded()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gab797b1cff481d823174db2e3fdec666a">XHdcp1x_TxTriggerDownstreamAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8bf591dc879a170beed8edc091ac018f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_ProcessAKsv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function processes the AKsv. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to display.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___port_struct.html#a5c94bb21f0376bd33fe7513be4103d91">XHdcp1x_PortStruct::Adaptor</a>, <a class="el" href="struct_x_hdcp1x___port_phy_if_adaptor_s.html#ad6274bc4f2ebf8acbabd47c6bbbff923">XHdcp1x_PortPhyIfAdaptorS::CallbackHandler</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, and <a class="el" href="struct_x_hdcp1x.html#a8234eabad6b1c38cb2cb725ef0ab9b47">XHdcp1x::Port</a>.</p>

</div>
</div>
<a class="anchor" id="ga4e1dc21a163e1e2c5281c36f23519a85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_ReadDownstream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function initiates downstream read of READY bit and consequently the second part of Repeater authentication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to initiate authentication on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gaf52273c741319df900b9fe2bb51b78d6">XHdcp1x_TxReadDownstream()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5a42371924892562d7f6df80d5907a1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function resets an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to reset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaddbe71f943e307f5efb356944b0c052d">XHdcp1x_RxReset()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga1f96aea1f54189b92719510de767b768">XHdcp1x_TxReset()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf0dcbf2dffdfd9ef4b3d02184f01cab7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_RxAuthenticate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function initiates authentication on an interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the receiver instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga103ae62cd1207e7566bf4f39ce946f67">XHdcp1x_Authenticate()</a>.</p>

</div>
</div>
<a class="anchor" id="ga80075a0db87bde2e795072ca8c5d1190"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_RxDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function disables a HDCP receive interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the receiver instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gab081c08c9cc4edb8c35c85fb27554b3e">XHdcp1x_Disable()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3938eb7c1586cfe850ec941c36857f22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_RxDownstreamReady </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function initiates downstream ready/ assemble ksv list on an interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the receiver instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga52caa4f761f34ccb7ad92a40a075ad1e">XHdcp1x_DownstreamReady()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5b3db5316f37aa537c96819ef7892d0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_RxEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function enables a HDCP receive interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the receiver instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga72fafe0eef23bbe5dbbc07a260b8d6b3">XHdcp1x_Enable()</a>.</p>

</div>
</div>
<a class="anchor" id="ga151310d6c13945600dbe10531827a2a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XHdcp1x_RxGetEncryption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function retrieves the current encryption stream map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the receiver instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current encryption stream map.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__hdcp1x__v4__0.html#gae38ae0f74022763d8650a21fedcd15e5">XHdcp1x_CipherGetEncryption()</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga60f6a284a49f0e381c353180ec5bebdc">XHdcp1x_GetEncryption()</a>.</p>

</div>
</div>
<a class="anchor" id="gad04a19828d3f0e503ac0a89cfb5e8212"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_RxGetRepeaterInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x___repeater_exchange.html">XHdcp1x_RepeaterExchange</a> *&#160;</td>
          <td class="paramname"><em>RepeaterInfoPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function copies the V'H0, V'H1, V'H2, V'H3, V'H4, KSVList and BInfo values in the HDCP RX HDCP Instance for Repeater validation . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the receiver instance. </td></tr>
    <tr><td class="paramname">RepeaterInfoPtr</td><td>is the Repeater information in the transmitter instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___rx_stats.html#a2aa5dfdc43cab072fb23bea4c44600fe">XHdcp1x_RxStats::AuthAttempts</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___rx_encyption_watch.html#a24cd28d7cab88a265a296faabc6be6fc">XHdcp1x_RxEncyptionWatch::CurrentState</a>, <a class="el" href="struct_x_hdcp1x___repeater_exchange.html#a40144408f1bb58cf5a97b3a50ba792b6">XHdcp1x_RepeaterExchange::Depth</a>, <a class="el" href="struct_x_hdcp1x___repeater_exchange.html#af6d1681d45b9be94629caf1e8ecdfdc2">XHdcp1x_RepeaterExchange::DeviceCount</a>, <a class="el" href="struct_x_hdcp1x___config.html#ada1368e4b8cb979a0feb6ae4682fae54">XHdcp1x_Config::DeviceId</a>, <a class="el" href="struct_x_hdcp1x___config.html#a737c4d0a7a9ceb9297a7383bf87a00c9">XHdcp1x_Config::IsHDMI</a>, <a class="el" href="struct_x_hdcp1x.html#ac977d9a53ad6777e4c4bcae29d58c4c4">XHdcp1x::IsRepeater</a>, <a class="el" href="struct_x_hdcp1x___repeater_exchange.html#a020414febebe00bdd191ee44c5aca495">XHdcp1x_RepeaterExchange::KsvList</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a4c40ab97d534b347c297c9cad8911f76">XHdcp1x_Rx::PendingEvents</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a1f9029cd792e5539b37eb2f3f8f5dce4">XHdcp1x_Rx::RepeaterDownstreamAuthCallback</a>, <a class="el" href="struct_x_hdcp1x___rx.html#ab21c32e43e81f9acbc743fb726e6fc28">XHdcp1x_Rx::RepeaterDownstreamAuthRef</a>, <a class="el" href="struct_x_hdcp1x.html#addd3478685d4cb9f7ce30ef286a1b371">XHdcp1x::RepeaterValues</a>, <a class="el" href="struct_x_hdcp1x.html#a0a37ba675983dce379385f3f84db9172">XHdcp1x::Rx</a>, <a class="el" href="struct_x_hdcp1x___rx.html#abac529df47db1cb77b62b762d2310cc6">XHdcp1x_Rx::Stats</a>, <a class="el" href="struct_x_hdcp1x___repeater_exchange.html#a7e57043f7b44fe7bb76c6b95159467d7">XHdcp1x_RepeaterExchange::V</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga2ca06586dc06796fdc31a2f64096a28d">XHdcp1x_CipherDisable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad44ad72f65d851de50c40053e327ba9e">XHdcp1x_CipherDoRequest()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa3f73058855c8d60cbd588d74e60a668">XHdcp1x_CipherEnable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gacc166098738c7aac2703ee0cbd757c01">XHdcp1x_CipherGetLocalKsv()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad8759c2071248b537b7ae18b2a1ec5a6">XHdcp1x_CipherGetMo()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga14ed33ea832900d1022b7a1e8ddba397">XHdcp1x_CipherGetRo()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gace24c74db709b523e1aae7e082494022">XHdcp1x_CipherIsRequestComplete()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga70bcb7dd61e57e5b33d2213817a80eca">XHdcp1x_CipherSetB()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gafc9a91374b2e78ea1aade28082e354a7">XHdcp1x_CipherSetCallback()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gac3912c6a86498e0559470ce8ce148cd1">XHdcp1x_CipherSetLinkStateCheck()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga320b0410ab8e10a8bc5c2a6278ed06d7">XHdcp1x_CipherSetRemoteKsv()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae2ae95918ecd46e725812a9bce8f6478">XHdcp1x_CipherSetRiUpdate()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga83e87d466be18c22a62503f408c341cc">XHDCP1X_DEBUG_LOGMSG</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga0f5e4cf832a1dd14f902a2e25043a56e">XHdcp1x_PlatformTimerBusy()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga702d5623fb869e3454ce5557b79cca1a">XHdcp1x_PlatformTimerStart()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga1c5ac368d276bfd8e6a017b64c90cbf1">XHdcp1x_PlatformTimerStop()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gab4c3aec7795d024dd2c37e672d552f1d">XHDCP1X_PORT_BIT_BSTATUS_RO_AVAILABLE</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga0b4d815c1d172e921b83f3685d54012b">XHDCP1X_PORT_BUF_TO_UINT</a>, <a class="el" href="group__hdcp1x__v4__0.html#gga758e8028b33a9204cabc6b8327eacaf3a1763ad0694adf51c42870df78089ec87">XHDCP1X_PORT_HANDLER_AUTHENTICATE</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga76ea6af219c93dc97fa1c5fd3aef6cbc">XHDCP1X_PORT_HDCP_RESET_KSV</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga317abcf43fb57d32be6b775f0281098e">XHDCP1X_PORT_HDCP_RESET_KSV_RST</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga0cf254f7b06dddaade9b80d1474a37d2">XHDCP1X_PORT_OFFSET_AKSV</a>, <a class="el" href="group__hdcp1x__v4__0.html#gafc793c58510855ab8647e1b46966ae91">XHDCP1X_PORT_OFFSET_AN</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga1865cffebcba3167ab0867e3a276fe12">XHDCP1X_PORT_OFFSET_BKSV</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga735d88629a20a22d8edc3527877160f8">XHDCP1X_PORT_OFFSET_BSTATUS</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga232b0f643c7651084bf3b565c5b444ac">XHDCP1X_PORT_OFFSET_RO</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga1b3e2eeb2a7f7ed7c7054bf387e16a10">XHDCP1X_PORT_SIZE_AKSV</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa49a07e54b5cf34b332e11e7784ef81e">XHDCP1X_PORT_SIZE_AN</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga8f589bb54a9c7295aa522dcf5f25fbf7">XHDCP1X_PORT_SIZE_BKSV</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga1f5c58db160f9afd130570f0111d094d">XHDCP1X_PORT_SIZE_BSTATUS</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga62b350f20404434a855f46c62ee888ed">XHDCP1X_PORT_UINT_TO_BUF</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga152c8d8f9abdee612ce15f6e914a122a">XHdcp1x_PortDisable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gafe3971f3a49c69f3a316f3fab58fdf20">XHdcp1x_PortEnable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga6e36b9c8a021600e2c9e3766f94b6dc7">XHdcp1x_PortRead()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga1f9860359eea1bd7989e76c11888734c">XHdcp1x_PortSetCallback()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga46da74febe033d53ef2420d318fd63b9">XHdcp1x_PortWrite()</a>, and <a class="el" href="struct_x_hdcp1x___rx.html#af46e8a6da2ced045c20dc669888b8c33">XHdcp1x_Rx::XORState</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga6650255cee4d6285275448cfa0e5664e">XHdcp1x_GetRepeaterInfo()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa97634c0e7aa105f887389101052c62f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_RxHandleTimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function handles a timeout on an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the receiver instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gadefd696ca95f00b16f9af353a0f7d2e8">XHdcp1x_HandleTimeout()</a>.</p>

</div>
</div>
<a class="anchor" id="ga89cf71a1a7edefa4671fdefa3cc7222b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_RxInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function implements the debug display output for receiver instances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the receiver instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___rx_stats.html#a2aa5dfdc43cab072fb23bea4c44600fe">XHdcp1x_RxStats::AuthAttempts</a>, <a class="el" href="struct_x_hdcp1x.html#ac4680b598dc6987ff0f60f8faaf91f0a">XHdcp1x::Cipher</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a45dfdf65ea2c69d3bb5f6f2573d1830a">XHdcp1x_Rx::CurrentState</a>, <a class="el" href="struct_x_hdcp1x___rx.html#ad7c01155a2fc2880ae549dc9e373bf4c">XHdcp1x_Rx::Flags</a>, <a class="el" href="struct_x_hdcp1x___cipher_stats.html#a105f3fd602c69a8fdcddb02b7b716440">XHdcp1x_CipherStats::IntCount</a>, <a class="el" href="struct_x_hdcp1x___port_stats.html#a5e09862f792ac5882b922a58a4d78e72">XHdcp1x_PortStats::IntCount</a>, <a class="el" href="struct_x_hdcp1x___config.html#a737c4d0a7a9ceb9297a7383bf87a00c9">XHdcp1x_Config::IsHDMI</a>, <a class="el" href="struct_x_hdcp1x___rx_stats.html#a0413a42e1eef857cca353d47c132ac4c">XHdcp1x_RxStats::LinkFailures</a>, <a class="el" href="struct_x_hdcp1x.html#a8234eabad6b1c38cb2cb725ef0ab9b47">XHdcp1x::Port</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a8fa0e880a311858439ca0a92c6ba75a2">XHdcp1x_Rx::PreviousState</a>, <a class="el" href="struct_x_hdcp1x___rx_stats.html#ae57022364910875a93bd7019bae98c12">XHdcp1x_RxStats::RiUpdates</a>, <a class="el" href="struct_x_hdcp1x.html#a0a37ba675983dce379385f3f84db9172">XHdcp1x::Rx</a>, <a class="el" href="struct_x_hdcp1x___cipher.html#a5f777760902410ea791790862f150e91">XHdcp1x_Cipher::Stats</a>, <a class="el" href="struct_x_hdcp1x___port_struct.html#a316391664c4d927846ef9169bf723e0f">XHdcp1x_PortStruct::Stats</a>, <a class="el" href="struct_x_hdcp1x___rx.html#abac529df47db1cb77b62b762d2310cc6">XHdcp1x_Rx::Stats</a>, <a class="el" href="group__hdcp1x__v4__0.html#gacc166098738c7aac2703ee0cbd757c01">XHdcp1x_CipherGetLocalKsv()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaac542620e5aa06df5f83f097a6fc7738">XHdcp1x_CipherGetVersion()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga66e1b425725213dd4d5231bf5710e04f">XHDCP1X_DEBUG_PRINTF</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga52085c5f3ece2e12521fe526dbc7742f">XHdcp1x_GetDriverVersion()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gaf8d484e140ba4935f33b7fd14b9c5c2a">XHdcp1x_IsEncrypted()</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga7f8a11ce5614a2541b378f034b3198cb">XHdcp1x_Info()</a>.</p>

</div>
</div>
<a class="anchor" id="ga45e3bcb6feba3b09d84567db489a8f86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_RxInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function initializes a HDCP receiver state machine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the receiver instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___rx.html#a4c40ab97d534b347c297c9cad8911f76">XHdcp1x_Rx::PendingEvents</a>, and <a class="el" href="struct_x_hdcp1x.html#a0a37ba675983dce379385f3f84db9172">XHdcp1x::Rx</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga931fc14801a82c9cc3aa870d887bbc07">XHdcp1x_CfgInitialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2f314cd6eca64f8953ea54fb6bb93c03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_RxIsAuthenticated </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function queries an interface to check if its been authenticated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the receiver instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating authenticated (true) or not (false).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___rx.html#a45dfdf65ea2c69d3bb5f6f2573d1830a">XHdcp1x_Rx::CurrentState</a>, and <a class="el" href="struct_x_hdcp1x.html#a0a37ba675983dce379385f3f84db9172">XHdcp1x::Rx</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gacce89db1cfc0e9cd5c632f3499bff690">XHdcp1x_IsAuthenticated()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9a7a3ac0f4c2abe70a1227c2e40eeda3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_RxIsEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function queries an interface to check if is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the receiver instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating is enabled (true) or not (false).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___rx.html#a45dfdf65ea2c69d3bb5f6f2573d1830a">XHdcp1x_Rx::CurrentState</a>, and <a class="el" href="struct_x_hdcp1x.html#a0a37ba675983dce379385f3f84db9172">XHdcp1x::Rx</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gac175508b95f7a2d101630aca5b55e8e5">XHdcp1x_IsEnabled()</a>.</p>

</div>
</div>
<a class="anchor" id="ga63d2c00e67796620c78474de50c5f4ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_RxIsInComputations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function queries an interface to check if its in the computations state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the receiver instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating authenticated (true) or not (false).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___rx.html#a45dfdf65ea2c69d3bb5f6f2573d1830a">XHdcp1x_Rx::CurrentState</a>, and <a class="el" href="struct_x_hdcp1x.html#a0a37ba675983dce379385f3f84db9172">XHdcp1x::Rx</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad264c967aebfe269ea6e40f675886c9f">XHdcp1x_IsInComputations()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa617d8a93cb5f75964aa2d0c6a94e1f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_RxIsInProgress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function queries an interface to check if authentication is in progress. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the receiver instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating in progress (true) or not (false).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___rx.html#a45dfdf65ea2c69d3bb5f6f2573d1830a">XHdcp1x_Rx::CurrentState</a>, and <a class="el" href="struct_x_hdcp1x.html#a0a37ba675983dce379385f3f84db9172">XHdcp1x::Rx</a>.</p>

</div>
</div>
<a class="anchor" id="ga3828bd501048526899095762ad7bb97e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_RxIsInWaitforready </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function queries an interface to check if its in the wait-for-downstream-ready state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the receiver instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating authenticated (true) or not (false).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___rx.html#a45dfdf65ea2c69d3bb5f6f2573d1830a">XHdcp1x_Rx::CurrentState</a>, and <a class="el" href="struct_x_hdcp1x.html#a0a37ba675983dce379385f3f84db9172">XHdcp1x::Rx</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga93df0cf3372141a9fd419a02c753196c">XHdcp1x_IsInWaitforready()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5ee01293294eecf9f0f2aa2b380e0116"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_RxPoll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function polls the HDCP receiver module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the receiver instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga81768260ec0f02284c294051c56e328e">XHdcp1x_Poll()</a>.</p>

</div>
</div>
<a class="anchor" id="gaddbe71f943e307f5efb356944b0c052d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_RxReset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function resets an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the receiver instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function disables and then re-enables the interface. </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga5a42371924892562d7f6df80d5907a1f">XHdcp1x_Reset()</a>.</p>

</div>
</div>
<a class="anchor" id="ga10379d782472233124be66f42559f093"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_RxSetCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hdcp1x__v4__0.html#gaa46858c4b302cf0e3f9d59d5c5e6bbb9">XHdcp1x_HandlerType</a>&#160;</td>
          <td class="paramname"><em>HandlerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallbackRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function installs callback functions for the given HandlerType: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the HDCP core instance. </td></tr>
    <tr><td class="paramname">HandlerType</td><td>specifies the type of handler. </td></tr>
    <tr><td class="paramname">CallbackFunc</td><td>is the address of the callback function. </td></tr>
    <tr><td class="paramname">CallbackRef</td><td>is a user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if callback function installed successfully.</li>
<li>XST_INVALID_PARAM when HandlerType is invalid.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Invoking this function for a handler that already has been installed replaces it with the new handler. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___rx.html#a2ed2aea26d867cc8b32c23446a8b356f">XHdcp1x_Rx::AuthenticatedCallback</a>, <a class="el" href="struct_x_hdcp1x___rx.html#af981da076b0ffacb3e6931f7851d4cd3">XHdcp1x_Rx::AuthenticatedCallbackRef</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a3ebbd48e5bd71035d4c720482f451cb7">XHdcp1x_Rx::DdcGetDataCallback</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a37e2adfaf1353061d847332dc849cd8d">XHdcp1x_Rx::DdcGetDataCallbackRef</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a390b07d7f8547e353f2e316e26320829">XHdcp1x_Rx::DdcSetAddressCallback</a>, <a class="el" href="struct_x_hdcp1x___rx.html#ad98b20f01d95d427d30e286af7350ca5">XHdcp1x_Rx::DdcSetAddressCallbackRef</a>, <a class="el" href="struct_x_hdcp1x___rx.html#ac0d254b702690871c60db2724a071a74">XHdcp1x_Rx::DdcSetDataCallback</a>, <a class="el" href="struct_x_hdcp1x___rx.html#aa7f2f1dbac2d0ef967a4c7579f4fdafe">XHdcp1x_Rx::DdcSetDataCallbackRef</a>, <a class="el" href="struct_x_hdcp1x___rx.html#afe55c0a1ba26412a5b1671e46e181347">XHdcp1x_Rx::EncryptionUpdateCallback</a>, <a class="el" href="struct_x_hdcp1x___rx.html#af671176e6654eaf148e1d8567b729a2e">XHdcp1x_Rx::EncryptionUpdateCallbackRef</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a5037a2415dafe5f92b225bffcf410e81">XHdcp1x_Rx::IsAuthenticatedCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___rx.html#ab5533c3626a8379739bfeb9023771e1f">XHdcp1x_Rx::IsDdcGetDataCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a328c110db56d453bf13d63006fe0b342">XHdcp1x_Rx::IsDdcSetAddressCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a71563daf4a5ba6da5d61538de804716e">XHdcp1x_Rx::IsDdcSetDataCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___rx.html#aab743cb5c6259e89858dce2bac9d01b6">XHdcp1x_Rx::IsEncryptionUpdateCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___rx.html#ac6f5ed90fdcf991e41131d1937bf2f56">XHdcp1x_Rx::IsRepeaterDownstreamAuthCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a9f414f91312d6753b5f704030051bc19">XHdcp1x_Rx::IsTopologyUpdateCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___rx.html#aba6af280761ee6bb27641062363c9ed6">XHdcp1x_Rx::IsUnauthenticatedCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a1f9029cd792e5539b37eb2f3f8f5dce4">XHdcp1x_Rx::RepeaterDownstreamAuthCallback</a>, <a class="el" href="struct_x_hdcp1x___rx.html#ab21c32e43e81f9acbc743fb726e6fc28">XHdcp1x_Rx::RepeaterDownstreamAuthRef</a>, <a class="el" href="struct_x_hdcp1x.html#a0a37ba675983dce379385f3f84db9172">XHdcp1x::Rx</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a090a75d1f1d6d838d55d4d8d8eb4de7e">XHdcp1x_Rx::TopologyUpdateCallback</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a876f1439cffebdff1b901ead25249443">XHdcp1x_Rx::TopologyUpdateCallbackRef</a>, <a class="el" href="struct_x_hdcp1x___rx.html#ae328e636837cd6fbe4488153f69b4c3f">XHdcp1x_Rx::UnauthenticatedCallback</a>, and <a class="el" href="struct_x_hdcp1x___rx.html#a4354d6aba739cf60eb2d5251593d42d0">XHdcp1x_Rx::UnauthenticatedCallbackRef</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga145ec2236143e47dd0bb8e31fbf690e4">XHdcp1x_SetCallback()</a>.</p>

</div>
</div>
<a class="anchor" id="ga51b562dcf0e9f5fe995d2ef05f3cc9b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_RxSetLaneCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>LaneCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function set the lane count of an hdcp interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the receiver instance. </td></tr>
    <tr><td class="paramname">LaneCount</td><td>is the number of lanes of the interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__hdcp1x__v4__0.html#gad104aebb80bb03cb66c31eaabf21247a">XHdcp1x_CipherSetNumLanes()</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga230854e10d59500a41137b4f5951042b">XHdcp1x_SetLaneCount()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf696741527cfe391ade5d66238b3cf75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_RxSetPhysicalState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>IsUp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function updates the physical state of an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the receiver instance. </td></tr>
    <tr><td class="paramname">IsUp</td><td>is truth value indicating the status of physical interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gaa00a71253e9a68307ee86ebe6d70b5dc">XHdcp1x_SetPhysicalState()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0b43677a8ea30e51ee23b673349d488e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_RxSetRepeaterBcaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>IsRptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function set the REPEATER bit for the HDCP RX interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the receiver instance. </td></tr>
    <tr><td class="paramname">IsRptr</td><td>is the truth value to determine if the repeater bit in the port registers is to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function disables and then re-enables the interface. </dd></dl>

<p>References <a class="el" href="group__hdcp1x__v4__0.html#ga4ddc37a110b704b91553dea3646d18e2">XHdcp1x_PortSetRepeater()</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga91937cd3d7e1aadbd8bb7be0f6c4fa91">XHdcp1x_SetRepeater()</a>.</p>

</div>
</div>
<a class="anchor" id="ga424c128017a249fece45572f628c2f83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_RxSetTopology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x___repeater_exchange.html">XHdcp1x_RepeaterExchange</a> *&#160;</td>
          <td class="paramname"><em>TopologyPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function sets the RepeaterInfo value int the HDCP RX instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Hdcp1x core instance. </td></tr>
    <tr><td class="paramname">TopologyPtr</td><td>is the pointer to topology information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#addd3478685d4cb9f7ce30ef286a1b371">XHdcp1x::RepeaterValues</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga34d2f8270d1aaf386e38e398a590ca3d">XHdcp1x_SetTopology()</a>.</p>

</div>
</div>
<a class="anchor" id="ga97cc65af5348a4bc57badb185250d39d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_RxSetTopologyDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function sets the Depth value in the HDCP RX BStatus/BInfo register space for the upstream interface to read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Hdcp1x core instance. </td></tr>
    <tr><td class="paramname">Value</td><td>is the Depth value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___repeater_exchange.html#a40144408f1bb58cf5a97b3a50ba792b6">XHdcp1x_RepeaterExchange::Depth</a>, and <a class="el" href="struct_x_hdcp1x.html#addd3478685d4cb9f7ce30ef286a1b371">XHdcp1x::RepeaterValues</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9d528cd47bdd818848c2297734fd86bb">XHdcp1x_SetTopologyField()</a>.</p>

</div>
</div>
<a class="anchor" id="gadfa4b6b01fe73a264da702c451eec590"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_RxSetTopologyDeviceCnt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function sets the DEVICE_COUNT value in the HDCP RX register space for the upstream interface to read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Hdcp1x core instance. </td></tr>
    <tr><td class="paramname">Value</td><td>is the device count value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___repeater_exchange.html#af6d1681d45b9be94629caf1e8ecdfdc2">XHdcp1x_RepeaterExchange::DeviceCount</a>, and <a class="el" href="struct_x_hdcp1x.html#addd3478685d4cb9f7ce30ef286a1b371">XHdcp1x::RepeaterValues</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9d528cd47bdd818848c2297734fd86bb">XHdcp1x_SetTopologyField()</a>.</p>

</div>
</div>
<a class="anchor" id="gad2d20e2c7ccd2e279a5bd4c3400484d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_RxSetTopologyKSVList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>ListPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ListSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function sets the KSVList value(s) in the HDCP RX KSV Fifo register space for the upstream interface to read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Hdcp1x core instance. </td></tr>
    <tr><td class="paramname">ListPtr</td><td>is a pointer to the KSV list. </td></tr>
    <tr><td class="paramname">ListSize</td><td>is the number of KSVs in the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___repeater_exchange.html#a020414febebe00bdd191ee44c5aca495">XHdcp1x_RepeaterExchange::KsvList</a>, <a class="el" href="struct_x_hdcp1x.html#addd3478685d4cb9f7ce30ef286a1b371">XHdcp1x::RepeaterValues</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga8f589bb54a9c7295aa522dcf5f25fbf7">XHDCP1X_PORT_SIZE_BKSV</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad21c705e369902193c9c8b0f0c44027a">XHdcp1x_SetTopologyKSVList()</a>.</p>

</div>
</div>
<a class="anchor" id="gae3eacc3ce1104040154509de3edd755f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_RxSetTopologyMaxCascadeExceeded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function sets the MAX_CASCADE_EXCEEDED error flag in the HDCP BStatus/BInfo register to indicate a topology error. </p>
<p>Setting the flag indicates a depth of more than (4 - 1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Hdcp1x core instance. </td></tr>
    <tr><td class="paramname">Value</td><td>is either TRUE or FALSE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__hdcp1x__v4__0.html#ga16aec39989dd4deb2e7bf9a7ce1af17a">XHDCP1X_PORT_BINFO_DEPTH_ERR_SHIFT</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga6f209255730ba389a6b2ed44a0ba7489">XHDCP1X_PORT_BSTATUS_DEPTH_ERR_SHIFT</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga340474589062fb395d755c3df36b03f8">XHDCP1X_PORT_OFFSET_BINFO</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga735d88629a20a22d8edc3527877160f8">XHDCP1X_PORT_OFFSET_BSTATUS</a>, <a class="el" href="group__hdcp1x__v4__0.html#gab06658de2c710ab133093ac51411f77a">XHDCP1X_PORT_SIZE_BINFO</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga1f5c58db160f9afd130570f0111d094d">XHDCP1X_PORT_SIZE_BSTATUS</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga6e36b9c8a021600e2c9e3766f94b6dc7">XHdcp1x_PortRead()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga46da74febe033d53ef2420d318fd63b9">XHdcp1x_PortWrite()</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9d528cd47bdd818848c2297734fd86bb">XHdcp1x_SetTopologyField()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9e592488862d8a1a599abbcf8bd1b30c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_RxSetTopologyMaxDevsExceeded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function sets the MAX_DEVS_EXCEEDED error flag in the HDCP BStatus register to indicate a topology error. </p>
<p>Setting the flag indicates that more than 31 downstream devices are attached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Hdcp1x core instance. </td></tr>
    <tr><td class="paramname">Value</td><td>is either TRUE or FALSE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___rx.html#a2ed2aea26d867cc8b32c23446a8b356f">XHdcp1x_Rx::AuthenticatedCallback</a>, <a class="el" href="struct_x_hdcp1x___rx.html#af981da076b0ffacb3e6931f7851d4cd3">XHdcp1x_Rx::AuthenticatedCallbackRef</a>, <a class="el" href="struct_x_hdcp1x___rx_encyption_watch.html#a24cd28d7cab88a265a296faabc6be6fc">XHdcp1x_RxEncyptionWatch::CurrentState</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a45dfdf65ea2c69d3bb5f6f2573d1830a">XHdcp1x_Rx::CurrentState</a>, <a class="el" href="struct_x_hdcp1x___repeater_exchange.html#a40144408f1bb58cf5a97b3a50ba792b6">XHdcp1x_RepeaterExchange::Depth</a>, <a class="el" href="struct_x_hdcp1x___repeater_exchange.html#af6d1681d45b9be94629caf1e8ecdfdc2">XHdcp1x_RepeaterExchange::DeviceCount</a>, <a class="el" href="struct_x_hdcp1x___rx.html#afe55c0a1ba26412a5b1671e46e181347">XHdcp1x_Rx::EncryptionUpdateCallback</a>, <a class="el" href="struct_x_hdcp1x___rx.html#af671176e6654eaf148e1d8567b729a2e">XHdcp1x_Rx::EncryptionUpdateCallbackRef</a>, <a class="el" href="struct_x_hdcp1x___rx.html#ad7c01155a2fc2880ae549dc9e373bf4c">XHdcp1x_Rx::Flags</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a5037a2415dafe5f92b225bffcf410e81">XHdcp1x_Rx::IsAuthenticatedCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___rx.html#aab743cb5c6259e89858dce2bac9d01b6">XHdcp1x_Rx::IsEncryptionUpdateCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___rx.html#aba6af280761ee6bb27641062363c9ed6">XHdcp1x_Rx::IsUnauthenticatedCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___repeater_exchange.html#a020414febebe00bdd191ee44c5aca495">XHdcp1x_RepeaterExchange::KsvList</a>, <a class="el" href="struct_x_hdcp1x___rx_stats.html#a0413a42e1eef857cca353d47c132ac4c">XHdcp1x_RxStats::LinkFailures</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a4c40ab97d534b347c297c9cad8911f76">XHdcp1x_Rx::PendingEvents</a>, <a class="el" href="struct_x_hdcp1x___rx_encyption_watch.html#ad5508205069078b7f8728cd35072144a">XHdcp1x_RxEncyptionWatch::PreviousState</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a8fa0e880a311858439ca0a92c6ba75a2">XHdcp1x_Rx::PreviousState</a>, <a class="el" href="struct_x_hdcp1x.html#addd3478685d4cb9f7ce30ef286a1b371">XHdcp1x::RepeaterValues</a>, <a class="el" href="struct_x_hdcp1x___rx_stats.html#ae57022364910875a93bd7019bae98c12">XHdcp1x_RxStats::RiUpdates</a>, <a class="el" href="struct_x_hdcp1x.html#a0a37ba675983dce379385f3f84db9172">XHdcp1x::Rx</a>, <a class="el" href="struct_x_hdcp1x___rx.html#abac529df47db1cb77b62b762d2310cc6">XHdcp1x_Rx::Stats</a>, <a class="el" href="struct_x_hdcp1x___rx.html#ae328e636837cd6fbe4488153f69b4c3f">XHdcp1x_Rx::UnauthenticatedCallback</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a4354d6aba739cf60eb2d5251593d42d0">XHdcp1x_Rx::UnauthenticatedCallbackRef</a>, <a class="el" href="struct_x_hdcp1x___repeater_exchange.html#a7e57043f7b44fe7bb76c6b95159467d7">XHdcp1x_RepeaterExchange::V</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga2ca06586dc06796fdc31a2f64096a28d">XHdcp1x_CipherDisable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa3f73058855c8d60cbd588d74e60a668">XHdcp1x_CipherEnable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9719a81dc9b6815f6b616ccc076f03c2">XHdcp1x_CipherGetRi()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga40c4838c730476e98dfcd742eb1d21a4">XHdcp1x_CipherIsLinkUp()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9d98f541dd4fe90543190e24a4f6b5cc">XHdcp1x_CipherXorInProgress</a>, <a class="el" href="group__hdcp1x__v4__0.html#gab88032bfe3c80ce9595f52f48091914d">XHDCP1X_PORT_BINFO_BIT_DEPTH_NO_ERR</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga37f36590f4f72b858001b286ce2278d6">XHDCP1X_PORT_BINFO_BIT_DEV_CNT_NO_ERR</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga044856b96d20dd177bae15e708edd3c7">XHDCP1X_PORT_BINFO_DEPTH_SHIFT</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga98c8466e4c104803303ac96d9f2382ed">XHDCP1X_PORT_BINFO_DEV_CNT_ERR_SHIFT</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga8f35c083b68c84c215d3a4a8a9d7ea12">XHDCP1X_PORT_BINFO_DEV_CNT_MASK</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga7343134ccbd4456a19c5789f9226e621">XHDCP1X_PORT_BIT_BCAPS_READY</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga0c3f0ec04bdfb89e59ff25412971d907">XHDCP1X_PORT_BIT_BSTATUS_HDMI_MODE</a>, <a class="el" href="group__hdcp1x__v4__0.html#gac77206fca08d48df639b64d9848dd846">XHDCP1X_PORT_BIT_BSTATUS_LINK_FAILURE</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga238771cd5536c2cf6ee36c2b300ac2bd">XHDCP1X_PORT_BIT_BSTATUS_READY</a>, <a class="el" href="group__hdcp1x__v4__0.html#gab4c3aec7795d024dd2c37e672d552f1d">XHDCP1X_PORT_BIT_BSTATUS_RO_AVAILABLE</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga26b1813e56a378c9a828b078708c3b8e">XHDCP1X_PORT_BSTATUS_BIT_DEPTH_NO_ERR</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf0af4fd4db896ef96b51efecb4edc8be">XHDCP1X_PORT_BSTATUS_BIT_DEV_CNT_NO_ERR</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga61336767f855dbc9fe977f855d6cfcd5">XHDCP1X_PORT_BSTATUS_DEPTH_SHIFT</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaebc022d267ef57dd08d861ff38671fdf">XHDCP1X_PORT_BSTATUS_DEV_CNT_ERR_SHIFT</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9fce1aa364b0da511db36570f96f074e">XHDCP1X_PORT_BSTATUS_DEV_CNT_MASK</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga76ea6af219c93dc97fa1c5fd3aef6cbc">XHDCP1X_PORT_HDCP_RESET_KSV</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga317abcf43fb57d32be6b775f0281098e">XHDCP1X_PORT_HDCP_RESET_KSV_RST</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf08fd8380ae111b2568e8663aa673190">XHDCP1X_PORT_OFFSET_BCAPS</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga340474589062fb395d755c3df36b03f8">XHDCP1X_PORT_OFFSET_BINFO</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga735d88629a20a22d8edc3527877160f8">XHDCP1X_PORT_OFFSET_BSTATUS</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga89f673f0c9256a50eaef4c136cce3b4c">XHDCP1X_PORT_OFFSET_KSVFIFO</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga232b0f643c7651084bf3b565c5b444ac">XHDCP1X_PORT_OFFSET_RO</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga00bc49959ffae99012af1f81ddc80668">XHDCP1X_PORT_OFFSET_VH0</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga73cb0b44e5ae774b8c2b6dd5ccca646e">XHDCP1X_PORT_OFFSET_VH1</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae69272331b9a16e7bdf1a5bd0a409ef2">XHDCP1X_PORT_OFFSET_VH2</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga862d61a28bb713632e726d1d0465e8d2">XHDCP1X_PORT_OFFSET_VH3</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae8b5750c01e6b867c5774aa7ca2b81ba">XHDCP1X_PORT_OFFSET_VH4</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf1e0df1c7715eebca1993241bb566721">XHDCP1X_PORT_SIZE_BCAPS</a>, <a class="el" href="group__hdcp1x__v4__0.html#gab06658de2c710ab133093ac51411f77a">XHDCP1X_PORT_SIZE_BINFO</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga8f589bb54a9c7295aa522dcf5f25fbf7">XHDCP1X_PORT_SIZE_BKSV</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga1f5c58db160f9afd130570f0111d094d">XHDCP1X_PORT_SIZE_BSTATUS</a>, <a class="el" href="group__hdcp1x__v4__0.html#gabfc39119e30fc4f207e32244643d4164">XHDCP1X_PORT_SIZE_HDCP_RESET_KSV</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga54b1d34de005b41d4cdc3ee4731b4da4">XHDCP1X_PORT_SIZE_RO</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaaf16f91e2feb9a5228c684fd288d7d62">XHDCP1X_PORT_SIZE_VH0</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga2adda3ea717e8cb0852072e863e134fc">XHDCP1X_PORT_SIZE_VH1</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga05c100e07d844f50d235266c718a6ebb">XHDCP1X_PORT_SIZE_VH2</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa1a7ca2f7760912e2381fce10a5e4d3b">XHDCP1X_PORT_SIZE_VH3</a>, <a class="el" href="group__hdcp1x__v4__0.html#gabebfe755929a4b4ca891648334c7aeca">XHDCP1X_PORT_SIZE_VH4</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga62b350f20404434a855f46c62ee888ed">XHDCP1X_PORT_UINT_TO_BUF</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga6e36b9c8a021600e2c9e3766f94b6dc7">XHdcp1x_PortRead()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga46da74febe033d53ef2420d318fd63b9">XHdcp1x_PortWrite()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga217bbf2604a76a1003c907376d4b8710">XHDCP1X_RPTR_MAX_CASCADE</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf421a5651c89ab4e8ff970ff04d60971">XHDCP1X_RPTR_MAX_DEVS_COUNT</a>, <a class="el" href="struct_x_hdcp1x___rx.html#af46e8a6da2ced045c20dc669888b8c33">XHdcp1x_Rx::XORState</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga689829fd2689d3b67c0f4133179979e4">XVPHY_FLAG_PHY_UP</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae0a88c92b220f5a14f3539f90632fedc">XVPHY_TMO_100MS</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga1166cc4f5ef31f3764bdc10408cfd2b2">XVPHY_TMO_1SECOND</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga9d528cd47bdd818848c2297734fd86bb">XHdcp1x_SetTopologyField()</a>.</p>

</div>
</div>
<a class="anchor" id="gaeb80781bfc840aba969aead350a41e46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_RxSetTopologyUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__rx_8c.html">xhdcp1x_rx.c</a>&gt;</code></p>

<p>This function does the necessary actions to update HDCP after the topology has been set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Hdcp1x core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gaba8f1fa8b28a519d192f1183fae62344">XHdcp1x_SetTopologyUpdate()</a>.</p>

</div>
</div>
<a class="anchor" id="ga710df77b22f0b5c728a51747be26ca2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>This function self tests an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___config.html#a5aaf25a566d02c952e4ec39d2ac4c4bc">XHdcp1x_Config::BaseAddress</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a737c4d0a7a9ceb9297a7383bf87a00c9">XHdcp1x_Config::IsHDMI</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga45c93818933d05bc03a38d74aaf33721">XHDCP1X_CIPHER_REG_VERSION</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga2870575e04b7a20bca6801f47f1f2169">XHdcp1x_IsDP</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga43765c1afc08c59a03b619d0c822e8b7">XHdcp1x_IsHDMI</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae45c2870e08ccd6d6e51409ede847c80">XHdcp1x_IsRX</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga0eb257e3b2af7d84e72e89dd93703d3d">XHdcp1x_IsTX</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga5477e830e157f72072a2a7f470365682">XHdcp1x_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga145ec2236143e47dd0bb8e31fbf690e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_SetCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hdcp1x__v4__0.html#gaa46858c4b302cf0e3f9d59d5c5e6bbb9">XHdcp1x_HandlerType</a>&#160;</td>
          <td class="paramname"><em>HandlerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallbackRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8h.html">xhdcp1x.h</a>&gt;</code></p>

<p>This function installs callback functions for the given HandlerType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the HDCP core instance. </td></tr>
    <tr><td class="paramname">HandlerType</td><td>specifies the type of handler. </td></tr>
    <tr><td class="paramname">CallbackFunc</td><td>is the address of the callback function. </td></tr>
    <tr><td class="paramname">CallbackRef</td><td>is a user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if callback function installed successfully.</li>
<li>XST_INVALID_PARAM when HandlerType is invalid.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Invoking this function for a handler that already has been installed replaces it with the new handler. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga10379d782472233124be66f42559f093">XHdcp1x_RxSetCallback()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga67f8a82df784bef00e7532a43b495d85">XHdcp1x_TxSetCallback()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0d8820c98c821780e9cbede688cc2957"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_SetDebugLogMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hdcp1x__v4__0.html#gaba9f04ac9a482bd9b3696df05868a598">XHdcp1x_LogMsg</a>&#160;</td>
          <td class="paramname"><em>LogFunc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function sets the debug log message function for the module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LogFunc</td><td>is the debug logging function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__hdcp1x__v4__0.html#ga2c89c757bb1b6bb6c904b67afad4f624">XHdcp1xDebugLogMsg</a>.</p>

</div>
</div>
<a class="anchor" id="gac2d6cb2bf146bfd87fc255200b09cd79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_SetDebugPrintf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hdcp1x__v4__0.html#gaa14ea51a98757da9f24e489130804846">XHdcp1x_Printf</a>&#160;</td>
          <td class="paramname"><em>PrintfFunc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function sets the debug printf function for the module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PrintfFunc</td><td>is the printf function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__hdcp1x__v4__0.html#ga9edfb21b66722d61af03129b4dcbb734">XHdcp1xDebugPrintf</a>.</p>

</div>
</div>
<a class="anchor" id="ga405e80474c58ef82e4c27ab99ae70f54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_SetKeySelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>KeySelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function sets the key selection vector that is to be used by the HDCP cipher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to configure. </td></tr>
    <tr><td class="paramname">KeySelect</td><td>is the key selection vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__hdcp1x__v4__0.html#ga6f0a88da0a794b63e3f6caafa912dc10">XHdcp1x_CipherSetKeySelect()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4dc3ae5f39d71120d46f7dacf1f61b4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_SetKsvRevokeCheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hdcp1x__v4__0.html#ga268b0b51f0fc7b58d8c1e21829b52800">XHdcp1x_KsvRevokeCheck</a>&#160;</td>
          <td class="paramname"><em>RevokeCheckFunc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function sets the KSV revocation list check function for the module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RevokeCheckFunc</td><td>is the KSV revocation list check function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__hdcp1x__v4__0.html#ga8669f2b83df6c835492036a201fbae27">XHdcp1xKsvRevokeCheck</a>.</p>

</div>
</div>
<a class="anchor" id="ga230854e10d59500a41137b4f5951042b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_SetLaneCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>LaneCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function sets the lane count of a hdcp interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to update. </td></tr>
    <tr><td class="paramname">LaneCount</td><td>is the lane count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a737c4d0a7a9ceb9297a7383bf87a00c9">XHdcp1x_Config::IsHDMI</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga51b562dcf0e9f5fe995d2ef05f3cc9b1">XHdcp1x_RxSetLaneCount()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gaf4099beda2b952aa7f9ce574cbbc7646">XHdcp1x_TxSetLaneCount()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa00a71253e9a68307ee86ebe6d70b5dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_SetPhysicalState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>IsUp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function updates the state of the underlying physical interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to update. </td></tr>
    <tr><td class="paramname">IsUp</td><td>indicates the state of the underlying physical interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf696741527cfe391ade5d66238b3cf75">XHdcp1x_RxSetPhysicalState()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga5540f73bc84858385b40eb85c2471cdc">XHdcp1x_TxSetPhysicalState()</a>.</p>

</div>
</div>
<a class="anchor" id="ga91937cd3d7e1aadbd8bb7be0f6c4fa91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_SetRepeater </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>State</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function sets the Repeater functionality for an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the interface to disable. </td></tr>
    <tr><td class="paramname">State</td><td>is etiher TRUE or FALSE</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x.html#ac977d9a53ad6777e4c4bcae29d58c4c4">XHdcp1x::IsRepeater</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga0b43677a8ea30e51ee23b673349d488e">XHdcp1x_RxSetRepeaterBcaps()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf3aa7fcf95484728d577700eaa04f2e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_SetTimerDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hdcp1x__v4__0.html#ga53900843854068ce4c5d0521ee9d4774">XHdcp1x_TimerDelay</a>&#160;</td>
          <td class="paramname"><em>TimerDelayFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function sets timer busy delay function for the module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the pointer to the HDCP interface. </td></tr>
    <tr><td class="paramname">TimerDelayFunc</td><td>is the timer busy delay function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#aff7bd50973bcc42ab5540bd9c9d8a709">XHdcp1x::XHdcp1xTimerDelay</a>.</p>

</div>
</div>
<a class="anchor" id="gab38a967494808e941831617a912b37b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_SetTimerStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hdcp1x__v4__0.html#ga38b1342cb63780a12f13f244c46e315f">XHdcp1x_TimerStart</a>&#160;</td>
          <td class="paramname"><em>TimerStartFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function sets timer start function for the module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the pointer to the HDCP interface. </td></tr>
    <tr><td class="paramname">TimerStartFunc</td><td>is the timer start function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a72c9f45f22ce6f84365adebdb31f3211">XHdcp1x::XHdcp1xTimerStart</a>.</p>

</div>
</div>
<a class="anchor" id="gaddaf275034b5df27dd68762192f58b78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_SetTimerStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hdcp1x__v4__0.html#gaea02f57423e496bb1bf659cd6652dd90">XHdcp1x_TimerStop</a>&#160;</td>
          <td class="paramname"><em>TimerStopFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function sets timer stop function for the module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the pointer to the HDCP interface. </td></tr>
    <tr><td class="paramname">TimerStopFunc</td><td>is the timer stop function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4d8be50f6a3e7200a1a09af3ecc2aa2f">XHdcp1x::XHdcp1xTimerStop</a>.</p>

</div>
</div>
<a class="anchor" id="ga34d2f8270d1aaf386e38e398a590ca3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_SetTopology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x___repeater_exchange.html">XHdcp1x_RepeaterExchange</a> *&#160;</td>
          <td class="paramname"><em>TopologyPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function sets the RepeaterInfo value int the HDCP RX instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Hdcp1x core instance. </td></tr>
    <tr><td class="paramname">TopologyPtr</td><td>is a pointer to the Repeater Info value(s).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga424c128017a249fece45572f628c2f83">XHdcp1x_RxSetTopology()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9d528cd47bdd818848c2297734fd86bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_SetTopologyField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hdcp1x__v4__0.html#ga54976f91c0d29039065ce279b6f6d8ad">XHdcp1x_TopologyField</a>&#160;</td>
          <td class="paramname"><em>Field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function is used to set various fields inside the topology structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_hdcp1x.html" title="This typedef contains an instance of an HDCP interface. ">XHdcp1x</a> core instance. </td></tr>
    <tr><td class="paramname">Field</td><td>indicates what field of the topology structure to update. </td></tr>
    <tr><td class="paramname">Value</td><td>is the value assigned to the field of the topology structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__hdcp1x__v4__0.html#ga97cc65af5348a4bc57badb185250d39d">XHdcp1x_RxSetTopologyDepth()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gadfa4b6b01fe73a264da702c451eec590">XHdcp1x_RxSetTopologyDeviceCnt()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae3eacc3ce1104040154509de3edd755f">XHdcp1x_RxSetTopologyMaxCascadeExceeded()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga9e592488862d8a1a599abbcf8bd1b30c">XHdcp1x_RxSetTopologyMaxDevsExceeded()</a>.</p>

</div>
</div>
<a class="anchor" id="gad21c705e369902193c9c8b0f0c44027a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_SetTopologyKSVList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>ListPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ListSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function sets the KSVList value(s) in the HDCP RX KSV Fifo register space for the upstream interface to read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Hdcp1x core instance. </td></tr>
    <tr><td class="paramname">ListPtr</td><td>is a pointer to the KSV list. </td></tr>
    <tr><td class="paramname">ListSize</td><td>is the number of KSVs in the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gad2d20e2c7ccd2e279a5bd4c3400484d3">XHdcp1x_RxSetTopologyKSVList()</a>.</p>

</div>
</div>
<a class="anchor" id="gaba8f1fa8b28a519d192f1183fae62344"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_SetTopologyUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>This function does the necessary actions to update HDCP after the topology has been set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Hdcp1x core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#a2bd303115c93ce720649a9d59a291893">XHdcp1x_Config::IsRx</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga66e1b425725213dd4d5231bf5710e04f">XHDCP1X_DEBUG_PRINTF</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gaeb80781bfc840aba969aead350a41e46">XHdcp1x_RxSetTopologyUpdate()</a>.</p>

</div>
</div>
<a class="anchor" id="gaec7dcf7e211da3d42dc621cb7d062f6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_TxAuthenticate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function initiates authentication on an interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the transmitter instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga103ae62cd1207e7566bf4f39ce946f67">XHdcp1x_Authenticate()</a>.</p>

</div>
</div>
<a class="anchor" id="ga88eb2f469cf2a69bcf8a80271a64330c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_TxDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function disables an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the transmitter instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gab081c08c9cc4edb8c35c85fb27554b3e">XHdcp1x_Disable()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5345387226f345c288ee244f369d8ed5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_TxDisableBlank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function disables the blank output for the cipher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Hdcp1.4 core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___config.html#ada1368e4b8cb979a0feb6ae4682fae54">XHdcp1x_Config::DeviceId</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a25f831507baa26aeccd5f41a2232a9f3">XHdcp1x_Tx::PendingEvents</a>, <a class="el" href="struct_x_hdcp1x___tx_stats.html#a580dab1b002765c851ead593af8c3c98">XHdcp1x_TxStats::ReauthRequested</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a083ec7c93276ad42fbbefb7bc52f7e2a">XHdcp1x_Tx::Stats</a>, <a class="el" href="struct_x_hdcp1x.html#af50e04f7bdf73163fb7632b0ab004d8a">XHdcp1x::Tx</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa2bcbd719e1f2f9b0b5fe6757b5a14b2">XHdcp1x_CipherDisableBlank()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga83e87d466be18c22a62503f408c341cc">XHDCP1X_DEBUG_LOGMSG</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga0f5e4cf832a1dd14f902a2e25043a56e">XHdcp1x_PlatformTimerBusy()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga702d5623fb869e3454ce5557b79cca1a">XHdcp1x_PlatformTimerStart()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga1c5ac368d276bfd8e6a017b64c90cbf1">XHdcp1x_PlatformTimerStop()</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga3bcdf20c5176355adb31bf0477bcaaca">XHdcp1x_DisableBlank()</a>.</p>

</div>
</div>
<a class="anchor" id="gad8b45d2c6a594bdb5210c443d1d0020d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_TxDisableEncryption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>StreamMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function disables encryption on set of streams on an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the transmitter instance. </td></tr>
    <tr><td class="paramname">StreamMap</td><td>is the bit map of streams to disable encryption on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___tx.html#ad09bb07585db661f7cabd6e9919f0cbc">XHdcp1x_Tx::EncryptionMap</a>, <a class="el" href="struct_x_hdcp1x.html#af50e04f7bdf73163fb7632b0ab004d8a">XHdcp1x::Tx</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga49cf0f72f0d918e33d66ff40c91d3073">XHdcp1x_CipherDisableEncryption()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga74a97f4a831692ea2465eb39935ffdcf">XHdcp1x_TxIsEnabled()</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gaad9f3acb0f7df366481d4261542ba2c8">XHdcp1x_DisableEncryption()</a>.</p>

</div>
</div>
<a class="anchor" id="gaaf9b859a4cd68d38f32103a365d48b99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_TxEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function enables an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the transmitter instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga72fafe0eef23bbe5dbbc07a260b8d6b3">XHdcp1x_Enable()</a>.</p>

</div>
</div>
<a class="anchor" id="ga610b320cce6d9ee99a4f8c2380f2c852"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_TxEnableBlank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function enables the blank output for the cipher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Hdcp1.4 core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__hdcp1x__v4__0.html#ga1075068f7db6bf3b0ae31818534f93e8">XHdcp1x_CipherEnableBlank()</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga78468655ea2782da93ae20bab2e9a680">XHdcp1x_EnableBlank()</a>.</p>

</div>
</div>
<a class="anchor" id="ga49660982a4772c7bc0091f7c88c68e19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_TxEnableEncryption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>StreamMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function enables encryption on set of streams on an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the transmitter instance. </td></tr>
    <tr><td class="paramname">StreamMap</td><td>is the bit map of streams to enable encryption on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___tx.html#ad09bb07585db661f7cabd6e9919f0cbc">XHdcp1x_Tx::EncryptionMap</a>, <a class="el" href="struct_x_hdcp1x.html#af50e04f7bdf73163fb7632b0ab004d8a">XHdcp1x::Tx</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga3c42675e40aba8024237fee77155fce4">XHdcp1x_TxIsAuthenticated()</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga7ace40ed3ad14f22e3cce4bc8bf6249c">XHdcp1x_EnableEncryption()</a>.</p>

</div>
</div>
<a class="anchor" id="ga86e8fd4e72f7d913bc7f13ea15f37af7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XHdcp1x_TxGetEncryption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function retrieves the current encryption stream map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>the transmitter instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current encryption stream map.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___tx.html#ad09bb07585db661f7cabd6e9919f0cbc">XHdcp1x_Tx::EncryptionMap</a>, and <a class="el" href="struct_x_hdcp1x.html#af50e04f7bdf73163fb7632b0ab004d8a">XHdcp1x::Tx</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga60f6a284a49f0e381c353180ec5bebdc">XHdcp1x_GetEncryption()</a>.</p>

</div>
</div>
<a class="anchor" id="gab22ac8a26a4b60bdeda3be59baacbf39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_hdcp1x___repeater_exchange.html">XHdcp1x_RepeaterExchange</a> * XHdcp1x_TxGetTopology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function returns a pointer to the downstream Topology structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XHdcp14 core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the XHdcp14 Topology structure or NULL when the topology info is invalid.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___tx.html#a13e72aa53d494ecce37f3d8921e1003d">XHdcp1x_Tx::AuthenticatedCallback</a>, <a class="el" href="struct_x_hdcp1x___tx.html#afd2d6ab03a4cc4169ff39cfa53bfbf28">XHdcp1x_Tx::AuthenticatedCallbackRef</a>, <a class="el" href="struct_x_hdcp1x___tx_stats.html#ad10ad43ee79a9bd6920a50ce02225f60">XHdcp1x_TxStats::AuthPassed</a>, <a class="el" href="struct_x_hdcp1x___tx.html#aa1ee1e1bfffebdf1add39be5ae81d741">XHdcp1x_Tx::CurrentState</a>, <a class="el" href="struct_x_hdcp1x___rx.html#a45dfdf65ea2c69d3bb5f6f2573d1830a">XHdcp1x_Rx::CurrentState</a>, <a class="el" href="struct_x_hdcp1x___repeater_exchange.html#a40144408f1bb58cf5a97b3a50ba792b6">XHdcp1x_RepeaterExchange::Depth</a>, <a class="el" href="struct_x_hdcp1x___repeater_exchange.html#af6d1681d45b9be94629caf1e8ecdfdc2">XHdcp1x_RepeaterExchange::DeviceCount</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a93c6808d7ec5710cbeac456698d27ebd">XHdcp1x_Tx::DownstreamReady</a>, <a class="el" href="struct_x_hdcp1x___tx.html#ad09bb07585db661f7cabd6e9919f0cbc">XHdcp1x_Tx::EncryptionMap</a>, <a class="el" href="struct_x_hdcp1x___tx.html#afaf115a5149798441d2e8559d2b58146">XHdcp1x_Tx::Flags</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a70af322f00eac53a663529097cb26235">XHdcp1x_Tx::IsAuthenticatedCallbackSet</a>, <a class="el" href="struct_x_hdcp1x.html#ac977d9a53ad6777e4c4bcae29d58c4c4">XHdcp1x::IsRepeater</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a3e2bb59f4101bf76db71060e0e2f310e">XHdcp1x_Tx::IsRepeaterExchangeCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___tx.html#af22151e0777ff7de84b9ae6e3da0561d">XHdcp1x_Tx::IsUnauthenticatedCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___repeater_exchange.html#a020414febebe00bdd191ee44c5aca495">XHdcp1x_RepeaterExchange::KsvList</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a25f831507baa26aeccd5f41a2232a9f3">XHdcp1x_Tx::PendingEvents</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a68b51570127d707615a8ae4324c08b02">XHdcp1x_Tx::PreviousState</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a447d308ccbf30a72a603ebdeb534d3ce">XHdcp1x_Tx::RepeaterExchangeCallback</a>, <a class="el" href="struct_x_hdcp1x___tx.html#aa8ceb4d9918e409bc97d98f679c5b627">XHdcp1x_Tx::RepeaterExchangeRef</a>, <a class="el" href="struct_x_hdcp1x.html#addd3478685d4cb9f7ce30ef286a1b371">XHdcp1x::RepeaterValues</a>, <a class="el" href="struct_x_hdcp1x.html#a0a37ba675983dce379385f3f84db9172">XHdcp1x::Rx</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a6320853e7f69b7b6e7f7b961edde3700">XHdcp1x_Tx::StateHelper</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a083ec7c93276ad42fbbefb7bc52f7e2a">XHdcp1x_Tx::Stats</a>, <a class="el" href="struct_x_hdcp1x.html#af50e04f7bdf73163fb7632b0ab004d8a">XHdcp1x::Tx</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a67bc52721c7f0780e6a2e9cc80b82340">XHdcp1x_Tx::UnauthenticatedCallback</a>, <a class="el" href="struct_x_hdcp1x___tx.html#ac1b72fd9c0405f4aedc6dcdc6baa66eb">XHdcp1x_Tx::UnauthenticatedCallbackRef</a>, <a class="el" href="struct_x_hdcp1x___repeater_exchange.html#a7e57043f7b44fe7bb76c6b95159467d7">XHdcp1x_RepeaterExchange::V</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga2ca06586dc06796fdc31a2f64096a28d">XHdcp1x_CipherDisable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa3f73058855c8d60cbd588d74e60a668">XHdcp1x_CipherEnable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga0b4d815c1d172e921b83f3685d54012b">XHDCP1X_PORT_BUF_TO_UINT</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga340474589062fb395d755c3df36b03f8">XHDCP1X_PORT_OFFSET_BINFO</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga1865cffebcba3167ab0867e3a276fe12">XHDCP1X_PORT_OFFSET_BKSV</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga735d88629a20a22d8edc3527877160f8">XHDCP1X_PORT_OFFSET_BSTATUS</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga00bc49959ffae99012af1f81ddc80668">XHDCP1X_PORT_OFFSET_VH0</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga73cb0b44e5ae774b8c2b6dd5ccca646e">XHDCP1X_PORT_OFFSET_VH1</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae69272331b9a16e7bdf1a5bd0a409ef2">XHDCP1X_PORT_OFFSET_VH2</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga862d61a28bb713632e726d1d0465e8d2">XHDCP1X_PORT_OFFSET_VH3</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae8b5750c01e6b867c5774aa7ca2b81ba">XHDCP1X_PORT_OFFSET_VH4</a>, <a class="el" href="group__hdcp1x__v4__0.html#gab06658de2c710ab133093ac51411f77a">XHDCP1X_PORT_SIZE_BINFO</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga8f589bb54a9c7295aa522dcf5f25fbf7">XHDCP1X_PORT_SIZE_BKSV</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga1f5c58db160f9afd130570f0111d094d">XHDCP1X_PORT_SIZE_BSTATUS</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaaf16f91e2feb9a5228c684fd288d7d62">XHDCP1X_PORT_SIZE_VH0</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga2adda3ea717e8cb0852072e863e134fc">XHDCP1X_PORT_SIZE_VH1</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga05c100e07d844f50d235266c718a6ebb">XHDCP1X_PORT_SIZE_VH2</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa1a7ca2f7760912e2381fce10a5e4d3b">XHDCP1X_PORT_SIZE_VH3</a>, <a class="el" href="group__hdcp1x__v4__0.html#gabebfe755929a4b4ca891648334c7aeca">XHDCP1X_PORT_SIZE_VH4</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga41b5285a790690159dece6baa5afadf9">XHdcp1x_PortIsRepeater()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga6e36b9c8a021600e2c9e3766f94b6dc7">XHdcp1x_PortRead()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga2d64ba19dac4365d7a379994dd3bbf9e">XVPHY_FLAG_IS_REPEATER</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga689829fd2689d3b67c0f4133179979e4">XVPHY_FLAG_PHY_UP</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae0a88c92b220f5a14f3539f90632fedc">XVPHY_TMO_100MS</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga1166cc4f5ef31f3764bdc10408cfd2b2">XVPHY_TMO_1SECOND</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga1030400c6c423608ffd155b9cb4d12ef">XHdcp1x_GetTopology()</a>.</p>

</div>
</div>
<a class="anchor" id="gaacbe196b64bd19fe98db62e552b89788"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 * XHdcp1x_TxGetTopologyBKSV </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function returns the value of BKSV of the device connected to the repeater downstream interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XHdcp14 core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE if MAX_DEPTH_EXCEEDED</li>
<li>FALSE if not</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__hdcp1x__v4__0.html#ga0b4d815c1d172e921b83f3685d54012b">XHDCP1X_PORT_BUF_TO_UINT</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga1865cffebcba3167ab0867e3a276fe12">XHDCP1X_PORT_OFFSET_BKSV</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga8f589bb54a9c7295aa522dcf5f25fbf7">XHDCP1X_PORT_SIZE_BKSV</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga6e36b9c8a021600e2c9e3766f94b6dc7">XHdcp1x_PortRead()</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gaa0dc57eed89ceb400350f9d78551946e">XHdcp1x_GetTopologyBKSV()</a>.</p>

</div>
</div>
<a class="anchor" id="ga11572e1f3d8c314380b5442a2edfb4bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XHdcp1x_TxGetTopologyDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function returns the value of Depth read in the downstream interface of the repeater topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XHdcp14 core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of Depth.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___repeater_exchange.html#a40144408f1bb58cf5a97b3a50ba792b6">XHdcp1x_RepeaterExchange::Depth</a>, and <a class="el" href="struct_x_hdcp1x.html#addd3478685d4cb9f7ce30ef286a1b371">XHdcp1x::RepeaterValues</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga410b33d14bb0883e3de81a5f784800b4">XHdcp1x_GetTopologyField()</a>.</p>

</div>
</div>
<a class="anchor" id="gad4fca1a785fdb5e58b98c8f6619614e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XHdcp1x_TxGetTopologyDeviceCnt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function returns the value of Device Count read in the downstream interface of the repeater topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XHdcp14 core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE if MAX_DEPTH_EXCEEDED</li>
<li>FALSE if not</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___repeater_exchange.html#af6d1681d45b9be94629caf1e8ecdfdc2">XHdcp1x_RepeaterExchange::DeviceCount</a>, and <a class="el" href="struct_x_hdcp1x.html#addd3478685d4cb9f7ce30ef286a1b371">XHdcp1x::RepeaterValues</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga410b33d14bb0883e3de81a5f784800b4">XHdcp1x_GetTopologyField()</a>.</p>

</div>
</div>
<a class="anchor" id="gad633915b955c6b56fa317e44bf26593a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 * XHdcp1x_TxGetTopologyKSVList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function returns the value of KSV List read in the downstream interface of the repeater topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XHdcp14 core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE if MAX_DEPTH_EXCEEDED</li>
<li>FALSE if not</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___repeater_exchange.html#af6d1681d45b9be94629caf1e8ecdfdc2">XHdcp1x_RepeaterExchange::DeviceCount</a>, <a class="el" href="struct_x_hdcp1x___repeater_exchange.html#a020414febebe00bdd191ee44c5aca495">XHdcp1x_RepeaterExchange::KsvList</a>, and <a class="el" href="struct_x_hdcp1x.html#addd3478685d4cb9f7ce30ef286a1b371">XHdcp1x::RepeaterValues</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gaf9abe5fb8d1b7663035ceb0250368699">XHdcp1x_GetTopologyKSVList()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf854c758691f491c5f80e89a795f2a24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XHdcp1x_TxGetTopologyMaxCascadeExceeded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function returns the MAX_DEPTH_EXCEEDED flag in the repeater topology structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XHdcp14 core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE if MAX_DEPTH_EXCEEDED</li>
<li>FALSE if not</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__hdcp1x__v4__0.html#ga3e0e68475a7bc3c4c23dd0eee76f242a">XHDCP1X_PORT_BINFO_BIT_DEPTH_ERR</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga1f61304755f675caa5adfa5dfaa7d766">XHDCP1X_PORT_BSTATUS_BIT_DEPTH_ERR</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga340474589062fb395d755c3df36b03f8">XHDCP1X_PORT_OFFSET_BINFO</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga735d88629a20a22d8edc3527877160f8">XHDCP1X_PORT_OFFSET_BSTATUS</a>, <a class="el" href="group__hdcp1x__v4__0.html#gab06658de2c710ab133093ac51411f77a">XHDCP1X_PORT_SIZE_BINFO</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga1f5c58db160f9afd130570f0111d094d">XHDCP1X_PORT_SIZE_BSTATUS</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga6e36b9c8a021600e2c9e3766f94b6dc7">XHdcp1x_PortRead()</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga410b33d14bb0883e3de81a5f784800b4">XHdcp1x_GetTopologyField()</a>.</p>

</div>
</div>
<a class="anchor" id="ga029629390d42624ba18930e5d73a948e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XHdcp1x_TxGetTopologyMaxDevsExceeded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function returns the MAX_DEVICS_EXCEEDED flag in the repeater topology structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XHdcp14 core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE if MAX_DEVICES_EXCEEDED</li>
<li>FALSE if not</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__hdcp1x__v4__0.html#ga6aff792c7dfb910015f1ebced29ce96f">XHDCP1X_PORT_BINFO_BIT_DEV_CNT_ERR</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9760b101a94e3f360a0c37b3622d8084">XHDCP1X_PORT_BSTATUS_BIT_DEV_CNT_ERR</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga340474589062fb395d755c3df36b03f8">XHDCP1X_PORT_OFFSET_BINFO</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga735d88629a20a22d8edc3527877160f8">XHDCP1X_PORT_OFFSET_BSTATUS</a>, <a class="el" href="group__hdcp1x__v4__0.html#gab06658de2c710ab133093ac51411f77a">XHDCP1X_PORT_SIZE_BINFO</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga1f5c58db160f9afd130570f0111d094d">XHDCP1X_PORT_SIZE_BSTATUS</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga6e36b9c8a021600e2c9e3766f94b6dc7">XHdcp1x_PortRead()</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga410b33d14bb0883e3de81a5f784800b4">XHdcp1x_GetTopologyField()</a>.</p>

</div>
</div>
<a class="anchor" id="ga79bb13897f9893f9ffbecd6247aea442"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_TxHandleTimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function handles a timeout on an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the transmitter instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gadefd696ca95f00b16f9af353a0f7d2e8">XHdcp1x_HandleTimeout()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa503ece3533fb6055289ad2dd01ba80b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_TxInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function implements the debug display output for transmit instances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the receiver instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___tx_stats.html#a3525721564be4f40c49527d3c4819d93">XHdcp1x_TxStats::AuthFailed</a>, <a class="el" href="struct_x_hdcp1x___tx_stats.html#ad10ad43ee79a9bd6920a50ce02225f60">XHdcp1x_TxStats::AuthPassed</a>, <a class="el" href="struct_x_hdcp1x.html#ac4680b598dc6987ff0f60f8faaf91f0a">XHdcp1x::Cipher</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___tx.html#aa1ee1e1bfffebdf1add39be5ae81d741">XHdcp1x_Tx::CurrentState</a>, <a class="el" href="struct_x_hdcp1x___tx.html#ad09bb07585db661f7cabd6e9919f0cbc">XHdcp1x_Tx::EncryptionMap</a>, <a class="el" href="struct_x_hdcp1x___tx.html#afaf115a5149798441d2e8559d2b58146">XHdcp1x_Tx::Flags</a>, <a class="el" href="struct_x_hdcp1x___cipher_stats.html#a105f3fd602c69a8fdcddb02b7b716440">XHdcp1x_CipherStats::IntCount</a>, <a class="el" href="struct_x_hdcp1x___port_stats.html#a5e09862f792ac5882b922a58a4d78e72">XHdcp1x_PortStats::IntCount</a>, <a class="el" href="struct_x_hdcp1x___config.html#a737c4d0a7a9ceb9297a7383bf87a00c9">XHdcp1x_Config::IsHDMI</a>, <a class="el" href="struct_x_hdcp1x___tx_stats.html#ab1b6f9d07408de0e2b7b14c641d6fc61">XHdcp1x_TxStats::LinkCheckFailed</a>, <a class="el" href="struct_x_hdcp1x___tx_stats.html#addbf1a011f13ce22d5118c661a332b44">XHdcp1x_TxStats::LinkCheckPassed</a>, <a class="el" href="struct_x_hdcp1x.html#a8234eabad6b1c38cb2cb725ef0ab9b47">XHdcp1x::Port</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a68b51570127d707615a8ae4324c08b02">XHdcp1x_Tx::PreviousState</a>, <a class="el" href="struct_x_hdcp1x___tx_stats.html#aac1925f5af13ab1e81df715b06394c06">XHdcp1x_TxStats::ReadFailures</a>, <a class="el" href="struct_x_hdcp1x___tx_stats.html#a580dab1b002765c851ead593af8c3c98">XHdcp1x_TxStats::ReauthRequested</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a6320853e7f69b7b6e7f7b961edde3700">XHdcp1x_Tx::StateHelper</a>, <a class="el" href="struct_x_hdcp1x___cipher.html#a5f777760902410ea791790862f150e91">XHdcp1x_Cipher::Stats</a>, <a class="el" href="struct_x_hdcp1x___port_struct.html#a316391664c4d927846ef9169bf723e0f">XHdcp1x_PortStruct::Stats</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a083ec7c93276ad42fbbefb7bc52f7e2a">XHdcp1x_Tx::Stats</a>, <a class="el" href="struct_x_hdcp1x.html#af50e04f7bdf73163fb7632b0ab004d8a">XHdcp1x::Tx</a>, <a class="el" href="group__hdcp1x__v4__0.html#gacc166098738c7aac2703ee0cbd757c01">XHdcp1x_CipherGetLocalKsv()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaac542620e5aa06df5f83f097a6fc7738">XHdcp1x_CipherGetVersion()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga66e1b425725213dd4d5231bf5710e04f">XHDCP1X_DEBUG_PRINTF</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga52085c5f3ece2e12521fe526dbc7742f">XHdcp1x_GetDriverVersion()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gaf8d484e140ba4935f33b7fd14b9c5c2a">XHdcp1x_IsEncrypted()</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga7f8a11ce5614a2541b378f034b3198cb">XHdcp1x_Info()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7cff233ed850c294c88271be7f76235e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_TxInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function initializes a transmit state machine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the receiver instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___tx.html#a25f831507baa26aeccd5f41a2232a9f3">XHdcp1x_Tx::PendingEvents</a>, and <a class="el" href="struct_x_hdcp1x.html#af50e04f7bdf73163fb7632b0ab004d8a">XHdcp1x::Tx</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga931fc14801a82c9cc3aa870d887bbc07">XHdcp1x_CfgInitialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3c42675e40aba8024237fee77155fce4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_TxIsAuthenticated </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function queries an interface to check if its been authenticated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the transmitter instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating authenticated (true) or not (false).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___tx.html#aa1ee1e1bfffebdf1add39be5ae81d741">XHdcp1x_Tx::CurrentState</a>, and <a class="el" href="struct_x_hdcp1x.html#af50e04f7bdf73163fb7632b0ab004d8a">XHdcp1x::Tx</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gacce89db1cfc0e9cd5c632f3499bff690">XHdcp1x_IsAuthenticated()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga49660982a4772c7bc0091f7c88c68e19">XHdcp1x_TxEnableEncryption()</a>.</p>

</div>
</div>
<a class="anchor" id="gad30b097e8f3ff909c1ad5bd4c6a7d7c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_TxIsDownstrmCapable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function queries the downstream device to check if the downstream device is HDCP capable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the receiver instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating HDCP capability (true) or not (false).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__hdcp1x__v4__0.html#gaf1e24817724b0410a9b272343a0ef745">XHdcp1x_PortIsCapable()</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gae8389541cb1c23695221b17789eb945c">XHdcp1x_IsDwnstrmCapable()</a>.</p>

</div>
</div>
<a class="anchor" id="ga74a97f4a831692ea2465eb39935ffdcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_TxIsEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function queries an interface to check if it is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the transmitter instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating is enabled (true) or not (false).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___tx.html#aa1ee1e1bfffebdf1add39be5ae81d741">XHdcp1x_Tx::CurrentState</a>, and <a class="el" href="struct_x_hdcp1x.html#af50e04f7bdf73163fb7632b0ab004d8a">XHdcp1x::Tx</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gac175508b95f7a2d101630aca5b55e8e5">XHdcp1x_IsEnabled()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#gad8b45d2c6a594bdb5210c443d1d0020d">XHdcp1x_TxDisableEncryption()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3d0d1dc50d7b95639e72d74b1fa2d064"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_TxIsInComputations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function queries an interface to check if its in the computations state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the transmitter instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating authenticated (true) or not (false).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___tx.html#aa1ee1e1bfffebdf1add39be5ae81d741">XHdcp1x_Tx::CurrentState</a>, and <a class="el" href="struct_x_hdcp1x.html#af50e04f7bdf73163fb7632b0ab004d8a">XHdcp1x::Tx</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gad264c967aebfe269ea6e40f675886c9f">XHdcp1x_IsInComputations()</a>.</p>

</div>
</div>
<a class="anchor" id="ga26586d8954b1ed09f365399f6f7fd6b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_TxIsInProgress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function queries an interface to check if authentication is still in progress. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the transmitter instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating in progress (true) or not (false).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___tx.html#aa1ee1e1bfffebdf1add39be5ae81d741">XHdcp1x_Tx::CurrentState</a>, and <a class="el" href="struct_x_hdcp1x.html#af50e04f7bdf73163fb7632b0ab004d8a">XHdcp1x::Tx</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga934f616f1b538de0f90a343bc1185380">XHdcp1x_IsInProgress()</a>.</p>

</div>
</div>
<a class="anchor" id="gae4b47fe66cfc82912ada3df74ade247b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_TxIsInWaitforready </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function queries an interface to check if its in the wait-for-ready state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the transmitter instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truth value indicating authenticated (true) or not (false).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___tx.html#aa1ee1e1bfffebdf1add39be5ae81d741">XHdcp1x_Tx::CurrentState</a>, and <a class="el" href="struct_x_hdcp1x.html#af50e04f7bdf73163fb7632b0ab004d8a">XHdcp1x::Tx</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga93df0cf3372141a9fd419a02c753196c">XHdcp1x_IsInWaitforready()</a>.</p>

</div>
</div>
<a class="anchor" id="gaee964dc4d6fc103705d6358fc2db9480"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_TxIsRepeater </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function returns if HDCP TX interface is connected to a downstream repeater. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the transmitter instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE if Repeater.</li>
<li>FALSE if not Repeater,</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__hdcp1x__v4__0.html#ga41b5285a790690159dece6baa5afadf9">XHdcp1x_PortIsRepeater()</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gac0c5947639623f7b97d9ec1cc712e75f">XHdcp1x_IsRepeater()</a>.</p>

</div>
</div>
<a class="anchor" id="gac2ceda82b4b6c4e6419e864895109ffa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_TxPoll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function polls an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the transmitter instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga81768260ec0f02284c294051c56e328e">XHdcp1x_Poll()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf52273c741319df900b9fe2bb51b78d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_TxReadDownstream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function initiates the transmitter to read READY bit from downstream and complete second part of authentication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the transmitter instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga4e1dc21a163e1e2c5281c36f23519a85">XHdcp1x_ReadDownstream()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f96aea1f54189b92719510de767b768"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_TxReset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function resets an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the transmitter instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function disables and then re-enables the interface. </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga5a42371924892562d7f6df80d5907a1f">XHdcp1x_Reset()</a>.</p>

</div>
</div>
<a class="anchor" id="ga67f8a82df784bef00e7532a43b495d85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_TxSetCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hdcp1x__v4__0.html#gaa46858c4b302cf0e3f9d59d5c5e6bbb9">XHdcp1x_HandlerType</a>&#160;</td>
          <td class="paramname"><em>HandlerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallbackRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function installs callback functions for the given HandlerType: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the HDCP core instance. </td></tr>
    <tr><td class="paramname">HandlerType</td><td>specifies the type of handler. </td></tr>
    <tr><td class="paramname">CallbackFunc</td><td>is the address of the callback function. </td></tr>
    <tr><td class="paramname">CallbackRef</td><td>is a user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if callback function installed successfully.</li>
<li>XST_INVALID_PARAM when HandlerType is invalid.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Invoking this function for a handler that already has been installed replaces it with the new handler. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___tx.html#a13e72aa53d494ecce37f3d8921e1003d">XHdcp1x_Tx::AuthenticatedCallback</a>, <a class="el" href="struct_x_hdcp1x___tx.html#afd2d6ab03a4cc4169ff39cfa53bfbf28">XHdcp1x_Tx::AuthenticatedCallbackRef</a>, <a class="el" href="struct_x_hdcp1x___tx.html#afcdeddb51718ba23ccbc9bf5f40b00e1">XHdcp1x_Tx::DdcRead</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a56b450fdf052cd33e2cfee9032ce089d">XHdcp1x_Tx::DdcReadRef</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a5f80ddbc1b84614ccbbbf6aa12399c8e">XHdcp1x_Tx::DdcWrite</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a2f40f5920b1208a36ccd24d0427ccb4f">XHdcp1x_Tx::DdcWriteRef</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a70af322f00eac53a663529097cb26235">XHdcp1x_Tx::IsAuthenticatedCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a5c978bfee6f5eb921661efbed3bb58f5">XHdcp1x_Tx::IsDdcReadSet</a>, <a class="el" href="struct_x_hdcp1x___tx.html#aff2f62fca46ff41d487edf0fe34dc2a6">XHdcp1x_Tx::IsDdcWriteSet</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a3e2bb59f4101bf76db71060e0e2f310e">XHdcp1x_Tx::IsRepeaterExchangeCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___tx.html#af22151e0777ff7de84b9ae6e3da0561d">XHdcp1x_Tx::IsUnauthenticatedCallbackSet</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a447d308ccbf30a72a603ebdeb534d3ce">XHdcp1x_Tx::RepeaterExchangeCallback</a>, <a class="el" href="struct_x_hdcp1x___tx.html#aa8ceb4d9918e409bc97d98f679c5b627">XHdcp1x_Tx::RepeaterExchangeRef</a>, <a class="el" href="struct_x_hdcp1x.html#af50e04f7bdf73163fb7632b0ab004d8a">XHdcp1x::Tx</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a67bc52721c7f0780e6a2e9cc80b82340">XHdcp1x_Tx::UnauthenticatedCallback</a>, and <a class="el" href="struct_x_hdcp1x___tx.html#ac1b72fd9c0405f4aedc6dcdc6baa66eb">XHdcp1x_Tx::UnauthenticatedCallbackRef</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga145ec2236143e47dd0bb8e31fbf690e4">XHdcp1x_SetCallback()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf4099beda2b952aa7f9ce574cbbc7646"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_TxSetLaneCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>LaneCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function set the lane count of an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the transmitter instance. </td></tr>
    <tr><td class="paramname">LaneCount</td><td>is the number of lanes of the interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__hdcp1x__v4__0.html#gad104aebb80bb03cb66c31eaabf21247a">XHdcp1x_CipherSetNumLanes()</a>.</p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga230854e10d59500a41137b4f5951042b">XHdcp1x_SetLaneCount()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5540f73bc84858385b40eb85c2471cdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XHdcp1x_TxSetPhysicalState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_hdcp1x.html">XHdcp1x</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>IsUp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function updates the physical state of an HDCP interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the transmitter instance. </td></tr>
    <tr><td class="paramname">IsUp</td><td>is truth value indicating the status of physical interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gaa00a71253e9a68307ee86ebe6d70b5dc">XHdcp1x_SetPhysicalState()</a>.</p>

</div>
</div>
<a class="anchor" id="gab797b1cff481d823174db2e3fdec666a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XHdcp1x_TxTriggerDownstreamAuth </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Parameter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__tx_8c.html">xhdcp1x_tx.c</a>&gt;</code></p>

<p>This function acts as the downstream authentication trigger callback for a Repeater state machine, to start the second part of authentication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Parameter</td><td>is the parameter specified during registration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_hdcp1x___tx_stats.html#a3525721564be4f40c49527d3c4819d93">XHdcp1x_TxStats::AuthFailed</a>, <a class="el" href="struct_x_hdcp1x.html#a4fd777f9a8a407ed4b2d6d02fab202ea">XHdcp1x::Config</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a93c6808d7ec5710cbeac456698d27ebd">XHdcp1x_Tx::DownstreamReady</a>, <a class="el" href="struct_x_hdcp1x___tx.html#ad09bb07585db661f7cabd6e9919f0cbc">XHdcp1x_Tx::EncryptionMap</a>, <a class="el" href="struct_x_hdcp1x___tx.html#afaf115a5149798441d2e8559d2b58146">XHdcp1x_Tx::Flags</a>, <a class="el" href="struct_x_hdcp1x___config.html#a737c4d0a7a9ceb9297a7383bf87a00c9">XHdcp1x_Config::IsHDMI</a>, <a class="el" href="struct_x_hdcp1x___repeater_exchange.html#a020414febebe00bdd191ee44c5aca495">XHdcp1x_RepeaterExchange::KsvList</a>, <a class="el" href="struct_x_hdcp1x___tx_stats.html#ab1b6f9d07408de0e2b7b14c641d6fc61">XHdcp1x_TxStats::LinkCheckFailed</a>, <a class="el" href="struct_x_hdcp1x___tx_stats.html#addbf1a011f13ce22d5118c661a332b44">XHdcp1x_TxStats::LinkCheckPassed</a>, <a class="el" href="struct_x_hdcp1x___tx_stats.html#aac1925f5af13ab1e81df715b06394c06">XHdcp1x_TxStats::ReadFailures</a>, <a class="el" href="struct_x_hdcp1x.html#addd3478685d4cb9f7ce30ef286a1b371">XHdcp1x::RepeaterValues</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a6320853e7f69b7b6e7f7b961edde3700">XHdcp1x_Tx::StateHelper</a>, <a class="el" href="struct_x_hdcp1x___tx.html#a083ec7c93276ad42fbbefb7bc52f7e2a">XHdcp1x_Tx::Stats</a>, <a class="el" href="struct_x_hdcp1x.html#af50e04f7bdf73163fb7632b0ab004d8a">XHdcp1x::Tx</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga2ca06586dc06796fdc31a2f64096a28d">XHdcp1x_CipherDisable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga49cf0f72f0d918e33d66ff40c91d3073">XHdcp1x_CipherDisableEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad44ad72f65d851de50c40053e327ba9e">XHdcp1x_CipherDoRequest()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa3f73058855c8d60cbd588d74e60a668">XHdcp1x_CipherEnable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga706d8729ad07f34fad5e20f83c59d69f">XHdcp1x_CipherEnableEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae38ae0f74022763d8650a21fedcd15e5">XHdcp1x_CipherGetEncryption()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gacc166098738c7aac2703ee0cbd757c01">XHdcp1x_CipherGetLocalKsv()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga72d8fd0f45ff6424d3aac43e36360fec">XHdcp1x_CipherGetMi()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gad8759c2071248b537b7ae18b2a1ec5a6">XHdcp1x_CipherGetMo()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga9719a81dc9b6815f6b616ccc076f03c2">XHdcp1x_CipherGetRi()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga14ed33ea832900d1022b7a1e8ddba397">XHdcp1x_CipherGetRo()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gace24c74db709b523e1aae7e082494022">XHdcp1x_CipherIsRequestComplete()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga70bcb7dd61e57e5b33d2213817a80eca">XHdcp1x_CipherSetB()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gafc9a91374b2e78ea1aade28082e354a7">XHdcp1x_CipherSetCallback()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga320b0410ab8e10a8bc5c2a6278ed06d7">XHdcp1x_CipherSetRemoteKsv()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae2ae95918ecd46e725812a9bce8f6478">XHdcp1x_CipherSetRiUpdate()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaceb8746cc60b1628b4df76d155f0b6a5">XHdcp1x_PlatformIsKsvRevoked()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga044856b96d20dd177bae15e708edd3c7">XHDCP1X_PORT_BINFO_DEPTH_SHIFT</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga0c3f0ec04bdfb89e59ff25412971d907">XHDCP1X_PORT_BIT_BSTATUS_HDMI_MODE</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga61336767f855dbc9fe977f855d6cfcd5">XHDCP1X_PORT_BSTATUS_DEPTH_SHIFT</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga0b4d815c1d172e921b83f3685d54012b">XHDCP1X_PORT_BUF_TO_UINT</a>, <a class="el" href="group__hdcp1x__v4__0.html#gga758e8028b33a9204cabc6b8327eacaf3a1763ad0694adf51c42870df78089ec87">XHDCP1X_PORT_HANDLER_AUTHENTICATE</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga99893f9f0385518d617593982a8aad71">XHDCP1X_PORT_OFFSET_AINFO</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga0cf254f7b06dddaade9b80d1474a37d2">XHDCP1X_PORT_OFFSET_AKSV</a>, <a class="el" href="group__hdcp1x__v4__0.html#gafc793c58510855ab8647e1b46966ae91">XHDCP1X_PORT_OFFSET_AN</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga1865cffebcba3167ab0867e3a276fe12">XHDCP1X_PORT_OFFSET_BKSV</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga89f673f0c9256a50eaef4c136cce3b4c">XHDCP1X_PORT_OFFSET_KSVFIFO</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga232b0f643c7651084bf3b565c5b444ac">XHDCP1X_PORT_OFFSET_RO</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga00bc49959ffae99012af1f81ddc80668">XHDCP1X_PORT_OFFSET_VH0</a>, <a class="el" href="group__hdcp1x__v4__0.html#gae46b665a4147e46b47f82189f4930f77">XHDCP1X_PORT_SIZE_AINFO</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga1b3e2eeb2a7f7ed7c7054bf387e16a10">XHDCP1X_PORT_SIZE_AKSV</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaa49a07e54b5cf34b332e11e7784ef81e">XHDCP1X_PORT_SIZE_AN</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga8f589bb54a9c7295aa522dcf5f25fbf7">XHDCP1X_PORT_SIZE_BKSV</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga6fad60e8cce1de54c9496e79c4cf8aa5">XHDCP1X_PORT_SIZE_KSVFIFO</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga62b350f20404434a855f46c62ee888ed">XHDCP1X_PORT_UINT_TO_BUF</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga152c8d8f9abdee612ce15f6e914a122a">XHdcp1x_PortDisable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gafe3971f3a49c69f3a316f3fab58fdf20">XHdcp1x_PortEnable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga8865a6a7279587d2a439f603b78bf35c">XHdcp1x_PortGetRepeaterInfo()</a>, <a class="el" href="group__hdcp1x__v4__0.html#gaf1e24817724b0410a9b272343a0ef745">XHdcp1x_PortIsCapable()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga41b5285a790690159dece6baa5afadf9">XHdcp1x_PortIsRepeater()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga6e36b9c8a021600e2c9e3766f94b6dc7">XHdcp1x_PortRead()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga1f9860359eea1bd7989e76c11888734c">XHdcp1x_PortSetCallback()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga46da74febe033d53ef2420d318fd63b9">XHdcp1x_PortWrite()</a>, <a class="el" href="group__hdcp1x__v4__0.html#ga2d64ba19dac4365d7a379994dd3bbf9e">XVPHY_FLAG_IS_REPEATER</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga21578c4367ba5e7c3648671ae8e5e033">XVPHY_TMO_5MS</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga3df3136bd898dd003b24846d5478f251"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_hdcp1x___config.html">XHdcp1x_Config</a> XHdcp1x_ConfigTable[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__sinit_8c.html">xhdcp1x_sinit.c</a>&gt;</code></p>

<p>Instance of Lookup table of HDCP instance(s) in the design. </p>

</div>
</div>
<a class="anchor" id="ga2c89c757bb1b6bb6c904b67afad4f624"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hdcp1x__v4__0.html#gaba9f04ac9a482bd9b3696df05868a598">XHdcp1x_LogMsg</a> XHdcp1xDebugLogMsg</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__debug_8h.html">xhdcp1x_debug.h</a>&gt;</code></p>

<p>Instance of function interface used for debug log message statement. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga0d8820c98c821780e9cbede688cc2957">XHdcp1x_SetDebugLogMsg()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2c89c757bb1b6bb6c904b67afad4f624"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hdcp1x__v4__0.html#gaba9f04ac9a482bd9b3696df05868a598">XHdcp1x_LogMsg</a> XHdcp1xDebugLogMsg = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>Instance of function interface used for debug log message statement. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#ga0d8820c98c821780e9cbede688cc2957">XHdcp1x_SetDebugLogMsg()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9edfb21b66722d61af03129b4dcbb734"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hdcp1x__v4__0.html#gaa14ea51a98757da9f24e489130804846">XHdcp1x_Printf</a> XHdcp1xDebugPrintf</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__debug_8h.html">xhdcp1x_debug.h</a>&gt;</code></p>

<p>Instance of function interface used for debug print statement. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gac2d6cb2bf146bfd87fc255200b09cd79">XHdcp1x_SetDebugPrintf()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9edfb21b66722d61af03129b4dcbb734"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hdcp1x__v4__0.html#gaa14ea51a98757da9f24e489130804846">XHdcp1x_Printf</a> XHdcp1xDebugPrintf = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>Instance of function interface used for debug print statement. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gac2d6cb2bf146bfd87fc255200b09cd79">XHdcp1x_SetDebugPrintf()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8669f2b83df6c835492036a201fbae27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hdcp1x__v4__0.html#ga268b0b51f0fc7b58d8c1e21829b52800">XHdcp1x_KsvRevokeCheck</a> XHdcp1xKsvRevokeCheck</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x__platform_8c.html">xhdcp1x_platform.c</a>&gt;</code></p>

<p>Instance of function interface used for checking a specific KSV against the platforms revocation list. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gaceb8746cc60b1628b4df76d155f0b6a5">XHdcp1x_PlatformIsKsvRevoked()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga4dc3ae5f39d71120d46f7dacf1f61b4e">XHdcp1x_SetKsvRevokeCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8669f2b83df6c835492036a201fbae27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hdcp1x__v4__0.html#ga268b0b51f0fc7b58d8c1e21829b52800">XHdcp1x_KsvRevokeCheck</a> XHdcp1xKsvRevokeCheck = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xhdcp1x_8c.html">xhdcp1x.c</a>&gt;</code></p>

<p>Instance of function interface used for checking a specific KSV against the platforms revocation list. </p>

<p>Referenced by <a class="el" href="group__hdcp1x__v4__0.html#gaceb8746cc60b1628b4df76d155f0b6a5">XHdcp1x_PlatformIsKsvRevoked()</a>, and <a class="el" href="group__hdcp1x__v4__0.html#ga4dc3ae5f39d71120d46f7dacf1f61b4e">XHdcp1x_SetKsvRevokeCheck()</a>.</p>

</div>
</div>
</div><!-- contents -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
