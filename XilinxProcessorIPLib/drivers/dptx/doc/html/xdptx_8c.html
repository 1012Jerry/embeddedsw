<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   xdptx.c File Reference
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>xdptx.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Contains a minimal wset of functions for the <a class="el" href="struct_x_dptx.html">XDptx</a> driver that allow access to all the DisplayPort transmitter's functionality. See xdptx.h for a detailed description of the driver.<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who  Date     Changes
 ----- ---- -------- -----------------------------------------------
 1.00a als  05/17/14 Initial release.
 </pre> 
<p>
<code>#include &quot;xdptx.h&quot;</code><br>
<code>#include &quot;xstatus.h&quot;</code><br>
<code>#include &quot;xenv.h&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dptx___aux_transaction.html">XDptx_AuxTransaction</a></td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#cd850705884d914c6c8468f61336f06d">XDptx_TrainingState</a> </td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#b2fbc41e2f0ac4471e4edbf71d877af3">XDptx_InitializeTx</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#9de0242347480cc38571113e5edd73ba">XDptx_CfgInitialize</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, <a class="el" href="struct_x_dptx___config.html">XDptx_Config</a> *ConfigPtr, u32 EffectiveAddr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#99e54ae4561026afaf223d798463dd44">XDptx_GetSinkCapabilities</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#db337d62a4acae90149ed159d3526af9">XDptx_GetEdid</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#1b0ea5fdead5a6955b72b4775ec1d0a3">XDptx_CfgMainLinkMax</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#32b552e953f9c486a6a5e04228dcf6b6">XDptx_EstablishLink</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#e85ec3a02cdf8f8ffd611e026bf9ff01">XDptx_CheckLinkStatus</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u8 LaneCount)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#6f302303735c870085d65253bcc9acdb">XDptx_EnableTrainAdaptive</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u8 Enable)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#55147fabd5935ff1198d732b54d1f310">XDptx_SetHasRedriverInPath</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u8 Set)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#591d601b5e6913df09ad73ea92881e31">XDptx_AuxRead</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u32 Address, u32 NumBytes, void *Data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#690a6ee9d1b4df0624967cb00892347b">XDptx_AuxWrite</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u32 Address, u32 NumBytes, void *Data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#d41a1582dbf74240ce665fee5eb8c018">XDptx_IicWrite</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u8 IicAddress, u8 RegStartAddress, u8 NumBytes, u8 *DataBuffer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#e3897207d5f04cb56a680092d13914ad">XDptx_IicRead</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u8 IicAddress, u8 RegStartAddress, u8 NumBytes, u8 *DataBuffer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#2a9f86dab2f5de738680e7b4320469b2">XDptx_SetDownspread</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u8 Enable)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#1d545645af32331e179e42e979bc3de3">XDptx_SetEnhancedFrameMode</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u8 Enable)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#a273dec21586ac33395010f87401c2d0">XDptx_SetLaneCount</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u8 LaneCount)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#fc742d9a00ff909e56766f5a692159f2">XDptx_SetLinkRate</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u8 LinkRate)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#3e9dee7b0b7711677c8c39fd14d585c8">XDptx_SetScrambler</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u8 Enable)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#0f43683ba44e5e1544042be2bcfc45de">XDptx_EnableMainLink</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#0086628f0fcfab2389efb4100415df96">XDptx_DisableMainLink</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#a71e17a951f445b9c7bcfcc3104cdf4c">XDptx_ResetPhy</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u32 Reset)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#0cfe4355d8e2fa3e46be78c1800bb9d5">XDptx_SetUserTimerHandler</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, XDptx_TimerHandler CallbackFunc, void *CallbackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8c.html#f60126291b4c1d2ac2d054707c804dce">XDptx_WaitUs</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u32 MicroSeconds)</td></tr>

</table>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="cd850705884d914c6c8468f61336f06d"></a><!-- doxytag: member="xdptx.c::XDptx_TrainingState" ref="cd850705884d914c6c8468f61336f06d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="xdptx_8c.html#cd850705884d914c6c8468f61336f06d">XDptx_TrainingState</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This typedef enumerates the list of training states used in the state machine during the link training process. 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="591d601b5e6913df09ad73ea92881e31"></a><!-- doxytag: member="xdptx.c::XDptx_AuxRead" ref="591d601b5e6913df09ad73ea92881e31" args="(XDptx *InstancePtr, u32 Address, u32 NumBytes, void *Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_AuxRead           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>NumBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function issues a read request over the AUX channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Address</em>&nbsp;</td><td>is the starting address to read from the receiver. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBytes</em>&nbsp;</td><td>is the number of bytes to read from the receiver. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is a pointer to the data buffer that will be filled with read data.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the AUX read request was successfully acknowledged.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_NO_DATA if no data was provided.</li><li>XST_ERROR_COUNT_MAX if the AUX request timed out.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="690a6ee9d1b4df0624967cb00892347b"></a><!-- doxytag: member="xdptx.c::XDptx_AuxWrite" ref="690a6ee9d1b4df0624967cb00892347b" args="(XDptx *InstancePtr, u32 Address, u32 NumBytes, void *Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_AuxWrite           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>NumBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function issues a write request over the AUX channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Address</em>&nbsp;</td><td>is the starting address to write to the receiver. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBytes</em>&nbsp;</td><td>is the number of bytes to write to the receiver. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is a pointer to the data buffer that contains the data to be written to the receiver.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if AUX write request was successfully acknowledged.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_NO_DATA if no data was provided.</li><li>XST_ERROR_COUNT_MAX if the AUX request timed out.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="9de0242347480cc38571113e5edd73ba"></a><!-- doxytag: member="xdptx.c::XDptx_CfgInitialize" ref="9de0242347480cc38571113e5edd73ba" args="(XDptx *InstancePtr, XDptx_Config *ConfigPtr, u32 EffectiveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDptx_CfgInitialize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_dptx___config.html">XDptx_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function retrieves the configuration for this DisplayPort TX instance and fills in the InstancePtr-&gt;TxConfig structure.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ConfigPtr</em>&nbsp;</td><td>is a pointer to the configuration structure that will be used to copy the settings from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the device base address in the virtual memory space. If the address translation is not used, then the physical address is passed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>Unexpected errors may occur if the address mapping is changed after this function is invoked. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1b0ea5fdead5a6955b72b4775ec1d0a3"></a><!-- doxytag: member="xdptx.c::XDptx_CfgMainLinkMax" ref="1b0ea5fdead5a6955b72b4775ec1d0a3" args="(XDptx *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_CfgMainLinkMax           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function determines the common capabilities between the DisplayPort TX core and the receiver.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if main link settings were successfully set.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_INVALID_PARAM if the specified link configuration specifies a link rate or lane count that isn't valid.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="e85ec3a02cdf8f8ffd611e026bf9ff01"></a><!-- doxytag: member="xdptx.c::XDptx_CheckLinkStatus" ref="e85ec3a02cdf8f8ffd611e026bf9ff01" args="(XDptx *InstancePtr, u8 LaneCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_CheckLinkStatus           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LaneCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function checks if the reciever's DPCD indicates the reciever has achieved and maintained clock recovery, channel equalization, symbol lock, and interlane alignment for all lanes currently in use.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LaneCount</em>&nbsp;</td><td>is the number of lanes to check.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the receiver has maintained clock recovery, channel equalization, symbol lock, and interlane alignment.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_INVALID_PARAM if the number of lanes to check does not match 1, 2, or 4 lanes.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="0086628f0fcfab2389efb4100415df96"></a><!-- doxytag: member="xdptx.c::XDptx_DisableMainLink" ref="0086628f0fcfab2389efb4100415df96" args="(XDptx *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDptx_DisableMainLink           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function disables the main link.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0f43683ba44e5e1544042be2bcfc45de"></a><!-- doxytag: member="xdptx.c::XDptx_EnableMainLink" ref="0f43683ba44e5e1544042be2bcfc45de" args="(XDptx *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDptx_EnableMainLink           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function enables the main link.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6f302303735c870085d65253bcc9acdb"></a><!-- doxytag: member="xdptx.c::XDptx_EnableTrainAdaptive" ref="6f302303735c870085d65253bcc9acdb" args="(XDptx *InstancePtr, u8 Enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDptx_EnableTrainAdaptive           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Enable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function enables or disables downshifting during the training process.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Enable</em>&nbsp;</td><td>controls the downshift feature in the training process. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="32b552e953f9c486a6a5e04228dcf6b6"></a><!-- doxytag: member="xdptx.c::XDptx_EstablishLink" ref="32b552e953f9c486a6a5e04228dcf6b6" args="(XDptx *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_EstablishLink           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function determines the common capabilities between the DisplayPort TX core and the receiver.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS was either already trained, or has been trained successfully.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_INVALID_PARAM if the current link rate or lane count isn't valid.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="db337d62a4acae90149ed159d3526af9"></a><!-- doxytag: member="xdptx.c::XDptx_GetEdid" ref="db337d62a4acae90149ed159d3526af9" args="(XDptx *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_GetEdid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function retrieves the receiver's EDID.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="99e54ae4561026afaf223d798463dd44"></a><!-- doxytag: member="xdptx.c::XDptx_GetSinkCapabilities" ref="99e54ae4561026afaf223d798463dd44" args="(XDptx *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_GetSinkCapabilities           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function retrieves sink device capabilities from the receiver's DPCD.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the DPCD was read successfully.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="e3897207d5f04cb56a680092d13914ad"></a><!-- doxytag: member="xdptx.c::XDptx_IicRead" ref="e3897207d5f04cb56a680092d13914ad" args="(XDptx *InstancePtr, u8 IicAddress, u8 RegStartAddress, u8 NumBytes, u8 *DataBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_IicRead           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>IicAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>RegStartAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>NumBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>DataBuffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function performs an I2C read over the AUX channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IicAddress</em>&nbsp;</td><td>is the address on the I2C bus of the target device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegStartAddress</em>&nbsp;</td><td>is the subaddress of the targeted I2C device that the read will start from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBytes</em>&nbsp;</td><td>is the number of bytes to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DataBuffer</em>&nbsp;</td><td>is a pointer to a buffer that will be filled with the I2C read data.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the I2C read has successfully completed with no errors.</li><li>XST_ERROR_COUNT_MAX if the AUX request timed out.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="d41a1582dbf74240ce665fee5eb8c018"></a><!-- doxytag: member="xdptx.c::XDptx_IicWrite" ref="d41a1582dbf74240ce665fee5eb8c018" args="(XDptx *InstancePtr, u8 IicAddress, u8 RegStartAddress, u8 NumBytes, u8 *DataBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_IicWrite           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>IicAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>RegStartAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>NumBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>DataBuffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function performs an I2C write over the AUX channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IicAddress</em>&nbsp;</td><td>is the address on the I2C bus of the target device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegStartAddress</em>&nbsp;</td><td>is the sub-address of the targeted I2C device that the write will start at. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBytes</em>&nbsp;</td><td>is the number of bytes to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DataBuffer</em>&nbsp;</td><td>is a pointer to a buffer which will be used as the data source for the write.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the I2C write has successfully completed with no errors.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_ERROR_COUNT_MAX if the AUX request timed out.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="b2fbc41e2f0ac4471e4edbf71d877af3"></a><!-- doxytag: member="xdptx.c::XDptx_InitializeTx" ref="b2fbc41e2f0ac4471e4edbf71d877af3" args="(XDptx *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_InitializeTx           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function prepares the DisplayPort TX core for use.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the DisplayPort TX core was successfully initialized.</li><li>XST_INVALID_PARAM if the supplied link rate does not correspond to either 1.62, 2.70, or 5.40 Gbps.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="a71e17a951f445b9c7bcfcc3104cdf4c"></a><!-- doxytag: member="xdptx.c::XDptx_ResetPhy" ref="a71e17a951f445b9c7bcfcc3104cdf4c" args="(XDptx *InstancePtr, u32 Reset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDptx_ResetPhy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Reset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function does a PHY reset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. &amp;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Reset</em>&nbsp;</td><td>is the type of reset to assert. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2a9f86dab2f5de738680e7b4320469b2"></a><!-- doxytag: member="xdptx.c::XDptx_SetDownspread" ref="2a9f86dab2f5de738680e7b4320469b2" args="(XDptx *InstancePtr, u8 Enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_SetDownspread           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Enable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function enables or disables 0.5% spreading of the clock for both the DisplayPort and the sink device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Enable</em>&nbsp;</td><td>will enable or disable down-spread control.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if setting the downspread control enable was successful.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="1d545645af32331e179e42e979bc3de3"></a><!-- doxytag: member="xdptx.c::XDptx_SetEnhancedFrameMode" ref="1d545645af32331e179e42e979bc3de3" args="(XDptx *InstancePtr, u8 Enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_SetEnhancedFrameMode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Enable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function enables or disables the enhanced framing symbol sequence for both the DisplayPort TX core and the sink device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Enable</em>&nbsp;</td><td>will enable or disable enhanced frame mode.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if setting the enhanced frame mode enable was successful.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="55147fabd5935ff1198d732b54d1f310"></a><!-- doxytag: member="xdptx.c::XDptx_SetHasRedriverInPath" ref="55147fabd5935ff1198d732b54d1f310" args="(XDptx *InstancePtr, u8 Set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDptx_SetHasRedriverInPath           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Set</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets a software switch that signifies whether or not a redriver exists on the DisplayPort output path. XDptx_SetVswingPreemp uses this switch to determine which set of voltage swing and pre-emphasis values to use in the TX core.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Set</em>&nbsp;</td><td>establishes that a redriver exists in the DisplayPort output path. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a273dec21586ac33395010f87401c2d0"></a><!-- doxytag: member="xdptx.c::XDptx_SetLaneCount" ref="a273dec21586ac33395010f87401c2d0" args="(XDptx *InstancePtr, u8 LaneCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_SetLaneCount           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LaneCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the number of lanes to be used by the main link for both the DisplayPort TX core and the sink device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LaneCount</em>&nbsp;</td><td>is the number of lanes to be used over the main link.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if setting the new lane count was successful.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_INVALID_PARAM if the supplied lane count is not either 1, 2, or 4 lanes.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="fc742d9a00ff909e56766f5a692159f2"></a><!-- doxytag: member="xdptx.c::XDptx_SetLinkRate" ref="fc742d9a00ff909e56766f5a692159f2" args="(XDptx *InstancePtr, u8 LinkRate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_SetLinkRate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LinkRate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the data rate to be used by the main link for both the DisplayPort TX core and the sink device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LinkRate</em>&nbsp;</td><td>is the link rate to be used over the main link based on one of the following selects:<ul>
<li>XDPTX_LINK_BW_SET_162GBPS = 0x06 (for a 1.62 Gbps data rate)</li><li>XDPTX_LINK_BW_SET_270GBPS = 0x0A (for a 2.70 Gbps data rate)</li><li>XDPTX_LINK_BW_SET_540GBPS = 0x14 (for a 5.40 Gbps data rate)</li></ul>
</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if setting the new link rate was successful.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_INVALID_PARAM if the supplied link rate does not correspond to either 1.62, 2.70, or 5.40 Gbps.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="3e9dee7b0b7711677c8c39fd14d585c8"></a><!-- doxytag: member="xdptx.c::XDptx_SetScrambler" ref="3e9dee7b0b7711677c8c39fd14d585c8" args="(XDptx *InstancePtr, u8 Enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_SetScrambler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Enable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function enables or disables scrambling of symbols for both the DisplayPort and the sink device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Enable</em>&nbsp;</td><td>will enable or disable scrambling.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if setting the scrambling enable was successful.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="0cfe4355d8e2fa3e46be78c1800bb9d5"></a><!-- doxytag: member="xdptx.c::XDptx_SetUserTimerHandler" ref="0cfe4355d8e2fa3e46be78c1800bb9d5" args="(XDptx *InstancePtr, XDptx_TimerHandler CallbackFunc, void *CallbackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDptx_SetUserTimerHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XDptx_TimerHandler&nbsp;</td>
          <td class="paramname"> <em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallbackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function installs a custom delay/sleep function to be used by the XDdptx driver.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackFunc</em>&nbsp;</td><td>is the address to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackRef</em>&nbsp;</td><td>is the user data item (microseconds to delay) that will be passed to the custom sleep/delay function when it is invoked. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f60126291b4c1d2ac2d054707c804dce"></a><!-- doxytag: member="xdptx.c::XDptx_WaitUs" ref="f60126291b4c1d2ac2d054707c804dce" args="(XDptx *InstancePtr, u32 MicroSeconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDptx_WaitUs           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>MicroSeconds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is the delay/sleep function for the <a class="el" href="struct_x_dptx.html">XDptx</a> driver. For the Zynq family, there exists native sleep functionality. For MicroBlaze however, there does not exist such functionality. In the MicroBlaze case, the default method for delaying is to use a predetermined amount of loop iterations. This method is prone to inaccuracy and dependent on system configuration; for greater accuracy, the user may supply their own delay/sleep handler, pointed to by InstancePtr-&gt;UserTimerWaitUs, which may have better accuracy if a hardware timer is used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MicroSeconds</em>&nbsp;</td><td>is the number of microseconds to delay/sleep for. </td></tr>
  </table>
</dl>

</div>
</div><p>
Copyright @ 1995-2014 Xilinx, Inc. All rights reserved. 
