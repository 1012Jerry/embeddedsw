<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   xdptx.h File Reference
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>xdptx.h File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
The Xilinx DisplayPort transmitter (TX) driver.<p>
The driver currently supports single-stream transport (SST) functionality.<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who  Date     Changes
 ----- ---- -------- -----------------------------------------------
 1.00a als  05/17/14 Initial release.
 </pre> 
<p>
<code>#include &quot;<a class="el" href="xdptx__hw_8h.html">xdptx_hw.h</a>&quot;</code><br>
<code>#include &quot;xil_assert.h&quot;</code><br>
<code>#include &quot;xil_types.h&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dptx___dmt_mode.html">XDptx_DmtMode</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dptx___config.html">XDptx_Config</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dptx___sink_config.html">XDptx_SinkConfig</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dptx___link_config.html">XDptx_LinkConfig</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dptx___main_stream_attributes.html">XDptx_MainStreamAttributes</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dptx.html">XDptx</a></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#d754af91a71cc550407212fa54831a92">XDptx_IsConnected</a>(InstancePtr)</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#c09d771f709e37e756d8de2ba627701f">XDptx_TimerHandler</a> (void *InstancePtr, u32 MicroSeconds)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#55e031231c2489c71c5b0187f8b2941e">XDptx_HpdEventHandler</a> (void *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#26acfa8f4b98b86385c7095bd3668313">XDptx_HpdPulseHandler</a> (void *InstancePtr)</td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#af8a64fd1433b74b07e2b2081a9c2fa6">XDptx_VideoMode</a> </td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#b2fbc41e2f0ac4471e4edbf71d877af3">XDptx_InitializeTx</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#9de0242347480cc38571113e5edd73ba">XDptx_CfgInitialize</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, <a class="el" href="struct_x_dptx___config.html">XDptx_Config</a> *ConfigPtr, u32 EffectiveAddr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#99e54ae4561026afaf223d798463dd44">XDptx_GetSinkCapabilities</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#db337d62a4acae90149ed159d3526af9">XDptx_GetEdid</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#1b0ea5fdead5a6955b72b4775ec1d0a3">XDptx_CfgMainLinkMax</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#32b552e953f9c486a6a5e04228dcf6b6">XDptx_EstablishLink</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#e85ec3a02cdf8f8ffd611e026bf9ff01">XDptx_CheckLinkStatus</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u8 LaneCount)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#6f302303735c870085d65253bcc9acdb">XDptx_EnableTrainAdaptive</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u8 Enable)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#55147fabd5935ff1198d732b54d1f310">XDptx_SetHasRedriverInPath</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u8 Set)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#591d601b5e6913df09ad73ea92881e31">XDptx_AuxRead</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u32 Address, u32 NumBytes, void *Data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#690a6ee9d1b4df0624967cb00892347b">XDptx_AuxWrite</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u32 Address, u32 NumBytes, void *Data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#d41a1582dbf74240ce665fee5eb8c018">XDptx_IicWrite</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u8 IicAddress, u8 RegStartAddress, u8 NumBytes, u8 *DataBuffer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#e3897207d5f04cb56a680092d13914ad">XDptx_IicRead</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u8 IicAddress, u8 RegStartAddress, u8 NumBytes, u8 *DataBuffer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#2a9f86dab2f5de738680e7b4320469b2">XDptx_SetDownspread</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u8 Enable)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#1d545645af32331e179e42e979bc3de3">XDptx_SetEnhancedFrameMode</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u8 Enable)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#a273dec21586ac33395010f87401c2d0">XDptx_SetLaneCount</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u8 LaneCount)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#fc742d9a00ff909e56766f5a692159f2">XDptx_SetLinkRate</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u8 LinkRate)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#3e9dee7b0b7711677c8c39fd14d585c8">XDptx_SetScrambler</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u8 Enable)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#0f43683ba44e5e1544042be2bcfc45de">XDptx_EnableMainLink</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#0086628f0fcfab2389efb4100415df96">XDptx_DisableMainLink</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#a71e17a951f445b9c7bcfcc3104cdf4c">XDptx_ResetPhy</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u32 Reset)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#f60126291b4c1d2ac2d054707c804dce">XDptx_WaitUs</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u32 MicroSeconds)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#0cfe4355d8e2fa3e46be78c1800bb9d5">XDptx_SetUserTimerHandler</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, <a class="el" href="xdptx_8h.html#c09d771f709e37e756d8de2ba627701f">XDptx_TimerHandler</a> CallbackFunc, void *CallbackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#d6d0ab65e5e57372fb02d3eb3d0c08b4">XDptx_CfgMsaRecalculate</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#d63ef9bd6bfa5653718d5abb26615495">XDptx_CfgMsaUseStandardVideoMode</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, <a class="el" href="xdptx_8h.html#af8a64fd1433b74b07e2b2081a9c2fa6">XDptx_VideoMode</a> VideoMode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#15e3eafa3e673961309e8eb784d6409b">XDptx_CfgMsaUseEdidPreferredTiming</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#abbab1fd51ea73f8f021cd3fa7f3ff54">XDptx_CfgMsaUseCustom</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, <a class="el" href="struct_x_dptx___main_stream_attributes.html">XDptx_MainStreamAttributes</a> *MsaConfigCustom, u8 Recalculate)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#a0af5e5b4a2789aa26efb33502f04423">XDptx_CfgMsaSetBpc</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, u8 BitsPerColor)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#7cd047ab5d5dc46af427086469e7a0db">XDptx_SetVideoMode</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#0fc77fba78c3de3cdd141273b9348d45">XDptx_SetHpdEventHandler</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, <a class="el" href="xdptx_8h.html#55e031231c2489c71c5b0187f8b2941e">XDptx_HpdEventHandler</a> CallbackFunc, void *CallbackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#a1dd03865a96f1323a8e3445dd4b15a6">XDptx_SetHpdPulseHandler</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr, <a class="el" href="xdptx_8h.html#26acfa8f4b98b86385c7095bd3668313">XDptx_HpdPulseHandler</a> CallbackFunc, void *CallbackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#42ad278e82e98ad5440ced0791eb1232">XDptx_HpdInterruptHandler</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#f6cbfafba59214dcaad29991a3e265a4">XDptx_SelfTest</a> (<a class="el" href="struct_x_dptx.html">XDptx</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_x_dptx___config.html">XDptx_Config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#32ba0cb6907ed3d2ecfdb31c699db3b4">XDptx_LookupConfig</a> (u16 DeviceId)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_x_dptx___dmt_mode.html">XDptx_DmtMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdptx_8h.html#35408b37824862d172606842e26e66e0">XDptx_DmtModes</a> []</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="d754af91a71cc550407212fa54831a92"></a><!-- doxytag: member="xdptx.h::XDptx_IsConnected" ref="d754af91a71cc550407212fa54831a92" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDptx_IsConnected          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">(<a class="code" href="xdptx__hw_8h.html#b9ae114efe97122a7a212baf3a27d5fe">XDptx_ReadReg</a>(InstancePtr-&gt;TxConfig.BaseAddr, \
        <a class="code" href="xdptx__hw_8h.html#0f779ac12934252a5548f520e776b1e8">XDPTX_INTERRUPT_SIG_STATE</a>) &amp; 0x1)
</pre></div>This macro checks if there is a connected sink.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if there is a connection.</li><li>FALSE if there is no connection.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xdptx_8h.html#d754af91a71cc550407212fa54831a92">XDptx_IsConnected(XDptx *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="55e031231c2489c71c5b0187f8b2941e"></a><!-- doxytag: member="xdptx.h::XDptx_HpdEventHandler" ref="55e031231c2489c71c5b0187f8b2941e" args="(void *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*) <a class="el" href="xdptx_8h.html#55e031231c2489c71c5b0187f8b2941e">XDptx_HpdEventHandler</a>(void *InstancePtr)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callback type which represents the handler for a hot-plug-detect event interrupt.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="26acfa8f4b98b86385c7095bd3668313"></a><!-- doxytag: member="xdptx.h::XDptx_HpdPulseHandler" ref="26acfa8f4b98b86385c7095bd3668313" args="(void *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*) <a class="el" href="xdptx_8h.html#26acfa8f4b98b86385c7095bd3668313">XDptx_HpdPulseHandler</a>(void *InstancePtr)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callback type which represents the handler for a hot-plug-detect pulse interrupt.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c09d771f709e37e756d8de2ba627701f"></a><!-- doxytag: member="xdptx.h::XDptx_TimerHandler" ref="c09d771f709e37e756d8de2ba627701f" args="(void *InstancePtr, u32 MicroSeconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*) <a class="el" href="xdptx_8h.html#c09d771f709e37e756d8de2ba627701f">XDptx_TimerHandler</a>(void *InstancePtr, u32 MicroSeconds)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callback type which represents a custom timer wait handler. This is only used for Microblaze since it doesn't have a native sleep function. To avoid dependency on a hardware timer, the default wait functionality is implemented using loop iterations; this isn't too accurate. If a custom timer handler is used, the user may implement their own wait implementation using a hardware timer (see example/) for better accuracy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MicroSeconds</em>&nbsp;</td><td>is the number of microseconds to be passed to the timer function. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="af8a64fd1433b74b07e2b2081a9c2fa6"></a><!-- doxytag: member="xdptx.h::XDptx_VideoMode" ref="af8a64fd1433b74b07e2b2081a9c2fa6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="xdptx_8h.html#af8a64fd1433b74b07e2b2081a9c2fa6">XDptx_VideoMode</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This typedef enumerates the list of available standard display monitor timings as specified in the mode_table.c file. The naming format is:<p>
XDPTX_VM_&lt;RESOLUTION&gt;_&lt;REFRESH RATE (HZ)&gt;_&lt;P|RB&gt;<p>
Where RB stands for reduced blanking. 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="591d601b5e6913df09ad73ea92881e31"></a><!-- doxytag: member="xdptx.h::XDptx_AuxRead" ref="591d601b5e6913df09ad73ea92881e31" args="(XDptx *InstancePtr, u32 Address, u32 NumBytes, void *Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_AuxRead           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>NumBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function issues a read request over the AUX channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Address</em>&nbsp;</td><td>is the starting address to read from the receiver. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBytes</em>&nbsp;</td><td>is the number of bytes to read from the receiver. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is a pointer to the data buffer that will be filled with read data.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the AUX read request was successfully acknowledged.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_NO_DATA if no data was provided.</li><li>XST_ERROR_COUNT_MAX if the AUX request timed out.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="690a6ee9d1b4df0624967cb00892347b"></a><!-- doxytag: member="xdptx.h::XDptx_AuxWrite" ref="690a6ee9d1b4df0624967cb00892347b" args="(XDptx *InstancePtr, u32 Address, u32 NumBytes, void *Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_AuxWrite           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>NumBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function issues a write request over the AUX channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Address</em>&nbsp;</td><td>is the starting address to write to the receiver. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBytes</em>&nbsp;</td><td>is the number of bytes to write to the receiver. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is a pointer to the data buffer that contains the data to be written to the receiver.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if AUX write request was successfully acknowledged.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_NO_DATA if no data was provided.</li><li>XST_ERROR_COUNT_MAX if the AUX request timed out.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="9de0242347480cc38571113e5edd73ba"></a><!-- doxytag: member="xdptx.h::XDptx_CfgInitialize" ref="9de0242347480cc38571113e5edd73ba" args="(XDptx *InstancePtr, XDptx_Config *ConfigPtr, u32 EffectiveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDptx_CfgInitialize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_dptx___config.html">XDptx_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function retrieves the configuration for this DisplayPort TX instance and fills in the InstancePtr-&gt;TxConfig structure.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ConfigPtr</em>&nbsp;</td><td>is a pointer to the configuration structure that will be used to copy the settings from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the device base address in the virtual memory space. If the address translation is not used, then the physical address is passed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>Unexpected errors may occur if the address mapping is changed after this function is invoked. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1b0ea5fdead5a6955b72b4775ec1d0a3"></a><!-- doxytag: member="xdptx.h::XDptx_CfgMainLinkMax" ref="1b0ea5fdead5a6955b72b4775ec1d0a3" args="(XDptx *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_CfgMainLinkMax           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function determines the common capabilities between the DisplayPort TX core and the receiver.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if main link settings were successfully set.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_INVALID_PARAM if the specified link configuration specifies a link rate or lane count that isn't valid.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="d6d0ab65e5e57372fb02d3eb3d0c08b4"></a><!-- doxytag: member="xdptx.h::XDptx_CfgMsaRecalculate" ref="d6d0ab65e5e57372fb02d3eb3d0c08b4" args="(XDptx *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDptx_CfgMsaRecalculate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function calculates the following main stream attributes:<ul>
<li>Transfer unit size</li><li>User pixel width</li><li>NVid</li><li>Horizontal start</li><li>Vertical start</li><li>Horizontal total clock</li><li>Vertical total clock</li><li>Misc0</li><li>Misc1</li><li>Data per lane</li><li>Average number of bytes per transfer unit</li><li>Number of initial wait cycles These values are derived from:</li><li>Bits per color</li><li>MVid</li><li>Horizontal sync polarity</li><li>Vertical sync polarity</li><li>Horizontal sync pulse width</li><li>Vertical sync pulse width</li><li>Horizontal resolution</li><li>Vertical resolution</li><li>Vertical back porch</li><li>Vertical front porch</li><li>Horizontal back porch</li><li>Horizontal front porch</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The MsaConfig structure is modified with the new, calculated values. The main stream attributes that were used to derive the calculated values are untouched in the MsaConfig structure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a0af5e5b4a2789aa26efb33502f04423"></a><!-- doxytag: member="xdptx.h::XDptx_CfgMsaSetBpc" ref="a0af5e5b4a2789aa26efb33502f04423" args="(XDptx *InstancePtr, u8 BitsPerColor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_CfgMsaSetBpc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>BitsPerColor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the bits per color value of the video stream.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BitsPerColor</em>&nbsp;</td><td>is the new number of bits per color to use.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The InstancePtr-&gt;MsaConfig structure is modified to reflect the new main stream attributes associated with a new bits per color value.</dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_INVALID_PARAM if the supplied bits per color value is not either 6, 8, 10, 12, or 16.</li><li>XST_SUCCESS otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="abbab1fd51ea73f8f021cd3fa7f3ff54"></a><!-- doxytag: member="xdptx.h::XDptx_CfgMsaUseCustom" ref="abbab1fd51ea73f8f021cd3fa7f3ff54" args="(XDptx *InstancePtr, XDptx_MainStreamAttributes *MsaConfigCustom, u8 Recalculate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDptx_CfgMsaUseCustom           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_dptx___main_stream_attributes.html">XDptx_MainStreamAttributes</a> *&nbsp;</td>
          <td class="paramname"> <em>MsaConfigCustom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Recalculate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function takes a the main stream attributes from MsaConfigCustom and copies them into InstancePtr-&gt;MsaConfig. If desired, given a base set of attributes, the rest of the attributes may be derived. The minimal required main stream attributes that must be contained in the MsaConfigCustom structure are:<ul>
<li>MVid</li><li>Horizontal sync polarity</li><li>Vertical sync polarity</li><li>Horizontal sync pulse width</li><li>Vertical sync pulse width</li><li>Horizontal resolution</li><li>Vertical resolution</li><li>Vertical back porch</li><li>Vertical front porch</li><li>Horizontal back porch</li><li>Horizontal front porch</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MsaConfigCustom</em>&nbsp;</td><td>is the structure that will be used to copy the main stream attributes from (into InstancePtr-&gt;MsaConfig). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Recalculate</em>&nbsp;</td><td>is a boolean enable that determines whether or not the main stream attributes should be recalculated.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The InstancePtr-&gt; MsaConfig structure is modified with the new values. </dd></dl>

</div>
</div><p>
<a class="anchor" name="15e3eafa3e673961309e8eb784d6409b"></a><!-- doxytag: member="xdptx.h::XDptx_CfgMsaUseEdidPreferredTiming" ref="15e3eafa3e673961309e8eb784d6409b" args="(XDptx *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDptx_CfgMsaUseEdidPreferredTiming           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the main stream attribute values in the configuration structure to match the preferred timing of the sink monitor. This preferred timing information is stored in the sink's extended display identification data (EDID).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The InstancePtr-&gt;MsaConfig structure is modified to reflect the main stream attribute values associated to the preferred timing of the sink monitor. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d63ef9bd6bfa5653718d5abb26615495"></a><!-- doxytag: member="xdptx.h::XDptx_CfgMsaUseStandardVideoMode" ref="d63ef9bd6bfa5653718d5abb26615495" args="(XDptx *InstancePtr, XDptx_VideoMode VideoMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_CfgMsaUseStandardVideoMode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xdptx_8h.html#af8a64fd1433b74b07e2b2081a9c2fa6">XDptx_VideoMode</a>&nbsp;</td>
          <td class="paramname"> <em>VideoMode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the main stream attribute values in the configuration structure to match one of the standard display mode timings from the XDptx_DmtModes[] table. THe XDptx_VideoMode enumeration in <a class="el" href="xdptx_8h.html">xdptx.h</a> lists the available video modes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VideoMode</em>&nbsp;</td><td>is one of the enumerated standard video modes that is used to determine the main stream attributes to be used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_INVALID_PARAM if the supplied video mode isn't in the DMT table.</li><li>XST_SUCCESS otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The InstancePtr-&gt;MsaConfig structure is modified to reflect the main stream attribute values associated to the specified video mode. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e85ec3a02cdf8f8ffd611e026bf9ff01"></a><!-- doxytag: member="xdptx.h::XDptx_CheckLinkStatus" ref="e85ec3a02cdf8f8ffd611e026bf9ff01" args="(XDptx *InstancePtr, u8 LaneCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_CheckLinkStatus           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LaneCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function checks if the reciever's DPCD indicates the reciever has achieved and maintained clock recovery, channel equalization, symbol lock, and interlane alignment for all lanes currently in use.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LaneCount</em>&nbsp;</td><td>is the number of lanes to check.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the receiver has maintained clock recovery, channel equalization, symbol lock, and interlane alignment.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_INVALID_PARAM if the number of lanes to check does not match 1, 2, or 4 lanes.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="0086628f0fcfab2389efb4100415df96"></a><!-- doxytag: member="xdptx.h::XDptx_DisableMainLink" ref="0086628f0fcfab2389efb4100415df96" args="(XDptx *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDptx_DisableMainLink           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function disables the main link.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0f43683ba44e5e1544042be2bcfc45de"></a><!-- doxytag: member="xdptx.h::XDptx_EnableMainLink" ref="0f43683ba44e5e1544042be2bcfc45de" args="(XDptx *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDptx_EnableMainLink           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function enables the main link.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6f302303735c870085d65253bcc9acdb"></a><!-- doxytag: member="xdptx.h::XDptx_EnableTrainAdaptive" ref="6f302303735c870085d65253bcc9acdb" args="(XDptx *InstancePtr, u8 Enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDptx_EnableTrainAdaptive           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Enable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function enables or disables downshifting during the training process.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Enable</em>&nbsp;</td><td>controls the downshift feature in the training process. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="32b552e953f9c486a6a5e04228dcf6b6"></a><!-- doxytag: member="xdptx.h::XDptx_EstablishLink" ref="32b552e953f9c486a6a5e04228dcf6b6" args="(XDptx *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_EstablishLink           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function determines the common capabilities between the DisplayPort TX core and the receiver.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS was either already trained, or has been trained successfully.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_INVALID_PARAM if the current link rate or lane count isn't valid.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="db337d62a4acae90149ed159d3526af9"></a><!-- doxytag: member="xdptx.h::XDptx_GetEdid" ref="db337d62a4acae90149ed159d3526af9" args="(XDptx *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_GetEdid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function retrieves the receiver's EDID.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="99e54ae4561026afaf223d798463dd44"></a><!-- doxytag: member="xdptx.h::XDptx_GetSinkCapabilities" ref="99e54ae4561026afaf223d798463dd44" args="(XDptx *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_GetSinkCapabilities           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function retrieves sink device capabilities from the receiver's DPCD.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the DPCD was read successfully.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="42ad278e82e98ad5440ced0791eb1232"></a><!-- doxytag: member="xdptx.h::XDptx_HpdInterruptHandler" ref="42ad278e82e98ad5440ced0791eb1232" args="(XDptx *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDptx_HpdInterruptHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is the interrupt handler for the <a class="el" href="struct_x_dptx.html">XDptx</a> driver.<p>
When an interrupt happens, it first detects what kind of interrupt happened, then decides which callback function to invoke.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e3897207d5f04cb56a680092d13914ad"></a><!-- doxytag: member="xdptx.h::XDptx_IicRead" ref="e3897207d5f04cb56a680092d13914ad" args="(XDptx *InstancePtr, u8 IicAddress, u8 RegStartAddress, u8 NumBytes, u8 *DataBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_IicRead           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>IicAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>RegStartAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>NumBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>DataBuffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function performs an I2C read over the AUX channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IicAddress</em>&nbsp;</td><td>is the address on the I2C bus of the target device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegStartAddress</em>&nbsp;</td><td>is the subaddress of the targeted I2C device that the read will start from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBytes</em>&nbsp;</td><td>is the number of bytes to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DataBuffer</em>&nbsp;</td><td>is a pointer to a buffer that will be filled with the I2C read data.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the I2C read has successfully completed with no errors.</li><li>XST_ERROR_COUNT_MAX if the AUX request timed out.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="d41a1582dbf74240ce665fee5eb8c018"></a><!-- doxytag: member="xdptx.h::XDptx_IicWrite" ref="d41a1582dbf74240ce665fee5eb8c018" args="(XDptx *InstancePtr, u8 IicAddress, u8 RegStartAddress, u8 NumBytes, u8 *DataBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_IicWrite           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>IicAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>RegStartAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>NumBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>DataBuffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function performs an I2C write over the AUX channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IicAddress</em>&nbsp;</td><td>is the address on the I2C bus of the target device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegStartAddress</em>&nbsp;</td><td>is the sub-address of the targeted I2C device that the write will start at. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBytes</em>&nbsp;</td><td>is the number of bytes to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DataBuffer</em>&nbsp;</td><td>is a pointer to a buffer which will be used as the data source for the write.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the I2C write has successfully completed with no errors.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_ERROR_COUNT_MAX if the AUX request timed out.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="b2fbc41e2f0ac4471e4edbf71d877af3"></a><!-- doxytag: member="xdptx.h::XDptx_InitializeTx" ref="b2fbc41e2f0ac4471e4edbf71d877af3" args="(XDptx *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_InitializeTx           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function prepares the DisplayPort TX core for use.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the DisplayPort TX core was successfully initialized.</li><li>XST_INVALID_PARAM if the supplied link rate does not correspond to either 1.62, 2.70, or 5.40 Gbps.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="32ba0cb6907ed3d2ecfdb31c699db3b4"></a><!-- doxytag: member="xdptx.h::XDptx_LookupConfig" ref="32ba0cb6907ed3d2ecfdb31c699db3b4" args="(u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_dptx___config.html">XDptx_Config</a>* XDptx_LookupConfig           </td>
          <td>(</td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function looks for the device configuration based on the unique device ID. The table XDptx_ConfigTable[] contains the configuration information for each device in the system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the unique device ID of the device being looked up.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to the configuration table entry corresponding to the given device ID, or NULL if no match is found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a71e17a951f445b9c7bcfcc3104cdf4c"></a><!-- doxytag: member="xdptx.h::XDptx_ResetPhy" ref="a71e17a951f445b9c7bcfcc3104cdf4c" args="(XDptx *InstancePtr, u32 Reset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDptx_ResetPhy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Reset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function does a PHY reset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. &amp;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Reset</em>&nbsp;</td><td>is the type of reset to assert. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f6cbfafba59214dcaad29991a3e265a4"></a><!-- doxytag: member="xdptx.h::XDptx_SelfTest" ref="f6cbfafba59214dcaad29991a3e265a4" args="(XDptx *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_SelfTest           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function runs a self-test on the <a class="el" href="struct_x_dptx.html">XDptx</a> driver/device. The test attempts to intialize the DisplayPort TX core, train the main link at the highest common capabilities between the core and the sink, and checks the status of the link after training.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the self-test passed. The main link has been trained and established successfully.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="2a9f86dab2f5de738680e7b4320469b2"></a><!-- doxytag: member="xdptx.h::XDptx_SetDownspread" ref="2a9f86dab2f5de738680e7b4320469b2" args="(XDptx *InstancePtr, u8 Enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_SetDownspread           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Enable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function enables or disables 0.5% spreading of the clock for both the DisplayPort and the sink device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Enable</em>&nbsp;</td><td>will enable or disable down-spread control.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if setting the downspread control enable was successful.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="1d545645af32331e179e42e979bc3de3"></a><!-- doxytag: member="xdptx.h::XDptx_SetEnhancedFrameMode" ref="1d545645af32331e179e42e979bc3de3" args="(XDptx *InstancePtr, u8 Enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_SetEnhancedFrameMode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Enable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function enables or disables the enhanced framing symbol sequence for both the DisplayPort TX core and the sink device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Enable</em>&nbsp;</td><td>will enable or disable enhanced frame mode.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if setting the enhanced frame mode enable was successful.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="55147fabd5935ff1198d732b54d1f310"></a><!-- doxytag: member="xdptx.h::XDptx_SetHasRedriverInPath" ref="55147fabd5935ff1198d732b54d1f310" args="(XDptx *InstancePtr, u8 Set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDptx_SetHasRedriverInPath           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Set</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets a software switch that signifies whether or not a redriver exists on the DisplayPort output path. XDptx_SetVswingPreemp uses this switch to determine which set of voltage swing and pre-emphasis values to use in the TX core.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Set</em>&nbsp;</td><td>establishes that a redriver exists in the DisplayPort output path. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0fc77fba78c3de3cdd141273b9348d45"></a><!-- doxytag: member="xdptx.h::XDptx_SetHpdEventHandler" ref="0fc77fba78c3de3cdd141273b9348d45" args="(XDptx *InstancePtr, XDptx_HpdEventHandler CallbackFunc, void *CallbackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDptx_SetHpdEventHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xdptx_8h.html#55e031231c2489c71c5b0187f8b2941e">XDptx_HpdEventHandler</a>&nbsp;</td>
          <td class="paramname"> <em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallbackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function installs a callback function for when a hot-plug-detect event interrupt occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackFunc</em>&nbsp;</td><td>is the address to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackRef</em>&nbsp;</td><td>is the user data item that will be passed to the callback function when it is invoked. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a1dd03865a96f1323a8e3445dd4b15a6"></a><!-- doxytag: member="xdptx.h::XDptx_SetHpdPulseHandler" ref="a1dd03865a96f1323a8e3445dd4b15a6" args="(XDptx *InstancePtr, XDptx_HpdPulseHandler CallbackFunc, void *CallbackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDptx_SetHpdPulseHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xdptx_8h.html#26acfa8f4b98b86385c7095bd3668313">XDptx_HpdPulseHandler</a>&nbsp;</td>
          <td class="paramname"> <em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallbackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function installs a callback function for when a hot-plug-detect pulse interrupt occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackFunc</em>&nbsp;</td><td>is the address to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackRef</em>&nbsp;</td><td>is the user data item that will be passed to the callback function when it is invoked. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a273dec21586ac33395010f87401c2d0"></a><!-- doxytag: member="xdptx.h::XDptx_SetLaneCount" ref="a273dec21586ac33395010f87401c2d0" args="(XDptx *InstancePtr, u8 LaneCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_SetLaneCount           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LaneCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the number of lanes to be used by the main link for both the DisplayPort TX core and the sink device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LaneCount</em>&nbsp;</td><td>is the number of lanes to be used over the main link.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if setting the new lane count was successful.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_INVALID_PARAM if the supplied lane count is not either 1, 2, or 4 lanes.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="fc742d9a00ff909e56766f5a692159f2"></a><!-- doxytag: member="xdptx.h::XDptx_SetLinkRate" ref="fc742d9a00ff909e56766f5a692159f2" args="(XDptx *InstancePtr, u8 LinkRate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_SetLinkRate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LinkRate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the data rate to be used by the main link for both the DisplayPort TX core and the sink device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LinkRate</em>&nbsp;</td><td>is the link rate to be used over the main link based on one of the following selects:<ul>
<li>XDPTX_LINK_BW_SET_162GBPS = 0x06 (for a 1.62 Gbps data rate)</li><li>XDPTX_LINK_BW_SET_270GBPS = 0x0A (for a 2.70 Gbps data rate)</li><li>XDPTX_LINK_BW_SET_540GBPS = 0x14 (for a 5.40 Gbps data rate)</li></ul>
</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if setting the new link rate was successful.</li><li>XST_DEVICE_NOT_FOUND if no receiver is connected.</li><li>XST_INVALID_PARAM if the supplied link rate does not correspond to either 1.62, 2.70, or 5.40 Gbps.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="3e9dee7b0b7711677c8c39fd14d585c8"></a><!-- doxytag: member="xdptx.h::XDptx_SetScrambler" ref="3e9dee7b0b7711677c8c39fd14d585c8" args="(XDptx *InstancePtr, u8 Enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDptx_SetScrambler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Enable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function enables or disables scrambling of symbols for both the DisplayPort and the sink device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Enable</em>&nbsp;</td><td>will enable or disable scrambling.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if setting the scrambling enable was successful.</li><li>XST_FAILURE otherwise. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="0cfe4355d8e2fa3e46be78c1800bb9d5"></a><!-- doxytag: member="xdptx.h::XDptx_SetUserTimerHandler" ref="0cfe4355d8e2fa3e46be78c1800bb9d5" args="(XDptx *InstancePtr, XDptx_TimerHandler CallbackFunc, void *CallbackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDptx_SetUserTimerHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xdptx_8h.html#c09d771f709e37e756d8de2ba627701f">XDptx_TimerHandler</a>&nbsp;</td>
          <td class="paramname"> <em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallbackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function installs a custom delay/sleep function to be used by the XDdptx driver.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackFunc</em>&nbsp;</td><td>is the address to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackRef</em>&nbsp;</td><td>is the user data item (microseconds to delay) that will be passed to the custom sleep/delay function when it is invoked. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7cd047ab5d5dc46af427086469e7a0db"></a><!-- doxytag: member="xdptx.h::XDptx_SetVideoMode" ref="7cd047ab5d5dc46af427086469e7a0db" args="(XDptx *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDptx_SetVideoMode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function clears the main stream attributes registers of the DisplayPort TX core and sets them to the values specified in the main stream attributes configuration structure.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f60126291b4c1d2ac2d054707c804dce"></a><!-- doxytag: member="xdptx.h::XDptx_WaitUs" ref="f60126291b4c1d2ac2d054707c804dce" args="(XDptx *InstancePtr, u32 MicroSeconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDptx_WaitUs           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dptx.html">XDptx</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>MicroSeconds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is the delay/sleep function for the <a class="el" href="struct_x_dptx.html">XDptx</a> driver. For the Zynq family, there exists native sleep functionality. For MicroBlaze however, there does not exist such functionality. In the MicroBlaze case, the default method for delaying is to use a predetermined amount of loop iterations. This method is prone to inaccuracy and dependent on system configuration; for greater accuracy, the user may supply their own delay/sleep handler, pointed to by InstancePtr-&gt;UserTimerWaitUs, which may have better accuracy if a hardware timer is used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dptx.html">XDptx</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MicroSeconds</em>&nbsp;</td><td>is the number of microseconds to delay/sleep for. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="35408b37824862d172606842e26e66e0"></a><!-- doxytag: member="xdptx.h::XDptx_DmtModes" ref="35408b37824862d172606842e26e66e0" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_dptx___dmt_mode.html">XDptx_DmtMode</a> <a class="el" href="xdptx__vidmodetable_8c.html#35408b37824862d172606842e26e66e0">XDptx_DmtModes</a>[]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This table contains the main stream attributes for various standard resolutions. 
</div>
</div><p>
Copyright @ 1995-2014 Xilinx, Inc. All rights reserved. 
