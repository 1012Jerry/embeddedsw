<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   xnandps.c File Reference
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.5 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>xnandps.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
This file contains the implementation of the interface functions for XNandPs driver. Refer to the header file xnandps.h for more detailed information.<p>
This module supports for NAND flash memory devices that conform to the "Open NAND Flash Interface" (ONFI) Specification. This modules implements basic flash operations like read, write and erase.<p>
<dl compact><dt><b>Note:</b></dt><dd>None</dd></dl>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who    Date    	   Changes
 ----- ----   ----------  -----------------------------------------------
 1.00a nm     12/10/2010  First release
 1.01a nm     28/02/2012  Fixed 16-bit issue with ONFI commands like
                          read, write and read status command. The config
                          structure width is updated after ONFI query
                          with the parameter page width.
 1.02a nm     20/09/2012  Removed setting of set_cycles and set_opmode
                          register values as it is now done in FSBL using
                          the PCW generated files. CR#678949.
 1.03a nm     10/22/2012  Fixed CR# 673348.
 1.04a nm     04/15/2013  Fixed CR# 704401. Removed warnings when compiled
 			   with -Wall and -Wextra option in bsp.
	       04/25/2013  Implemented PR# 699544. Added page cache read
			   and program support. Added API's XNandPs_ReadCache
			   and XNandPs_WriteCache for page cache support.
			   Added ECC handling functions XNandPs_EccSetCfg,
			   XNandPs_EccSetMemCmd1...etc, to support better 
			   usage of ECC block for page cache commands.
			   Modified Read/Write API's so that there is common
			   code for normal read/write and page cache commands.
			   Disabling/Re-enabling ECC block in read/write API's
			   of spare bytes since we don't calculate ECC for
			   spare bytes.
 </pre> 
<p>
<code>#include &quot;xnandps.h&quot;</code><br>
<code>#include &quot;<a class="el" href="xnandps__bbm_8h.html">xnandps_bbm.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="xnandps__onfi_8h.html">xnandps_onfi.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#5e9a9e78bf52b70288416c4f70d0a636">XNandPs_SendCommand</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr, <a class="el" href="struct_x_nand_ps___command_format.html">XNandPs_CommandFormat</a> *Command, int Page, int Column)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#3ac103af0005d0a9375a8617cab34ae4">XNandPs_InitBbtDesc</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#ec4b8f584cd85c840f97f400be1b7f7c">XNandPs_ScanBbt</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#242826f09f6d9cab1ab85ddf5b1419ab">Onfi_CmdReadStatus</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#71eb008eeb4b6c3b04c7889be9ef7828">Onfi_NandInit</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#640a3a6791dc60cbd8efb13873346667">XNandPs_CfgInitialize</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr, <a class="el" href="struct_x_nand_ps___config.html">XNandPs_Config</a> *ConfigPtr, u32 SmcBaseAddr, u32 FlashBaseAddr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#8771afd57c3c6b395b1232aad24b8732">XNandPs_Read</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr, u64 Offset, u32 Length, void *DestPtr, u8 *UserSparePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#91048dce1286c9378b09f49786e330e3">XNandPs_ReadCache</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr, u64 Offset, u32 Length, void *DestPtr, u8 *UserSparePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#714b8234c64481a732be277cff36880d">XNandPs_Write</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr, u64 Offset, u32 Length, void *SrcPtr, u8 *UserSparePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#fa84ea36515978a94e78a1a05b829181">XNandPs_WriteCache</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr, u64 Offset, u32 Length, void *SrcPtr, u8 *UserSparePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#360edb6cd1a0e223d7e7f4e8c4362faa">XNandPs_ReadSpareBytes</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr, u32 Page, u8 *Buf)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#5002378514a79f56068a9e50c0f10f2c">XNandPs_WriteSpareBytes</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr, u32 Page, u8 *Buf)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#3aeaa22b3ea721c2ed0050abf8502df8">XNandPs_EraseBlock</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr, u32 BlockNum)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#469ff8705a5ab8659ff0ee64c950073d">NandOob16</a> [] = {13, 14, 15}</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#a8fc6bf2121a9ae287b24d102061a281">NandOob32</a> [] = {26, 27, 28, 29, 30, 31}</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#f9b371cb37400b34363fa1a0a56a205e">NandOob64</a> []</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_x_nand_ps___command_format.html">XNandPs_CommandFormat</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#4175177d9f5cd255ff1e01f384129261">OnfiCommands</a> []</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="242826f09f6d9cab1ab85ddf5b1419ab"></a><!-- doxytag: member="xnandps.c::Onfi_CmdReadStatus" ref="242826f09f6d9cab1ab85ddf5b1419ab" args="(XNandPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u8 Onfi_CmdReadStatus           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function sends read status command to the flash device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the XNandPs instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>flash status value read</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="71eb008eeb4b6c3b04c7889be9ef7828"></a><!-- doxytag: member="xnandps.c::Onfi_NandInit" ref="71eb008eeb4b6c3b04c7889be9ef7828" args="(XNandPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Onfi_NandInit           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function initializes the NAND flash and gets the geometry information.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the XNandPs instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XST_FAILURE if failed.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="640a3a6791dc60cbd8efb13873346667"></a><!-- doxytag: member="xnandps.c::XNandPs_CfgInitialize" ref="640a3a6791dc60cbd8efb13873346667" args="(XNandPs *InstancePtr, XNandPs_Config *ConfigPtr, u32 SmcBaseAddr, u32 FlashBaseAddr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XNandPs_CfgInitialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct_x_nand_ps___config.html">XNandPs_Config</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>SmcBaseAddr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>FlashBaseAddr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function initializes a specific XNandPs device/instance. This function must be called prior to using the flash device to read or write any data.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the XNandPs instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ConfigPtr</em>&nbsp;</td><td>points to the XNandPs device configuration structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SmcBaseAddr</em>&nbsp;</td><td>is the base address of SMC controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FlashBaseAddr</em>&nbsp;</td><td>is the base address of NAND flash.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XST_FAILURE if fail.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The user needs to first call the <a class="el" href="xnandps__sinit_8c.html#0b25c536026bf1e6ab4b8aa95e485600">XNandPs_LookupConfig()</a> API which returns the Configuration structure pointer which is passed as a parameter to the <a class="el" href="xnandps_8c.html#640a3a6791dc60cbd8efb13873346667">XNandPs_CfgInitialize()</a> API. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="3aeaa22b3ea721c2ed0050abf8502df8"></a><!-- doxytag: member="xnandps.c::XNandPs_EraseBlock" ref="3aeaa22b3ea721c2ed0050abf8502df8" args="(XNandPs *InstancePtr, u32 BlockNum)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XNandPs_EraseBlock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>BlockNum</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function erases a specific block in the NAND device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the XNandPs instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BlockNum</em>&nbsp;</td><td>is the block number of the device. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XST_FAILURE if fail.</li><li>XST_NAND_WRITE_PROTECTED if the flash is write protected.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="3ac103af0005d0a9375a8617cab34ae4"></a><!-- doxytag: member="xnandps.c::XNandPs_InitBbtDesc" ref="3ac103af0005d0a9375a8617cab34ae4" args="(XNandPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XNandPs_InitBbtDesc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function initializes the Bad Block Table(BBT) descriptors with a predefined pattern for searching Bad Block Table(BBT) in flash.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the XNandPs instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>NONE </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="8771afd57c3c6b395b1232aad24b8732"></a><!-- doxytag: member="xnandps.c::XNandPs_Read" ref="8771afd57c3c6b395b1232aad24b8732" args="(XNandPs *InstancePtr, u64 Offset, u32 Length, void *DestPtr, u8 *UserSparePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XNandPs_Read           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u64&nbsp;</td>
          <td class="mdname" nowrap> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>DestPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>UserSparePtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function reads the data from the Flash device and copies it into the specified user buffer. It doesn't check for the bad blocks while reading the flash pages that cross block boundary. User must take care of handling bad blocks.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to the XNandPs instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>is the flash data address to read from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>is number of bytes to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DestPtr</em>&nbsp;</td><td>is the destination address to copy data to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UserSparePtr</em>&nbsp;</td><td>is the user buffer to which spare data must be copied.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XST_FAILURE if fail.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function reads sequential pages from the Flash device. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="91048dce1286c9378b09f49786e330e3"></a><!-- doxytag: member="xnandps.c::XNandPs_ReadCache" ref="91048dce1286c9378b09f49786e330e3" args="(XNandPs *InstancePtr, u64 Offset, u32 Length, void *DestPtr, u8 *UserSparePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XNandPs_ReadCache           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u64&nbsp;</td>
          <td class="mdname" nowrap> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>DestPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>UserSparePtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function reads the data from the Flash device using read page cache command and copies it into the specified user buffer. It doesn't check for the bad blocks while reading the flash pages that cross block boundary. User must take care of handling bad blocks.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to the XNandPs instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>is the flash data address to read from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>is number of bytes to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DestPtr</em>&nbsp;</td><td>is the destination address to copy data to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UserSparePtr</em>&nbsp;</td><td>is the user buffer to which spare data must be copied.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XST_FAILURE if fail.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function reads sequential pages from the Flash device. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="360edb6cd1a0e223d7e7f4e8c4362faa"></a><!-- doxytag: member="xnandps.c::XNandPs_ReadSpareBytes" ref="360edb6cd1a0e223d7e7f4e8c4362faa" args="(XNandPs *InstancePtr, u32 Page, u8 *Buf)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XNandPs_ReadSpareBytes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Page</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>Buf</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function reads the spare area of a page.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to the XNandPs instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Page</em>&nbsp;</td><td>is the page number from where spare data is read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Buf</em>&nbsp;</td><td>is pointer to the buffer where the spare data is filled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XST_FAILURE if fail.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ec4b8f584cd85c840f97f400be1b7f7c"></a><!-- doxytag: member="xnandps.c::XNandPs_ScanBbt" ref="ec4b8f584cd85c840f97f400be1b7f7c" args="(XNandPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XNandPs_ScanBbt           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function reads the Bad Block Table(BBT) if present in flash. If not it scans the flash for detecting factory marked bad blocks and creates a bad block table and write the Bad Block Table(BBT) into the flash.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the XNandPs instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XST_FAILURE if fail. </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5e9a9e78bf52b70288416c4f70d0a636"></a><!-- doxytag: member="xnandps.c::XNandPs_SendCommand" ref="5e9a9e78bf52b70288416c4f70d0a636" args="(XNandPs *InstancePtr, XNandPs_CommandFormat *Command, int Page, int Column)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XNandPs_SendCommand           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct_x_nand_ps___command_format.html">XNandPs_CommandFormat</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Command</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Page</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Column</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function sends a NAND command to the flash device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to XNandPs struture </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Command</em>&nbsp;</td><td>is the NAND command to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Page</em>&nbsp;</td><td>is the page offset required for specific commands </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Column</em>&nbsp;</td><td>the column offset required for specific commands</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="714b8234c64481a732be277cff36880d"></a><!-- doxytag: member="xnandps.c::XNandPs_Write" ref="714b8234c64481a732be277cff36880d" args="(XNandPs *InstancePtr, u64 Offset, u32 Length, void *SrcPtr, u8 *UserSparePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XNandPs_Write           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u64&nbsp;</td>
          <td class="mdname" nowrap> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>SrcPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>UserSparePtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function programs the flash device(s) with data specified in the user buffer. The source and destination address must be aligned to the width of the flash's data bus. It doesn't check for the bad blocks while writing to the flash pages that cross block boundary. User must take care of handling bad blocks.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to the XNandPs instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>is the flash data address to write to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>is number of bytes to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SrcPtr</em>&nbsp;</td><td>is the source address to write the data from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UserSparePtr</em>&nbsp;</td><td>is the user buffer which contains buffer to write into spare data area.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XST_FAILURE if fail.</li><li>XST_NAND_WRITE_PROTECTED if the flash is write protected.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function writes number of sequential pages into the Flash device. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="fa84ea36515978a94e78a1a05b829181"></a><!-- doxytag: member="xnandps.c::XNandPs_WriteCache" ref="fa84ea36515978a94e78a1a05b829181" args="(XNandPs *InstancePtr, u64 Offset, u32 Length, void *SrcPtr, u8 *UserSparePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XNandPs_WriteCache           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u64&nbsp;</td>
          <td class="mdname" nowrap> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>SrcPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>UserSparePtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function programs the flash device(s) with data specified in the user buffer using program cache command. The source and destination address must be aligned to the width of the flash's data bus. It doesn't check for the bad blocks while writing to the flash pages that cross block boundary. User must take care of handling bad blocks.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to the XNandPs instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>is the flash data address to write to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>is number of bytes to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SrcPtr</em>&nbsp;</td><td>is the source address to write the data from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UserSparePtr</em>&nbsp;</td><td>is the user buffer which contains buffer to write into spare data area.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XST_FAILURE if fail.</li><li>XST_NAND_WRITE_PROTECTED if the flash is write protected.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function writes number of sequential pages into the Flash device. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5002378514a79f56068a9e50c0f10f2c"></a><!-- doxytag: member="xnandps.c::XNandPs_WriteSpareBytes" ref="5002378514a79f56068a9e50c0f10f2c" args="(XNandPs *InstancePtr, u32 Page, u8 *Buf)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XNandPs_WriteSpareBytes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Page</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>Buf</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function write to the spare area of a page.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to the XNandPs instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Page</em>&nbsp;</td><td>is the page number to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Buf</em>&nbsp;</td><td>is pointer to the buffer which holds the data.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XST_FAILURE if fail.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="469ff8705a5ab8659ff0ee64c950073d"></a><!-- doxytag: member="xnandps.c::NandOob16" ref="469ff8705a5ab8659ff0ee64c950073d" args="[]" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u32 <a class="el" href="xnandps_8c.html#469ff8705a5ab8659ff0ee64c950073d">NandOob16</a>[] = {13, 14, 15}          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Ecc position for 16 bytes spare area     </td>
  </tr>
</table>
<a class="anchor" name="a8fc6bf2121a9ae287b24d102061a281"></a><!-- doxytag: member="xnandps.c::NandOob32" ref="a8fc6bf2121a9ae287b24d102061a281" args="[]" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u32 <a class="el" href="xnandps_8c.html#a8fc6bf2121a9ae287b24d102061a281">NandOob32</a>[] = {26, 27, 28, 29, 30, 31}          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Ecc position for 32 bytes spare area     </td>
  </tr>
</table>
<a class="anchor" name="f9b371cb37400b34363fa1a0a56a205e"></a><!-- doxytag: member="xnandps.c::NandOob64" ref="f9b371cb37400b34363fa1a0a56a205e" args="[]" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u32 <a class="el" href="xnandps_8c.html#f9b371cb37400b34363fa1a0a56a205e">NandOob64</a>[]          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {52, 53, 54, 55, 56, 57,
                   58, 59, 60, 61, 62, 63}
</pre></div>Ecc position for 64 bytes spare area     </td>
  </tr>
</table>
<a class="anchor" name="4175177d9f5cd255ff1e01f384129261"></a><!-- doxytag: member="xnandps.c::OnfiCommands" ref="4175177d9f5cd255ff1e01f384129261" args="[]" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_nand_ps___command_format.html">XNandPs_CommandFormat</a> <a class="el" href="xnandps__onfi_8c.html#4175177d9f5cd255ff1e01f384129261">OnfiCommands</a>[]          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This structure defines the onfi command format sent to the flash.     </td>
  </tr>
</table>
Copyright @ 1995-2014 Xilinx, Inc. All rights reserved. 
