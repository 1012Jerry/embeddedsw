<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   axivdma v5_0
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.5 -->
<div class="tabs">
  <ul>
    <li id="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>axivdma v5_0</h1>
<p>
This is the Xilinx MVI AXI Video DMA device driver. The DMA engine transfers frames from the AXI Bus or to the AXI Bus. It is in the chain of video IPs, which process video frames.<p>
It supports the following features:<ul>
<li>Continuous transfers of video frames, AKA circular buffer mode</li><li>Continuous transfers of one specific video frame, AKA park mode</li><li>Optionally only transfer a certain amount of video frames</li><li>Optionally transfer unaligned frame buffers</li></ul>
<p>
An AXI Video DMA engine can have one or two channels. If configured as two channels, then one of the channels reads data from memory, and the other channel writes to the memory.<p>
For a full description of AXI Video DMA features, please see the hardware spec.<p>
The driver composes of three parts: initialization, start a DMA transfer, and interrupt handling.<p>
<b> Driver Initialization </b><p>
To initialize the driver, the caller needs to pass a configuration structure to the driver. This configuration structure contains information about the hardware build.<p>
A caller can manually setup the configuration structure, or call XAxiVdma_LoopkupConfig().<p>
The sequence of initialization of the driver is: 1. <a class="el" href="xaxivdma__sinit_8c.html#e2510562a8ef03b832930159fa0e02b5">XAxiVdma_LookupConfig()</a> to get the configuration structure, or manually setup the structure. 2. <a class="el" href="xaxivdma_8c.html#d4fb52f44c17abce3b63a6452e7db8e6">XAxiVdma_CfgInitialize()</a> to initialize the driver &amp; device. 3. <a class="el" href="xaxivdma_8c.html#b5e88f20f88b436f97d12dde8b76e3dc">XAxiVdma_SetFrmStore()</a> to set the desired frame store number which is optional. 4. If interrupt is desired:<ul>
<li>Set frame counter using <a class="el" href="xaxivdma_8c.html#bca6d9c6ce189b7e9a921b40153150eb">XAxiVdma_SetFrameCounter()</a></li><li>Set call back functions for each channel. There are two types of call backfunctions: general and error</li><li>Enable interrupts that the user cares about</li></ul>
<p>
<b>Start a DMA Transaction </b><p>
If you are using the driver API to start the transfer, then there are two ways to start a DMA transaction:<p>
1. Invoke <a class="el" href="xaxivdma_8c.html#be0e5895aa394ead8e02ee859b07a49a">XAxiVdma_StartWriteFrame()</a> or <a class="el" href="xaxivdma_8c.html#a38f72fe981db54f056b180e79f1dbf5">XAxiVdma_StartReadFrame()</a> to start a DMA operation, depending on the purpose of the transfer (Read or Write).<p>
2. Or, call the phased functions as the following:<ul>
<li>Call <a class="el" href="xaxivdma_8c.html#3bac160a2afa4bd9637505ca19bd6f4f">XAxiVdma_DmaConfig()</a> to set up a DMA operation configuration</li><li>Call <a class="el" href="xaxivdma_8c.html#774e288ba4535db783b6dbed8204ca95">XAxiVdma_DmaSetBufferAddr()</a> to set up the DMA buffers</li><li>Call <a class="el" href="xaxivdma_8c.html#6993a05a7bdc0669b3e9d7939b6e1642">XAxiVdma_DmaStart()</a> to kick off the DMA operation</li></ul>
<p>
If you are writing your own functions to start the transfer, the order of setting up the hardware must be the following:<p>
<ul>
<li>Do any processing or setting, but do not start the hardware, means do not set the RUN/STOP bit in the XAXIVDMA_CR_OFFSET register.</li><li>After any reset you need to do, write the head of your BD ring into the XAXIVDMA_CDESC_OFFSET register.</li><li>You can do other setup for the harware.</li><li>Start your hardware, by setting up the RUN/STOP bit in the XAXIVDMA_CR_OFFSET register.</li><li>You can do other setup for the hardware.</li><li>If you are done with all the setup, now write the tail of your BD ring to the XAXIVDMA_TDESC_OFFSET register to start the transfer.</li></ul>
<p>
You can refer to <a class="el" href="xaxivdma__channel_8c.html#b54b24f4dcc8e3e8b9542ec2c4c42f2b">XAxiVdma_ChannelStartTransfer()</a> to see how this order is preserved there. The function is in <a class="el" href="xaxivdma__channel_8c.html">xaxivdma_channel.c</a>.<p>
Note a Read VDMA could work with one out of multiple write VDMA instances and vice versa. The PointNum in structure <a class="el" href="struct_x_axi_vdma___dma_setup.html">XAxiVdma_DmaSetup</a> decides which VDMA instance this VDMA is working with.<p>
<b>Interrupt Handling </b><p>
Each VDMA channel supports 2 kinds of interrupts:<ul>
<li>General Interrupt: An interrupt other than error interrupt.</li><li>Error Interrupt: An error just happened.</li></ul>
<p>
The driver does the interrupt handling, and dispatch to the user application through callback functions that user has registered. If there are no registered callback functions, then a stub callback function is called.<p>
Each channel has two interrupt callback functions. One for IOC and delay interrupt, or general interrupt; one for error interrupt.<p>
<b>Reset</b><p>
Reset a DMA channel causes the channel enter the following state:<p>
<ul>
<li>Interrupts are disabled</li><li>Coalescing threshold is one</li><li>Delay counter is 0</li><li>RUN/STOP bit low</li><li>Halted bit high</li><li>XAXIVDMA_CDESC_OFFSET register has 0</li><li>XAXIVDMA_TDESC_OFFSET register has 0</li></ul>
<p>
If there is an active transfer going on when reset (or stop) is issued to the hardware, the current transfer will gracefully finish. For a maximum transfer length of (0x1FFF * 0xFFFF) bytes, on a 100 MHz system, it can take as long as 1.34 seconds, assuming that the system responds to DMA engine's requests quickly.<p>
To ensure that the hardware finishes the reset, please use <a class="el" href="xaxivdma_8c.html#2896ee3bfd00bb01445c1125b55139f6">XAxiVdma_ResetNotDone()</a> to check for completion of the reset.<p>
To start a transfer after a reset, the following actions are the minimal requirement before setting RUN/STOP bit high to avoid crashing the system:<p>
<ul>
<li>XAXIVDMA_CDESC_OFFSET register has a valid BD pointer, it should be the head of the BD ring.</li><li>XAXIVDMA_TDESC_OFFSET register has a valid BD pointer, it should be the tail of the BD ring.</li></ul>
<p>
If you are using the driver API to start a transfer after a reset, then it should be fine.<p>
<b>Stop</b><p>
Stop a channel using XAxiVDma_DmaStop() is similar to a reset, except the registers are kept intact.<p>
To start a transfer after a stop:<p>
<ul>
<li>If there are error bits in the status register, then a reset is necessary. Please refer to the <b>Reset</b> section for more details on how to start a transfer after a reset.</li><li>If there are no error bits in the status register, then you can call <a class="el" href="xaxivdma_8c.html#6993a05a7bdc0669b3e9d7939b6e1642">XAxiVdma_DmaStart()</a> to start the transfer again. Note that the transfer always starts from the first video frame.</li></ul>
<p>
<b> Examples</b><p>
We provide one example on how to use the AXI VDMA with AXI Video IPs. This example does not work by itself. To make it work, you must have two other Video IPs to connect to the VDMA. One of the Video IP does the write and the other does the read.<p>
<b>Cache Coherency</b><p>
This driver does not handle any cache coherency for the data buffers. The application is responsible for handling cache coherency, if the cache is enabled.<p>
<b>Alignment</b><p>
The VDMA supports any buffer alignment when DRE is enabled in the hardware configuration. It only supports word-aligned buffers otherwise. Note that "word" is defined by C_M_AXIS_MM2S_TDATA_WIDTH and C_S_AXIS_S2MM_TDATA_WIDTH for the read and write channel specifically.<p>
If the horizonal frame size is not word-aligned, then DRE must be enabled in the hardware. Otherwise, undefined results happen.<p>
<b>Address Translation</b><p>
Buffer addresses for transfers are physical addresses. If the system does not use MMU, then physical and virtual addresses are the same.<p>
<b>API Change from PLB Video DMA</b><p>
We try to keep the API as consistent with the PLB Video DMA driver as possible. However, due to hardware differences, some of the PLB video DMA driver APIs are changed or removed. Two API functions are added to the AXI DMA driver.<p>
For details on the API changes, please refer to <a class="el" href="xaxivdma__porting__guide_8h.html">xaxivdma_porting_guide.h</a>.<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who  Date     Changes
 ----- ---- -------- -------------------------------------------------------
 1.00a jz   08/16/10 First release
 2.00a jz   12/10/10 Added support for direct register access mode, v3 core
 2.01a jz   01/19/11 Added ability to re-assign BD addresses
		      Replaced include xenv.h with string.h in <a class="el" href="xaxivdma__i_8h.html">xaxivdma_i.h</a>
 		      file.
 2.01a	rkv  03/28/11 Added support for frame store register and 
                     XAxiVdma_ChannelInit API is changed.
 3.00a srt  08/26/11 - Added support for Flush on Frame Sync and dynamic 
		      	programming of Line Buffer Thresholds.<ul>
<li>XAxiVdma_ChannelErrors API is changed to support for
			Flush on Frame Sync feature.</li><li>Two flags, XST_VDMA_MISMATCH_ERROR &amp; XAXIVDMA_MIS
			MATCH_ERROR are added to report error status when
			Flush on Frame Sync feature is enabled.		    
 4.00a srt  11/21/11 - XAxiVdma_ChannelSetBufferAddr API is changed to
			support 32 Frame Stores.</li><li>XAxiVdma_ChannelConfig API is changed to support
			modified Park Offset Register bits.</li><li>Added APIs: 
			<a class="el" href="xaxivdma_8c.html#9e64b7cdd1e811c9f0f78d53ded2326d">XAxiVdma_FsyncSrcSelect()</a>
			<a class="el" href="xaxivdma_8c.html#6376a297533bfe977a0f25e1b1005b18">XAxiVdma_GenLockSourceSelect()</a></li><li>Modified structures <a class="el" href="struct_x_axi_vdma___config.html">XAxiVdma_Config</a> and <a class="el" href="struct_x_axi_vdma.html">XAxiVdma</a> to
		        include new parameters.
 4.01a srt  06/13/12 - Added APIs:
			<a class="el" href="xaxivdma_8c.html#c540ef75c9ada8d4321c884cc03793af">XAxiVdma_GetDmaChannelErrors()</a>
			<a class="el" href="xaxivdma_8c.html#7061aad011f9f0b626c8aa06781ef25b">XAxiVdma_ClearDmaChannelErrors()</a>
			XAxiVdma_ClearChannelErrors()</li><li>XAxiVdma_ChannelErrors API is changed to remove 
			Mismatch error logic.</li><li>Removed Error checking logic in the channel APIs.
			Provided User APIs to do this.</li><li>Added new error bit mask XAXIVDMA_SR_ERR_SOF_LATE_MASK</li><li>XAXIVDMA_MISMATCH_ERROR flag is deprecated.</li><li>Modified the logic of Error handling in interrupt
		        handlers.
 4.02a srt  10/11/12 - XAxiVdma_SetFrmStore function changed to remove 
                       Reset logic after setting number of frame stores.
			(CR 678734)</li><li>Changed Error bitmasks to support IP version 5.02a.
			(CR 679959)
 4.03a srt  01/18/13 - Updated logic of GenLockSourceSelect() &amp; FsyncSrcSelect()
                       APIs for newer versions of IP (CR: 691052).</li><li>Modified CfgInitialize() API to initialize
			StreamWidth parameters and added TDATA_WIDTH parameters
			to tcl file (CR 691866)</li><li>Updated DDR base address for IPI designs (CR 703656).
 4.04a srt  03/03/13 - Support for the GenlockRepeat Control bit (Bit 15)
                       added in the new version of IP v5.04 (CR: 691391)</li></ul>
</pre><p>
<pre><ul>
<li>Updated driver tcl, <a class="el" href="xaxivdma__g_8c.html">xaxivdma_g.c</a> and  <a class="el" href="struct_x_axi_vdma___config.html">XAxiVdma_Config</a>
			structure in xaxivdma.h to import the relevant VDMA IP
			DEBUG_INFO_* parameters into the driver.
			This fixes CR# 703738.
 4.05a srt  05/01/3  - Merged v4.03a driver with v4.04a driver.
		             Driver v4.03a - Supports VDMA IPv5.04a XPS release
		             Driver v4.04a - Supports VDMA IPv6.00a IPI release
	                 The parameters C_ENABLE_DEBUG_* are only available in 
		         VDMA IPv6.00a. These parameters should be set to '1'
		         for older versions of IP (XPS) and added this logic in
		         the driver tcl file.</li></ul>
</pre><p>
<pre>Added unalignment checks for Hsize and Stride
			(CR 710279)
 4.06a srt  04/09/13 - Added support for the newly added S2MM_DMA_IRQ_MASK
                       register (CR 734741)
 5.0   adk  19/12/13 - Updated as per the New Tcl API's</pre><p>
<pre> </pre> Copyright @ 1995-2014 Xilinx, Inc. All rights reserved. 
