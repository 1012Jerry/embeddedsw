<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>sysmonpsu: xsysmonpsu.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sysmonpsu
   </div>
   <div id="projectbrief">Xilinx SDK Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_3d8ae667e48a6cbccd83ec3f0dab6fae.html">sysmonpsu</a></li><li class="navelem"><a class="el" href="dir_6dce4783c5b54e41acca6cc96589ab02.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xsysmonpsu.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<div class="textblock"><p>The System Monitor device has the following features:</p><ul>
<li>PL Sysmon instance has 10-bit, 200-KSPS (kilo samples per second) Analog-to-Digital Converter (ADC)</li>
<li>PS Sysmon instance has 10-bit, 1000-KSPS ADC.</li>
<li>Monitoring of on-chip supply voltages and temperature</li>
<li>1 dedicated differential analog-input pair and 16 auxiliary differential analog-input pairs</li>
<li>Automatic alarms based on user defined limits for the on-chip supply voltages and temperature</li>
<li>Automatic Channel Sequencer, programmable averaging, programmable acquisition time for the external inputs, unipolar or differential input selection for the external inputs</li>
<li>Inbuilt Calibration</li>
<li>Optional interrupt request generation</li>
<li>External Mux</li>
</ul>
<p>The user should refer to the hardware device specification for detailed information about the device.</p>
<p>This header file contains the prototypes of driver functions that can be used to access the System Monitor device.</p>
<p><b> System Monitor Channel Sequencer Modes </b></p>
<p>The System Monitor Channel Sequencer supports the following operating modes:</p>
<ul>
<li><b> Default </b>: This is the default mode after power up. In this mode of operation the System Monitor operates in a sequence mode, monitoring the on chip sensors: Temperature, VCCINT, and VCCAUX.</li>
<li><b> One pass through sequence </b>: In this mode the System Monitor converts the channels enabled in the Sequencer Channel Enable registers for a single pass and then stops.</li>
<li><b> Continuous cycling of sequence </b>: In this mode the System Monitor converts the channels enabled in the Sequencer Channel Enable registers continuously.</li>
<li><b> Single channel mode</b>: In this mode the System Monitor Channel Sequencer is disabled and the System Monitor operates in a Single Channel Mode. The System Monitor can operate either in a Continuous or Event driven sampling mode in the single channel mode.</li>
</ul>
<p><b> Initialization and Configuration </b></p>
<p>The device driver enables higher layer software (e.g., an application) to communicate to the System Monitor device.</p>
<p><a class="el" href="xsysmonpsu_8h.html#a8cd0584410c0931f931aa4da1e3e151b" title="This function initializes XSysMonPsu device/instance. ">XSysMonPsu_CfgInitialize()</a> API is used to initialize the System Monitor device. The user needs to first call the <a class="el" href="xsysmonpsu_8h.html#a948f08280b6195869015382d92ba8a50" title="This function looks for the device configuration based on the unique device ID. ">XSysMonPsu_LookupConfig()</a> API which returns the Configuration structure pointer which is passed as a parameter to the <a class="el" href="xsysmonpsu_8h.html#a8cd0584410c0931f931aa4da1e3e151b" title="This function initializes XSysMonPsu device/instance. ">XSysMonPsu_CfgInitialize()</a> API.</p>
<p><b>Interrupts</b></p>
<p>The System Monitor device supports interrupt driven mode and the default operation mode is polling mode.</p>
<p>This driver does not provide a Interrupt Service Routine (ISR) for the device. It is the responsibility of the application to provide one if needed. Refer to the interrupt example provided with this driver for details on using the device in interrupt mode.</p>
<p><b> Virtual Memory </b></p>
<p>This driver supports Virtual Memory. The RTOS is responsible for calculating the correct device base address in Virtual Memory space.</p>
<p><b> Threads </b></p>
<p>This driver is not thread safe. Any needs for threads or thread mutual exclusion must be satisfied by the layer above this driver.</p>
<p><b> Asserts </b></p>
<p>Asserts are used within all Xilinx drivers to enforce constraints on argument values. Asserts can be turned off on a system-wide basis by defining, at compile time, the NDEBUG identifier. By default, asserts are turned on and it is recommended that users leave asserts on during development.</p>
<p><b> Building the driver </b></p>
<p>The <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> driver is composed of several source files. This allows the user to build and link only those parts of the driver that are necessary.</p>
<p><b> Limitations of the driver </b></p>
<p>System Monitor device can be accessed through the JTAG port and the AXI interface. The driver implementation does not support the simultaneous access of the device by both these interfaces. The user has to take care of this situation in the user application code.</p>
<p><br />
<br />
</p>
<pre>
MODIFICATION HISTORY:</pre><pre>Ver   Who    Date	Changes
----- -----  -------- -----------------------------------------------
1.00  kvn    12/15/15 First release
             02/15/16 Corrected Assert function call in
                      XSysMonPsu_GetMonitorStatus API.
             03/03/16 Added Temperature remote channel for Setsingle
                      channel API. Also corrected external mux channel
                      numbers.
1.1   kvn    05/05/16 Modified code for MISRA-C:2012 Compliance.
2.0   vns    08/14/16 Fixed CR #956780, added support for enabling/disabling
                      SEQ_CH2 and SEQ_AVG2 registers, modified function
                      prototypes of XSysMonPsu_GetSeqAvgEnables,
                      XSysMonPsu_SetSeqAvgEnables, XSysMonPsu_SetSeqChEnables,
                      XSysMonPsu_GetSeqChEnables,
                      XSysMonPsu_SetSeqInputMode, XSysMonPsu_GetSeqInputMode,
                      XSysMonPsu_SetSeqAcqTime
                      and XSysMonPsu_GetSeqAcqTime to provide support for
                      set/get 64 bit value.
                      Added constants XSM_CFR_ALM_SUPPLY*(8-31)_MASKs to
                      provide support for enabling extra PS alarams.</pre><pre></pre> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_sys_mon_psu___config.html">XSysMonPsu_Config</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a380d87507652a19d453b20e6d7655d65"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a380d87507652a19d453b20e6d7655d65">XSysMonPsu_RawToTemperature_OnChip</a>(AdcData)&#160;&#160;&#160;((((float)(AdcData)/65536.0f)/0.00199451786f ) - 273.6777f)</td></tr>
<tr class="separator:a380d87507652a19d453b20e6d7655d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab3e135004e7d5995a827caa045883e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a9ab3e135004e7d5995a827caa045883e">XSysMonPsu_RawToTemperature_ExternalRef</a>(AdcData)&#160;&#160;&#160;((((float)(AdcData)/65536.0f)/0.00198842814f ) - 273.8195f)</td></tr>
<tr class="separator:a9ab3e135004e7d5995a827caa045883e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6667f0fcc65dda4a7af897b2924143c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#af6667f0fcc65dda4a7af897b2924143c">XSysMonPsu_RawToVoltage</a>(AdcData)&#160;&#160;&#160;((((float)(AdcData))* (3.0f))/65536.0f)</td></tr>
<tr class="separator:af6667f0fcc65dda4a7af897b2924143c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977b419288fae23364d46bc87d6976ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a977b419288fae23364d46bc87d6976ce">XSysMonPsu_TemperatureToRaw_OnChip</a>(Temperature)&#160;&#160;&#160;((s32)(((Temperature) + 273.6777f)*65536.0f*0.00199451786f))</td></tr>
<tr class="separator:a977b419288fae23364d46bc87d6976ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b32ba6617a306fd1f12c7d34151722"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a50b32ba6617a306fd1f12c7d34151722">XSysMonPsu_TemperatureToRaw_ExternalRef</a>(Temperature)&#160;&#160;&#160;((s32)(((Temperature) + 273.8195f)*65536.0f*0.00198842814f))</td></tr>
<tr class="separator:a50b32ba6617a306fd1f12c7d34151722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986f164c3c1f811ea27713adf9dace4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a986f164c3c1f811ea27713adf9dace4c">XSysMonPsu_VoltageToRaw</a>(Voltage)&#160;&#160;&#160;((s32)((Voltage)*65536.0f/3.0f))</td></tr>
<tr class="separator:a986f164c3c1f811ea27713adf9dace4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Indexes for the different channels.</div></td></tr>
<tr><td colspan="2"><div class="groupHeader">Indexes for reading the Calibration Coefficient Data.</div></td></tr>
<tr><td colspan="2"><div class="groupHeader">Indexes for reading the Minimum/Maximum Measurement Data.</div></td></tr>
<tr><td colspan="2"><div class="groupHeader">Averaging to be done for the channels.</div></td></tr>
<tr><td colspan="2"><div class="groupHeader">Channel Sequencer Modes of operation.</div></td></tr>
<tr><td colspan="2"><div class="groupHeader">Clock Divisor values range.</div></td></tr>
<tr><td colspan="2"><div class="groupHeader">Alarm Threshold(Limit) Register (ATR) indexes.</div></td></tr>
<tr><td colspan="2"><div class="groupHeader">Alarm masks for channels in Configuration registers 1</div></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa228a3186422ffdc47f63d2e6b0f654e"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#aa228a3186422ffdc47f63d2e6b0f654e">XSysMonPsu_Handler</a>) (void *CallBackRef)</td></tr>
<tr class="separator:aa228a3186422ffdc47f63d2e6b0f654e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8cd0584410c0931f931aa4da1e3e151b"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a8cd0584410c0931f931aa4da1e3e151b">XSysMonPsu_CfgInitialize</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, <a class="el" href="struct_x_sys_mon_psu___config.html">XSysMonPsu_Config</a> *ConfigPtr, u32 EffectiveAddr)</td></tr>
<tr class="separator:a8cd0584410c0931f931aa4da1e3e151b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fc9daa41e50955a71e2fe7a107a0e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ad6fc9daa41e50955a71e2fe7a107a0e5">XSysMonPsu_Reset</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr)</td></tr>
<tr class="separator:ad6fc9daa41e50955a71e2fe7a107a0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1841bc7888195dd3f9381947e4f8d3"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a5e1841bc7888195dd3f9381947e4f8d3">XSysMonPsu_GetStatus</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="separator:a5e1841bc7888195dd3f9381947e4f8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed2a9f0fbd1be48dfd71aaeef05174f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a2ed2a9f0fbd1be48dfd71aaeef05174f">XSysMonPsu_StartAdcConversion</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr)</td></tr>
<tr class="separator:a2ed2a9f0fbd1be48dfd71aaeef05174f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54eb6ba4c6f594b75d402cde03f6e173"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a54eb6ba4c6f594b75d402cde03f6e173">XSysMonPsu_GetAdcData</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 Channel, u32 Block)</td></tr>
<tr class="separator:a54eb6ba4c6f594b75d402cde03f6e173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83bb4ad116f2bb1ea7676050bd74b6b"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#af83bb4ad116f2bb1ea7676050bd74b6b">XSysMonPsu_GetCalibCoefficient</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 CoeffType, u32 SysmonBlk)</td></tr>
<tr class="separator:af83bb4ad116f2bb1ea7676050bd74b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4312c89ab0280cd7df2de940193fe32"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#aa4312c89ab0280cd7df2de940193fe32">XSysMonPsu_GetMinMaxMeasurement</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 MeasurementType, u32 SysmonBlk)</td></tr>
<tr class="separator:aa4312c89ab0280cd7df2de940193fe32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711d9441ecb7c36f22b11f941d7f994b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a711d9441ecb7c36f22b11f941d7f994b">XSysMonPsu_SetAvg</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 Average, u32 SysmonBlk)</td></tr>
<tr class="separator:a711d9441ecb7c36f22b11f941d7f994b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d99a653ec8c8089e8cdc9e4f400dc3"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a78d99a653ec8c8089e8cdc9e4f400dc3">XSysMonPsu_GetAvg</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="separator:a78d99a653ec8c8089e8cdc9e4f400dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872e9a41818489e77fa554dd01408281"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 Channel, u32 IncreaseAcqCycles, u32 IsEventMode, u32 IsDifferentialMode, u32 SysmonBlk)</td></tr>
<tr class="separator:a872e9a41818489e77fa554dd01408281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce8ca01b6992994737213f342847662"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a3ce8ca01b6992994737213f342847662">XSysMonPsu_SetAlarmEnables</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 AlmEnableMask, u32 SysmonBlk)</td></tr>
<tr class="separator:a3ce8ca01b6992994737213f342847662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c38e475226ff1eba528d0c9b7eb9b5"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ab1c38e475226ff1eba528d0c9b7eb9b5">XSysMonPsu_GetAlarmEnables</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="separator:ab1c38e475226ff1eba528d0c9b7eb9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bdb4e555b2c8d47a0185862c9cb4c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#aa4bdb4e555b2c8d47a0185862c9cb4c6">XSysMonPsu_SetSequencerMode</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 SequencerMode, u32 SysmonBlk)</td></tr>
<tr class="separator:aa4bdb4e555b2c8d47a0185862c9cb4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2d5053a1406cecd4fa311525f68ce7"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a2f2d5053a1406cecd4fa311525f68ce7">XSysMonPsu_GetSequencerMode</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="separator:a2f2d5053a1406cecd4fa311525f68ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193dbc689e9a668ef7f548920706b2a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a193dbc689e9a668ef7f548920706b2a8">XSysMonPsu_SetSequencerEvent</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 IsEventMode, u32 SysmonBlk)</td></tr>
<tr class="separator:a193dbc689e9a668ef7f548920706b2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0b98e18bb6c2c8b3587e2fe2cffde8"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a6a0b98e18bb6c2c8b3587e2fe2cffde8">XSysMonPsu_GetSequencerEvent</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="separator:a6a0b98e18bb6c2c8b3587e2fe2cffde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4903002cdddf192acdcda4827e5b1a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ab4903002cdddf192acdcda4827e5b1a6">XSysMonPsu_SetExtenalMux</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 Channel, u32 SysmonBlk)</td></tr>
<tr class="separator:ab4903002cdddf192acdcda4827e5b1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3ad732967594b6cc1cc314e24ae9b0"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a5e3ad732967594b6cc1cc314e24ae9b0">XSysMonPsu_GetExtenalMux</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="separator:a5e3ad732967594b6cc1cc314e24ae9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e8fc0b9dffbe33b41ec4e6825ffc4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a11e8fc0b9dffbe33b41ec4e6825ffc4a">XSysMonPsu_SetAdcClkDivisor</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 Divisor, u32 SysmonBlk)</td></tr>
<tr class="separator:a11e8fc0b9dffbe33b41ec4e6825ffc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c7d46d66608863cf7b859238e44e13"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#af6c7d46d66608863cf7b859238e44e13">XSysMonPsu_GetAdcClkDivisor</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="separator:af6c7d46d66608863cf7b859238e44e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51295c525a507a8f334c97f02a84221"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ac51295c525a507a8f334c97f02a84221">XSysMonPsu_SetSeqChEnables</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u64 ChEnableMask, u32 SysmonBlk)</td></tr>
<tr class="separator:ac51295c525a507a8f334c97f02a84221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0cf3c7c355471f81fe60d663043e7b"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#adf0cf3c7c355471f81fe60d663043e7b">XSysMonPsu_GetSeqAvgEnables</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="separator:adf0cf3c7c355471f81fe60d663043e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d0525934fbe21b46732c039f93a8b0"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a08d0525934fbe21b46732c039f93a8b0">XSysMonPsu_GetSeqChEnables</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="separator:a08d0525934fbe21b46732c039f93a8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb114566387fa8889b913f34a7de6010"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#adb114566387fa8889b913f34a7de6010">XSysMonPsu_SetSeqAvgEnables</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u64 AvgEnableChMask, u32 SysmonBlk)</td></tr>
<tr class="separator:adb114566387fa8889b913f34a7de6010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b751279110ca4a05073ae8a9b8a1a8"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ae6b751279110ca4a05073ae8a9b8a1a8">XSysMonPsu_SetSeqInputMode</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u64 InputModeChMask, u32 SysmonBlk)</td></tr>
<tr class="separator:ae6b751279110ca4a05073ae8a9b8a1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e597e2db96739d90195d9ad019377c4"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a2e597e2db96739d90195d9ad019377c4">XSysMonPsu_GetSeqInputMode</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="separator:a2e597e2db96739d90195d9ad019377c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe5ce3d9e15f0bebdab313decf9729c"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#acfe5ce3d9e15f0bebdab313decf9729c">XSysMonPsu_SetSeqAcqTime</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u64 AcqCyclesChMask, u32 SysmonBlk)</td></tr>
<tr class="separator:acfe5ce3d9e15f0bebdab313decf9729c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8261ca6ec1564b9066f858adbd81a85f"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a8261ca6ec1564b9066f858adbd81a85f">XSysMonPsu_GetSeqAcqTime</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="separator:a8261ca6ec1564b9066f858adbd81a85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d436ab807a561d70339cdfe52f6f560"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a6d436ab807a561d70339cdfe52f6f560">XSysMonPsu_SetAlarmThreshold</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 AlarmThrReg, u16 Value, u32 SysmonBlk)</td></tr>
<tr class="separator:a6d436ab807a561d70339cdfe52f6f560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708bc2465a24743784ce6119bc05b10a"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a708bc2465a24743784ce6119bc05b10a">XSysMonPsu_GetAlarmThreshold</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 AlarmThrReg, u32 SysmonBlk)</td></tr>
<tr class="separator:a708bc2465a24743784ce6119bc05b10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118f51203c23bf2ed1f76d154e46ad3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a118f51203c23bf2ed1f76d154e46ad3c">XSysMonPsu_SetPSAutoConversion</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr)</td></tr>
<tr class="separator:a118f51203c23bf2ed1f76d154e46ad3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f2fde294e151e5db65822b26f11a4f"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ad9f2fde294e151e5db65822b26f11a4f">XSysMonPsu_GetMonitorStatus</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr)</td></tr>
<tr class="separator:ad9f2fde294e151e5db65822b26f11a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97be122426bd5302e93b45ba5a3fc8ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a97be122426bd5302e93b45ba5a3fc8ec">XSysMonPsu_IntrEnable</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u64 Mask)</td></tr>
<tr class="separator:a97be122426bd5302e93b45ba5a3fc8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f581ea48eb8d57c2fab2dcaefdeccd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a95f581ea48eb8d57c2fab2dcaefdeccd">XSysMonPsu_IntrDisable</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u64 Mask)</td></tr>
<tr class="separator:a95f581ea48eb8d57c2fab2dcaefdeccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b39afe5e1c62f44a320311d74e2402"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a78b39afe5e1c62f44a320311d74e2402">XSysMonPsu_IntrGetEnabled</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr)</td></tr>
<tr class="separator:a78b39afe5e1c62f44a320311d74e2402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef44a74426b13480363747a5dedc5d0"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a3ef44a74426b13480363747a5dedc5d0">XSysMonPsu_IntrGetStatus</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr)</td></tr>
<tr class="separator:a3ef44a74426b13480363747a5dedc5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c41996bf95cd7119dba302246345a9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a7c41996bf95cd7119dba302246345a9d">XSysMonPsu_IntrClear</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u64 Mask)</td></tr>
<tr class="separator:a7c41996bf95cd7119dba302246345a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d8d59cc35fe4151b51b5bbafdca2ca"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a39d8d59cc35fe4151b51b5bbafdca2ca">XSysMonPsu_SelfTest</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr)</td></tr>
<tr class="separator:a39d8d59cc35fe4151b51b5bbafdca2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948f08280b6195869015382d92ba8a50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_sys_mon_psu___config.html">XSysMonPsu_Config</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a948f08280b6195869015382d92ba8a50">XSysMonPsu_LookupConfig</a> (u16 DeviceId)</td></tr>
<tr class="separator:a948f08280b6195869015382d92ba8a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a3c17894e2b8cc575bc8192c2ede7f019"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_OT_LOWER&#160;&#160;&#160;7U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower Over Temperature limit. </p>

</div>
</div>
<a class="anchor" id="aca2f92bee99f2e78c2418bb237763ab4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_OT_UPPER&#160;&#160;&#160;3U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upper Over Temperature limit. </p>

</div>
</div>
<a class="anchor" id="a7d16bad767fc1c4e8f02dd606efbe742"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP10_LOWER&#160;&#160;&#160;0x1BU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply10 low voltage limit. </p>

</div>
</div>
<a class="anchor" id="a6e518f2b534c43f92efa7c1e605f46ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP10_UPPER&#160;&#160;&#160;0x13U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply10 high voltage limit. </p>

</div>
</div>
<a class="anchor" id="a6dfa93eff75396bbfad602d8586995d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP1_LOWER&#160;&#160;&#160;5U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suuply1 low voltage limit. </p>

</div>
</div>
<a class="anchor" id="a220ecdeca017ceb88fcb61fcc0f20253"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP1_UPPER&#160;&#160;&#160;1U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply1 high voltage limit. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a39d8d59cc35fe4151b51b5bbafdca2ca">XSysMonPsu_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="af2b3d8137af325fe8d91c4a1c2d8ee98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP2_LOWER&#160;&#160;&#160;6U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply2 low voltage limit. </p>

</div>
</div>
<a class="anchor" id="a8435336cfcb347810a70af56f310bd67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP2_UPPER&#160;&#160;&#160;2U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply2 high voltage limit. </p>

</div>
</div>
<a class="anchor" id="a5b01f56ee33bf0ed6e0d42cac33cb50f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP3_LOWER&#160;&#160;&#160;0xCU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply3 low voltage limit. </p>

</div>
</div>
<a class="anchor" id="a58fa91d71bb7459ec43600876c0ad4be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP3_UPPER&#160;&#160;&#160;8U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply3 high voltage limit. </p>

</div>
</div>
<a class="anchor" id="a970695f46a5c360347d0241132e66a15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP4_LOWER&#160;&#160;&#160;0xDU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply4 low voltage limit. </p>

</div>
</div>
<a class="anchor" id="a52bd95d4a9b4adf4d32a0a3be256a6c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP4_UPPER&#160;&#160;&#160;9U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply4 high voltage limit. </p>

</div>
</div>
<a class="anchor" id="ad5f380b3303cda01b3b9d7ac319485c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP5_LOWER&#160;&#160;&#160;0xEU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply5 low voltage limit. </p>

</div>
</div>
<a class="anchor" id="afe102c2c4b1420b0994523817e71e14c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP5_UPPER&#160;&#160;&#160;0xAU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply5 high voltage limit. </p>

</div>
</div>
<a class="anchor" id="a7d07244310934945baa3160cb52809df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP6_LOWER&#160;&#160;&#160;0xFU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply6 low voltage limit. </p>

</div>
</div>
<a class="anchor" id="ab83e730e268431827c2476b071e98708"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP6_UPPER&#160;&#160;&#160;0xBU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply6 high voltage limit. </p>

</div>
</div>
<a class="anchor" id="a9cd13eee75fe9d48b9d004652cb12e1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP7_LOWER&#160;&#160;&#160;0x18U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply7 low voltage limit. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a708bc2465a24743784ce6119bc05b10a">XSysMonPsu_GetAlarmThreshold()</a>, and <a class="el" href="xsysmonpsu_8h.html#a6d436ab807a561d70339cdfe52f6f560">XSysMonPsu_SetAlarmThreshold()</a>.</p>

</div>
</div>
<a class="anchor" id="af8cd72cf7f17d1a282951a12e141ea8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP7_UPPER&#160;&#160;&#160;0x10U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply7 high voltage limit. </p>

</div>
</div>
<a class="anchor" id="a9886bb5d8f5e9c7ab14da5d66106b77e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP8_LOWER&#160;&#160;&#160;0x19U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply8 low voltage limit. </p>

</div>
</div>
<a class="anchor" id="a3bf3eaff26d3b2df6c0bb2b78ff454d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP8_UPPER&#160;&#160;&#160;0x11U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply8 high voltage limit. </p>

</div>
</div>
<a class="anchor" id="a3c9f70508a6fc65111524555a8cbab63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP9_LOWER&#160;&#160;&#160;0x1AU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply9 low voltage limit. </p>

</div>
</div>
<a class="anchor" id="a62a5f33197223d36588ac2414674c391"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP9_UPPER&#160;&#160;&#160;0x12U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply9 high voltage limit. </p>

</div>
</div>
<a class="anchor" id="a138ea63ae47cd1478f188045792a5aef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_TEMP_LOWER&#160;&#160;&#160;4U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low user Temperature. </p>

</div>
</div>
<a class="anchor" id="a9b816bc88f59e9b497fa66f336babd99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_TEMP_RMTE_LOWER&#160;&#160;&#160;0x1DU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low remote Temperature limit. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a708bc2465a24743784ce6119bc05b10a">XSysMonPsu_GetAlarmThreshold()</a>, and <a class="el" href="xsysmonpsu_8h.html#a6d436ab807a561d70339cdfe52f6f560">XSysMonPsu_SetAlarmThreshold()</a>.</p>

</div>
</div>
<a class="anchor" id="ad1eb3b0945f7c93a178c67fe0bb66d9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_TEMP_RMTE_UPPER&#160;&#160;&#160;0x15U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High remote Temperature limit. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a708bc2465a24743784ce6119bc05b10a">XSysMonPsu_GetAlarmThreshold()</a>, and <a class="el" href="xsysmonpsu_8h.html#a6d436ab807a561d70339cdfe52f6f560">XSysMonPsu_SetAlarmThreshold()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e041ad6a624c7014aad8803d2f9667a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_TEMP_UPPER&#160;&#160;&#160;0U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High user Temperature limit. </p>

</div>
</div>
<a class="anchor" id="a0f3c58830b92f1368d828cc30d6fcfd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VCCAMS_LOWER&#160;&#160;&#160;0x1CU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VCCAMS low voltage limit. </p>

</div>
</div>
<a class="anchor" id="aeb02464e70f858c8c3cde15456e1d9ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VCCAMS_UPPER&#160;&#160;&#160;0x14U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VCCAMS high voltage limit. </p>

</div>
</div>
<a class="anchor" id="a81e97c4d54cab391a4c816f2bb666a63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_AVG_0_SAMPLES&#160;&#160;&#160;0U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>No Averaging. </p>

</div>
</div>
<a class="anchor" id="a7cd77d90e7456614726390476f3636c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_AVG_16_SAMPLES&#160;&#160;&#160;1U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average 16 samples. </p>

</div>
</div>
<a class="anchor" id="a2bcf68b01a8ff59237bea9b303828e4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_AVG_256_SAMPLES&#160;&#160;&#160;3U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average 256 samples. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a711d9441ecb7c36f22b11f941d7f994b">XSysMonPsu_SetAvg()</a>.</p>

</div>
</div>
<a class="anchor" id="a30eabcd0f343d52159cce69aad462c37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_AVG_64_SAMPLES&#160;&#160;&#160;2U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average 64 samples. </p>

</div>
</div>
<a class="anchor" id="a47dbdfce05bdc719f09f56e36ac154b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CALIB_ADC_OFFSET_COEFF&#160;&#160;&#160;1U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ADC Offset Calib Coefficient. </p>

</div>
</div>
<a class="anchor" id="a173a9675e7f812b837aab6cf61457b6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CALIB_GAIN_ERROR_COEFF&#160;&#160;&#160;2U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gain Error Calib Coefficient. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#af83bb4ad116f2bb1ea7676050bd74b6b">XSysMonPsu_GetCalibCoefficient()</a>.</p>

</div>
</div>
<a class="anchor" id="a6152ac28d736b4e0d1e214f3377fd1e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CALIB_SUPPLY_OFFSET_COEFF&#160;&#160;&#160;0U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply Offset Calib Coefficient. </p>

</div>
</div>
<a class="anchor" id="a1e30d664f1f3cc61bf0728c28633221a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_OT_MASK&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Over Temperature Alarm. </p>

</div>
</div>
<a class="anchor" id="a7ce2b0d52d92328019e103dd3205c820"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY10_MASK&#160;&#160;&#160;0x040000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 6 - SUPPLY6. </p>

</div>
</div>
<a class="anchor" id="a14c6bb5bcc7fa47a0098c1324cda1f27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY11_MASK&#160;&#160;&#160;0x080000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 6 - SUPPLY6. </p>

</div>
</div>
<a class="anchor" id="a40b254ba9b0fa4a16cb8c85d09e1d4d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY12_MASK&#160;&#160;&#160;0x100000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 6 - SUPPLY6. </p>

</div>
</div>
<a class="anchor" id="aa05b5c4679a807629e4478ac21c07bba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY13_MASK&#160;&#160;&#160;0x200000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 6 - SUPPLY6. </p>

</div>
</div>
<a class="anchor" id="adf617c1e2104003abbd7cec9a69411f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY1_MASK&#160;&#160;&#160;0x0004</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 1 - SUPPLY1. </p>

</div>
</div>
<a class="anchor" id="ae990f0790723d434fe1948753771d62e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY2_MASK&#160;&#160;&#160;0x0008</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 2 - SUPPLY2. </p>

</div>
</div>
<a class="anchor" id="a5468b12d45def4d7b462ac5a735c1605"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY3_MASK&#160;&#160;&#160;0x0100</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 3 - SUPPLY3. </p>

</div>
</div>
<a class="anchor" id="a4faf17a94077f5b556fbfab9ad1d3f79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY4_MASK&#160;&#160;&#160;0x0200</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 4 - SUPPLY4. </p>

</div>
</div>
<a class="anchor" id="a8bd6b739fd7953414edc24e672d3ec38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY5_MASK&#160;&#160;&#160;0x0400</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 5 - SUPPLY5. </p>

</div>
</div>
<a class="anchor" id="ab2543cfe1cfcfe989d7e361b9365e185"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY6_MASK&#160;&#160;&#160;0x0800</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 6 - SUPPLY6. </p>

</div>
</div>
<a class="anchor" id="a78f1ab5ec444d4210083808046e4d779"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY8_MASK&#160;&#160;&#160;0x010000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 6 - SUPPLY6. </p>

</div>
</div>
<a class="anchor" id="ac0ce336fba61a108bd9b56dad419de6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY9_MASK&#160;&#160;&#160;0x020000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 6 - SUPPLY6. </p>

</div>
</div>
<a class="anchor" id="a69ff380ea74c831bcf39a5c46652d056"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_TEMP_MASK&#160;&#160;&#160;0x0002</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 0 - Temperature. </p>

</div>
</div>
<a class="anchor" id="a802955d06a498aca0909e488caee528c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_ADC_CALIB&#160;&#160;&#160;0x09U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ADC Offset Channel Reg. </p>

</div>
</div>
<a class="anchor" id="ae8c007df4d1c481557120435619b4ff5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_AUX_MAX&#160;&#160;&#160;31U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Channel number for Last Aux channel. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a54eb6ba4c6f594b75d402cde03f6e173">XSysMonPsu_GetAdcData()</a>, <a class="el" href="xsysmonpsu_8h.html#ab4903002cdddf192acdcda4827e5b1a6">XSysMonPsu_SetExtenalMux()</a>, and <a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams()</a>.</p>

</div>
</div>
<a class="anchor" id="a41aa90146d4e0786b8d36888e44aac34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_AUX_MIN&#160;&#160;&#160;16U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Channel number for 1st Aux Channel. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#ab4903002cdddf192acdcda4827e5b1a6">XSysMonPsu_SetExtenalMux()</a>, and <a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams()</a>.</p>

</div>
</div>
<a class="anchor" id="ae6b086c6e28f21abdcd2078b41b975a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_DDRPHY_AT0&#160;&#160;&#160;49U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DDRPHY_AT0. </p>

</div>
</div>
<a class="anchor" id="a2526be2a1f3319c068088aade1c73eb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_DDRPHY_VREF&#160;&#160;&#160;48U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DDRPHY_VREF. </p>

</div>
</div>
<a class="anchor" id="a15ea4b9f08ee9dc44fc000384ca36e42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_GAINERR_CALIB&#160;&#160;&#160;0x0AU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gain Error Channel Reg. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a54eb6ba4c6f594b75d402cde03f6e173">XSysMonPsu_GetAdcData()</a>, and <a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams()</a>.</p>

</div>
</div>
<a class="anchor" id="a1233836ff8a51affd9b5e2b4c84b1a2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_PSGT_AT0&#160;&#160;&#160;50U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PSGT_AT0. </p>

</div>
</div>
<a class="anchor" id="afd85b2ed119364500384a1cfca4e4576"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_PSGT_AT1&#160;&#160;&#160;51U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PSGT_AT0. </p>

</div>
</div>
<a class="anchor" id="ad942bb367363cf19f059ff852f7083c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_RESERVE0&#160;&#160;&#160;52U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PSGT_AT0. </p>

</div>
</div>
<a class="anchor" id="ae411c55817a64b2351271181ebdae254"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_RESERVE1&#160;&#160;&#160;53U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PSGT_AT0. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a54eb6ba4c6f594b75d402cde03f6e173">XSysMonPsu_GetAdcData()</a>.</p>

</div>
</div>
<a class="anchor" id="a0b564ae32085a3fc51c452d1babe46db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_SUPPLY1&#160;&#160;&#160;0x1U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SUPPLY1 VCC_PSINTLP. </p>

</div>
</div>
<a class="anchor" id="a39654f20bba10aa6e1cd7985fe75ea70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_SUPPLY10&#160;&#160;&#160;35U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SUPPLY10 PS_MGTRAVTT. </p>

</div>
</div>
<a class="anchor" id="a80fb0fe44e342aad8c2d19d1f435284a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_SUPPLY2&#160;&#160;&#160;0x2U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SUPPLY2 VCC_PSINTFP. </p>

</div>
</div>
<a class="anchor" id="a7c4df26dc69ef41921c484fd3ccc006c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_SUPPLY3&#160;&#160;&#160;0x6U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SUPPLY3 VCC_PSAUX. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a54eb6ba4c6f594b75d402cde03f6e173">XSysMonPsu_GetAdcData()</a>, and <a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams()</a>.</p>

</div>
</div>
<a class="anchor" id="a2939dda6d5c6efbcf10977c6b33aa7fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_SUPPLY4&#160;&#160;&#160;0x0DU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SUPPLY4 VCC_PSDDR_504. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a54eb6ba4c6f594b75d402cde03f6e173">XSysMonPsu_GetAdcData()</a>, and <a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams()</a>.</p>

</div>
</div>
<a class="anchor" id="aa3880806109f07b635bb02c599fced14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_SUPPLY5&#160;&#160;&#160;0x0EU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SUPPLY5 VCC_PSIO3_503. </p>

</div>
</div>
<a class="anchor" id="a4afc3f01bbea8bc4f94435b5cd5e1915"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_SUPPLY6&#160;&#160;&#160;0x0FU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SUPPLY6 VCC_PSIO0_500. </p>

</div>
</div>
<a class="anchor" id="aba50e39946a244f7565b8d15c3ffabb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_SUPPLY7&#160;&#160;&#160;32U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SUPPLY7 VCC_PSIO1_501. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a54eb6ba4c6f594b75d402cde03f6e173">XSysMonPsu_GetAdcData()</a>.</p>

</div>
</div>
<a class="anchor" id="aadf08790ddd9d8b02768583c3f250636"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_SUPPLY8&#160;&#160;&#160;33U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SUPPLY8 VCC_PSIO2_502. </p>

</div>
</div>
<a class="anchor" id="a7d8c7547ed4d7e1652b7e078bc6230ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_SUPPLY9&#160;&#160;&#160;34U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SUPPLY9 PS_MGTRAVCC. </p>

</div>
</div>
<a class="anchor" id="a3fdb14478def5283880cd4d65dfaf56f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_SUPPLY_CALIB&#160;&#160;&#160;0x08U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply Calib Data Reg. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a54eb6ba4c6f594b75d402cde03f6e173">XSysMonPsu_GetAdcData()</a>, and <a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams()</a>.</p>

</div>
</div>
<a class="anchor" id="af2f79c54dddbdf090934f80f315b2e60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_TEMP&#160;&#160;&#160;0x0U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>On Chip Temperature. </p>

</div>
</div>
<a class="anchor" id="ace8eebd74607658044e98c7b5ca1c0c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_TEMP_REMTE&#160;&#160;&#160;37U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Temperature Remote. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a54eb6ba4c6f594b75d402cde03f6e173">XSysMonPsu_GetAdcData()</a>, and <a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams()</a>.</p>

</div>
</div>
<a class="anchor" id="a4e9be76bfd9fbcf42a7ac5e2a5b0548d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VCC_PSBATT&#160;&#160;&#160;43U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VCC_PSBATT. </p>

</div>
</div>
<a class="anchor" id="a432956207f2e1b259f9d320739b5d286"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VCC_PSDDRPLL&#160;&#160;&#160;47U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VCC_PSDDRPLL. </p>

</div>
</div>
<a class="anchor" id="a367867d9ef353a759eb5d33620bffed4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VCC_PSLL0&#160;&#160;&#160;38U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VCC_PSLL0. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a54eb6ba4c6f594b75d402cde03f6e173">XSysMonPsu_GetAdcData()</a>.</p>

</div>
</div>
<a class="anchor" id="a83511a8d11ebf4e7f61f0518ce7e24ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VCC_PSLL1&#160;&#160;&#160;39U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VCC_PSLL1. </p>

</div>
</div>
<a class="anchor" id="a3aaa56fad7f607c91f41089742611abf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VCC_PSLL2&#160;&#160;&#160;40U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VCC_PSLL2. </p>

</div>
</div>
<a class="anchor" id="a8b87dfb4207793ed9043629c32488aa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VCC_PSLL3&#160;&#160;&#160;41U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VCC_PSLL3. </p>

</div>
</div>
<a class="anchor" id="af31409819d43692e5ddc6223f479c91d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VCC_PSLL4&#160;&#160;&#160;42U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VCC_PSLL4. </p>

</div>
</div>
<a class="anchor" id="a69dbddc6ab704c05c513e9d3957167a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VCCAMS&#160;&#160;&#160;36U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VCCAMS. </p>

</div>
</div>
<a class="anchor" id="a1c6a2517306958c69f3259057d3649a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VCCAUX&#160;&#160;&#160;46U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VCCAUX. </p>

</div>
</div>
<a class="anchor" id="a3c791d8747031b6e7fdc85cac810241a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VCCBRAM&#160;&#160;&#160;45U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VCCBRAM. </p>

</div>
</div>
<a class="anchor" id="a715e29a748cdd1b301bec9ac17c4c7f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VCCINT&#160;&#160;&#160;44U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VCCINT. </p>

</div>
</div>
<a class="anchor" id="af9c81d9f5fa3d80cad2b374c84117840"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VPVN&#160;&#160;&#160;0x3U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VP/VN Dedicated analog inputs. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams()</a>.</p>

</div>
</div>
<a class="anchor" id="a120bab2a7a97a74da70eef07204728fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VREFN&#160;&#160;&#160;0x5U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VREFN. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#ab4903002cdddf192acdcda4827e5b1a6">XSysMonPsu_SetExtenalMux()</a>.</p>

</div>
</div>
<a class="anchor" id="a676a91c5452aa7ec285794dc3ee13d4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VREFP&#160;&#160;&#160;0x4U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VREFP. </p>

</div>
</div>
<a class="anchor" id="aca34d11f97f4410add9157f7d03d2af4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CLK_DIV_MAX&#160;&#160;&#160;255U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum Clock Divisor value. </p>

</div>
</div>
<a class="anchor" id="a6f0bef0dfd3704d427564bf705a7f9ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CLK_DIV_MIN&#160;&#160;&#160;0U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum Clock Divisor value. </p>

</div>
</div>
<a class="anchor" id="a2ab1b4304d1e781bd7a9908718620c0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_SUPPLY1&#160;&#160;&#160;1U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum SUPPLY1 Data. </p>

</div>
</div>
<a class="anchor" id="a4ad452144ae98a77893ab4056e341b47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_SUPPLY10&#160;&#160;&#160;0x83U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum SUPPLY10 Data. </p>

</div>
</div>
<a class="anchor" id="a1e17f28a5b5e02447d0674120e5a9257"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_SUPPLY2&#160;&#160;&#160;2U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum SUPPLY2 Data. </p>

</div>
</div>
<a class="anchor" id="a4cc0e390c18e733d61a5bec32f8f806f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_SUPPLY3&#160;&#160;&#160;3U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum SUPPLY3 Data. </p>

</div>
</div>
<a class="anchor" id="ab4ef6de7f4d6dd4bcc55ea7f7e0d5f66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_SUPPLY4&#160;&#160;&#160;8U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum SUPPLY4 Data. </p>

</div>
</div>
<a class="anchor" id="af94baf233cff0eac2a5aa299a05a7937"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_SUPPLY5&#160;&#160;&#160;9U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum SUPPLY5 Data. </p>

</div>
</div>
<a class="anchor" id="a9e519a87a8d9330083e59826065eb259"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_SUPPLY6&#160;&#160;&#160;0xAU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum SUPPLY6 Data. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#aa4312c89ab0280cd7df2de940193fe32">XSysMonPsu_GetMinMaxMeasurement()</a>.</p>

</div>
</div>
<a class="anchor" id="aa21e53b8ba182fbe4481563ed3edc772"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_SUPPLY7&#160;&#160;&#160;0x80U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum SUPPLY7 Data. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#aa4312c89ab0280cd7df2de940193fe32">XSysMonPsu_GetMinMaxMeasurement()</a>.</p>

</div>
</div>
<a class="anchor" id="ae8253f7661c72912e98b88d128fcb50b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_SUPPLY8&#160;&#160;&#160;0x81U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum SUPPLY8 Data. </p>

</div>
</div>
<a class="anchor" id="ad5d3f6c621f7d737ce7697947a8f39d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_SUPPLY9&#160;&#160;&#160;0x82U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum SUPPLY9 Data. </p>

</div>
</div>
<a class="anchor" id="a35d9814abedb2943f4a84ecff66351e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_TEMP&#160;&#160;&#160;0U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum Temperature Data. </p>

</div>
</div>
<a class="anchor" id="acf402d972e5855885a587779aa75f802"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_TEMP_REMOTE&#160;&#160;&#160;0x85U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum Remote Temperature Data. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#aa4312c89ab0280cd7df2de940193fe32">XSysMonPsu_GetMinMaxMeasurement()</a>.</p>

</div>
</div>
<a class="anchor" id="a592a7d4901c3adeae9b0e28be37c8484"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_VCCAMS&#160;&#160;&#160;0x84U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum VCCAMS Data. </p>

</div>
</div>
<a class="anchor" id="acda48741be11b7a96ece33a3f67dbd74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_SUPPLY1&#160;&#160;&#160;5U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum SUPPLY1 Data. </p>

</div>
</div>
<a class="anchor" id="a74372e940f4e159070de88166b07a344"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_SUPPLY10&#160;&#160;&#160;0x8BU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum SUPPLY10 Data. </p>

</div>
</div>
<a class="anchor" id="a9b0e0664dcc3a6fb227157d1e49ce255"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_SUPPLY2&#160;&#160;&#160;6U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum SUPPLY2 Data. </p>

</div>
</div>
<a class="anchor" id="a4ae90b5125c90a5ecf98415c05e493a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_SUPPLY3&#160;&#160;&#160;7U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum SUPPLY3 Data. </p>

</div>
</div>
<a class="anchor" id="a92681353913a769554b3a03f0a614bcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_SUPPLY4&#160;&#160;&#160;0xCU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum SUPPLY4 Data. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#aa4312c89ab0280cd7df2de940193fe32">XSysMonPsu_GetMinMaxMeasurement()</a>.</p>

</div>
</div>
<a class="anchor" id="a685eed612478874918c1d2ae77ae93e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_SUPPLY5&#160;&#160;&#160;0xDU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum SUPPLY5 Data. </p>

</div>
</div>
<a class="anchor" id="af309384ae3efb40dd11f11a5e7170671"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_SUPPLY6&#160;&#160;&#160;0xEU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum SUPPLY6 Data. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#aa4312c89ab0280cd7df2de940193fe32">XSysMonPsu_GetMinMaxMeasurement()</a>.</p>

</div>
</div>
<a class="anchor" id="aec0f9f1e8ad9a98083f6e399a2d8b5e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_SUPPLY7&#160;&#160;&#160;0x88U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum SUPPLY7 Data. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#aa4312c89ab0280cd7df2de940193fe32">XSysMonPsu_GetMinMaxMeasurement()</a>.</p>

</div>
</div>
<a class="anchor" id="a139cbe1dcb71891e7681ca57d9fc7b86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_SUPPLY8&#160;&#160;&#160;0x89U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum SUPPLY8 Data. </p>

</div>
</div>
<a class="anchor" id="a7b172c8397ed0cbb59ed58a0b5265194"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_SUPPLY9&#160;&#160;&#160;0x8AU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum SUPPLY9 Data. </p>

</div>
</div>
<a class="anchor" id="af3acf3098ee563aa1cc3e35555d4e801"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_TEMP&#160;&#160;&#160;4U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum Temperature Data. </p>

</div>
</div>
<a class="anchor" id="acd364c7df27909c07ca9df995f4c0af7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_TEMP_REMOTE&#160;&#160;&#160;0x8DU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum Remote Temperature Data. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#aa4312c89ab0280cd7df2de940193fe32">XSysMonPsu_GetMinMaxMeasurement()</a>.</p>

</div>
</div>
<a class="anchor" id="ac3d4d25ec322db4f763a371168dcccf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_VCCAMS&#160;&#160;&#160;0x8CU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum VCCAMS Data. </p>

</div>
</div>
<a class="anchor" id="a090e870886f3ed8d58efc57c763772f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_SEQ_MODE_CONTINPASS&#160;&#160;&#160;2U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Continuous Cycling Seqquencer. </p>

</div>
</div>
<a class="anchor" id="abd5917a2edc464012891450744a15a0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_SEQ_MODE_ONEPASS&#160;&#160;&#160;1U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Onepass through Sequencer. </p>

</div>
</div>
<a class="anchor" id="a9fadcdd4e89cd9d96581f81dfe47dce7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_SEQ_MODE_OYLMPUS&#160;&#160;&#160;6U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Olympus mode. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#aa4bdb4e555b2c8d47a0185862c9cb4c6">XSysMonPsu_SetSequencerMode()</a>.</p>

</div>
</div>
<a class="anchor" id="a223c74befcd8a6710ea7a7acbaf41636"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_SEQ_MODE_SAFE&#160;&#160;&#160;0U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default Safe Mode. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#acfe5ce3d9e15f0bebdab313decf9729c">XSysMonPsu_SetSeqAcqTime()</a>, <a class="el" href="xsysmonpsu_8h.html#adb114566387fa8889b913f34a7de6010">XSysMonPsu_SetSeqAvgEnables()</a>, <a class="el" href="xsysmonpsu_8h.html#ac51295c525a507a8f334c97f02a84221">XSysMonPsu_SetSeqChEnables()</a>, and <a class="el" href="xsysmonpsu_8h.html#ae6b751279110ca4a05073ae8a9b8a1a8">XSysMonPsu_SetSeqInputMode()</a>.</p>

</div>
</div>
<a class="anchor" id="a3c4487fa8b08f41c807433ef456abc75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_SEQ_MODE_SINGCHAN&#160;&#160;&#160;3U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single channel - No Sequencing. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#aa4bdb4e555b2c8d47a0185862c9cb4c6">XSysMonPsu_SetSequencerMode()</a>, and <a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ab3e135004e7d5995a827caa045883e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSysMonPsu_RawToTemperature_ExternalRef</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">AdcData</td><td>)</td>
          <td>&#160;&#160;&#160;((((float)(AdcData)/65536.0f)/0.00198842814f ) - 273.8195f)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro converts System Monitor Raw Data to Temperature(centigrades) for external reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdcData</td><td>is the SysMon Raw ADC Data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Temperature in centigrades.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: float XSysMon_RawToTemperature_ExternalRef(u32 AdcData) </dd></dl>

</div>
</div>
<a class="anchor" id="a380d87507652a19d453b20e6d7655d65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSysMonPsu_RawToTemperature_OnChip</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">AdcData</td><td>)</td>
          <td>&#160;&#160;&#160;((((float)(AdcData)/65536.0f)/0.00199451786f ) - 273.6777f)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro converts System Monitor Raw Data to Temperature(centigrades) for On-Chip Sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdcData</td><td>is the SysMon Raw ADC Data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Temperature in centigrades.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: float XSysMon_RawToTemperature_OnChip(u32 AdcData) </dd></dl>

</div>
</div>
<a class="anchor" id="af6667f0fcc65dda4a7af897b2924143c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSysMonPsu_RawToVoltage</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">AdcData</td><td>)</td>
          <td>&#160;&#160;&#160;((((float)(AdcData))* (3.0f))/65536.0f)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro converts System Monitor Raw Data to Voltage(volts). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdcData</td><td>is the System Monitor ADC Raw Data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Voltage in volts.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: float XSysMon_RawToVoltage(u32 AdcData) </dd></dl>

</div>
</div>
<a class="anchor" id="a50b32ba6617a306fd1f12c7d34151722"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSysMonPsu_TemperatureToRaw_ExternalRef</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Temperature</td><td>)</td>
          <td>&#160;&#160;&#160;((s32)(((Temperature) + 273.8195f)*65536.0f*0.00198842814f))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro converts Temperature in centigrades to System Monitor Raw Data for external reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Temperature</td><td>is the Temperature in centigrades to be converted to System Monitor ADC Raw Data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The System Monitor ADC Raw Data.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: int XSysMon_TemperatureToRaw_ExternalRef(float Temperature) </dd></dl>

</div>
</div>
<a class="anchor" id="a977b419288fae23364d46bc87d6976ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSysMonPsu_TemperatureToRaw_OnChip</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Temperature</td><td>)</td>
          <td>&#160;&#160;&#160;((s32)(((Temperature) + 273.6777f)*65536.0f*0.00199451786f))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro converts Temperature in centigrades to System Monitor Raw Data for On-Chip Sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Temperature</td><td>is the Temperature in centigrades to be converted to System Monitor ADC Raw Data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The System Monitor ADC Raw Data.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: int XSysMon_TemperatureToRaw_OnChip(float Temperature) </dd></dl>

</div>
</div>
<a class="anchor" id="a986f164c3c1f811ea27713adf9dace4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSysMonPsu_VoltageToRaw</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Voltage</td><td>)</td>
          <td>&#160;&#160;&#160;((s32)((Voltage)*65536.0f/3.0f))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro converts Voltage in Volts to System Monitor Raw Data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Voltage</td><td>is the Voltage in volts to be converted to System Monitor/ADC Raw Data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The System Monitor ADC Raw Data.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: int XSysMon_VoltageToRaw(float Voltage) </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="aa228a3186422ffdc47f63d2e6b0f654e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XSysMonPsu_Handler) (void *CallBackRef)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This data type defines a handler that an application defines to communicate with interrupt system to retrieve state information about an application. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CallBackRef</td><td>is a callback reference passed in by the upper layer when setting the handler, and is passed back to the upper layer when the handler is called. It is used to find the device driver instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a8cd0584410c0931f931aa4da1e3e151b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSysMonPsu_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu___config.html">XSysMonPsu_Config</a> *&#160;</td>
          <td class="paramname"><em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>EffectiveAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> device/instance. </p>
<p>This function must be called prior to using the System Monitor device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">ConfigPtr</td><td>points to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> device configuration structure. </td></tr>
    <tr><td class="paramname">EffectiveAddr</td><td>is the device base address in the virtual memory address space. If the address translation is not used then the physical address is passed. Unexpected errors may occur if the address mapping is changed after this function is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The user needs to first call the <a class="el" href="xsysmonpsu_8h.html#a948f08280b6195869015382d92ba8a50" title="This function looks for the device configuration based on the unique device ID. ">XSysMonPsu_LookupConfig()</a> API which returns the Configuration structure pointer which is passed as a parameter to the <a class="el" href="xsysmonpsu_8c.html#a8cd0584410c0931f931aa4da1e3e151b" title="This function initializes XSysMonPsu device/instance. ">XSysMonPsu_CfgInitialize()</a> API. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu___config.html#abc6dabd175ea52cdf0dbf5b32798f62d">XSysMonPsu_Config::DeviceId</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a4107b908b0a66ed314fa19c9458e10dd">XSYSMONPSU_PL_SYSMON_CSTS_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a5652827d8f6d892c11c0a1a5aa03217d">XSYSMONPSU_PS_SYSMON_CSTS_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu_8c.html#ad6fc9daa41e50955a71e2fe7a107a0e5">XSysMonPsu_Reset()</a>.</p>

</div>
</div>
<a class="anchor" id="af6c7d46d66608863cf7b859238e44e13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XSysMonPsu_GetAdcClkDivisor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function gets the ADCCLK divisor from the Configuration Register 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XSysMon instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The divisor read from the Configuration Register 2.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The ADCCLK is an internal clock used by the ADC and is synchronized to the DCLK clock. The ADCCLK is equal to DCLK divided by the user selection in the Configuration Register 2. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a5a77bafe25ef83d49e8091cbe661d974">XSYSMONPSU_CFG_REG2_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a54eb6ba4c6f594b75d402cde03f6e173"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XSysMonPsu_GetAdcData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the ADC converted data for the specified channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">Channel</td><td>is the channel number. Use the XSM_CH_* defined in the file <a class="el" href="xsysmonpsu_8h.html" title="The XSysMon driver supports the Xilinx System Monitor device. ">xsysmonpsu.h</a>. The valid channels for PS / PL SysMon are 0 - 6, 8 - 10 and 13 - 37. For AMS, 38 - 53 channels are valid. </td></tr>
    <tr><td class="paramname">Block</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block or the AMS controller register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 16-bit value representing the ADC converted data for the specified channel. The System Monitor device guarantees a 10 bit resolution for the ADC converted data and data is the 10 MSB bits of the 16 data read from the device.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Please make sure that the proper channel number is passed. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#ae8c007df4d1c481557120435619b4ff5">XSM_CH_AUX_MAX</a>, <a class="el" href="xsysmonpsu_8h.html#a15ea4b9f08ee9dc44fc000384ca36e42">XSM_CH_GAINERR_CALIB</a>, <a class="el" href="xsysmonpsu_8h.html#ae411c55817a64b2351271181ebdae254">XSM_CH_RESERVE1</a>, <a class="el" href="xsysmonpsu_8h.html#a7c4df26dc69ef41921c484fd3ccc006c">XSM_CH_SUPPLY3</a>, <a class="el" href="xsysmonpsu_8h.html#a2939dda6d5c6efbcf10977c6b33aa7fb">XSM_CH_SUPPLY4</a>, <a class="el" href="xsysmonpsu_8h.html#aba50e39946a244f7565b8d15c3ffabb8">XSM_CH_SUPPLY7</a>, <a class="el" href="xsysmonpsu_8h.html#a3fdb14478def5283880cd4d65dfaf56f">XSM_CH_SUPPLY_CALIB</a>, <a class="el" href="xsysmonpsu_8h.html#ace8eebd74607658044e98c7b5ca1c0c6">XSM_CH_TEMP_REMTE</a>, <a class="el" href="xsysmonpsu_8h.html#a367867d9ef353a759eb5d33620bffed4">XSM_CH_VCC_PSLL0</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="ab1c38e475226ff1eba528d0c9b7eb9b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSysMonPsu_GetAlarmEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the status of the alarm output enables in the Configuration Register 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is the bit-mask of the enabled alarm outputs in the Configuration Register 1. Use the masks XSYSMONPSU_CFG_REG1_ALRM_*_MASK masks defined in <a class="el" href="xsysmonpsu_8h.html" title="The XSysMon driver supports the Xilinx System Monitor device. ">xsysmonpsu.h</a> to interpret the returned value.</dd></dl>
<p>Bit positions of 1 indicate that the alarm output is enabled. Bit positions of 0 indicate that the alarm output is disabled.</p>
<dl class="section note"><dt>Note</dt><dd>The implementation of the alarm enables in the Configuration register 1 is such that alarms for the bit positions of 1 will be disabled and alarms for bit positions of 0 will be enabled. The enabled alarm outputs returned by this function is the negated value of the the data read from the Configuration Register 1. Upper 16 bits of return value are valid only if the channel selected is PS. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acd26481ffd9f4c26a41779246aa2cf8a">XSYSMONPSU_CFG_REG1_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a708bc2465a24743784ce6119bc05b10a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XSysMonPsu_GetAlarmThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>AlarmThrReg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the contents of the specified Alarm Threshold Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">AlarmThrReg</td><td>is the index of an Alarm Threshold Register to be read. Use XSM_ATR_* constants defined in <a class="el" href="xsysmonpsu_8h.html" title="The XSysMon driver supports the Xilinx System Monitor device. ">xsysmonpsu.h</a> to specify the index. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 16-bit value representing the contents of the selected Alarm Threshold Register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a9cd13eee75fe9d48b9d004652cb12e1f">XSM_ATR_SUP7_LOWER</a>, <a class="el" href="xsysmonpsu_8h.html#a9b816bc88f59e9b497fa66f336babd99">XSM_ATR_TEMP_RMTE_LOWER</a>, <a class="el" href="xsysmonpsu_8h.html#ad1eb3b0945f7c93a178c67fe0bb66d9f">XSM_ATR_TEMP_RMTE_UPPER</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a531009f056913bfecb5b591d9f91385c">XSYSMONPSU_ALRM_TEMP_UPR_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a39d8d59cc35fe4151b51b5bbafdca2ca">XSysMonPsu_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="a78d99a653ec8c8089e8cdc9e4f400dc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XSysMonPsu_GetAvg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the number of samples of averaging configured for all the channels in the Configuration Register 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The averaging read from the Configuration Register 0 is returned. Use the XSM_AVG_* bit definitions defined in <a class="el" href="xsysmonpsu_8h.html" title="The XSysMon driver supports the Xilinx System Monitor device. ">xsysmonpsu.h</a> file to interpret the returned value :<ul>
<li>XSM_AVG_0_SAMPLES means no averaging</li>
<li>XSM_AVG_16_SAMPLES means 16 samples of averaging</li>
<li>XSM_AVG_64_SAMPLES means 64 samples of averaging</li>
<li>XSM_AVG_256_SAMPLES means 256 samples of averaging</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acc78e04e37a1d847fc610a978356adc1">XSYSMONPSU_CFG_REG0_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="af83bb4ad116f2bb1ea7676050bd74b6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XSysMonPsu_GetCalibCoefficient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>CoeffType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the calibration coefficient data for the specified parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">CoeffType</td><td>specifies the calibration coefficient to be read. Use XSM_CALIB_* constants defined in <a class="el" href="xsysmonpsu_8h.html" title="The XSysMon driver supports the Xilinx System Monitor device. ">xsysmonpsu.h</a> to specify the calibration coefficient to be read. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 16-bit value representing the calibration coefficient. The System Monitor device guarantees a 10 bit resolution for the ADC converted data and data is the 10 MSB bits of the 16 data read from the device.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a173a9675e7f812b837aab6cf61457b6d">XSM_CALIB_GAIN_ERROR_COEFF</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a2177cbc8b73be4ce1c76ba03c674e5d6">XSYSMONPSU_CAL_SUP_OFF_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a5e3ad732967594b6cc1cc314e24ae9b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSysMonPsu_GetExtenalMux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function returns the external mux channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the channel number used to connect to the external Mux. The valid channels are 0 to 6, 8 to 16, and 31 to 36..</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acc78e04e37a1d847fc610a978356adc1">XSYSMONPSU_CFG_REG0_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="aa4312c89ab0280cd7df2de940193fe32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XSysMonPsu_GetMinMaxMeasurement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>MeasurementType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads the Minimum/Maximum measurement for one of the XSM_MIN_* or XSM_MAX_* constants defined in <a class="el" href="xsysmonpsu_8h.html" title="The XSysMon driver supports the Xilinx System Monitor device. ">xsysmonpsu.h</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">MeasurementType</td><td>specifies the parameter for which the Minimum/Maximum measurement has to be read. Use XSM_MAX_* and XSM_MIN_* constants defined in <a class="el" href="xsysmonpsu_8h.html" title="The XSysMon driver supports the Xilinx System Monitor device. ">xsysmonpsu.h</a> to specify the data to be read. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 16-bit value representing the maximum/minimum measurement for specified parameter. The System Monitor device guarantees a 10 bit resolution for the ADC converted data and data is the 10 MSB bits of 16 bit data read from the device. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a9e519a87a8d9330083e59826065eb259">XSM_MAX_SUPPLY6</a>, <a class="el" href="xsysmonpsu_8h.html#aa21e53b8ba182fbe4481563ed3edc772">XSM_MAX_SUPPLY7</a>, <a class="el" href="xsysmonpsu_8h.html#acf402d972e5855885a587779aa75f802">XSM_MAX_TEMP_REMOTE</a>, <a class="el" href="xsysmonpsu_8h.html#a92681353913a769554b3a03f0a614bcb">XSM_MIN_SUPPLY4</a>, <a class="el" href="xsysmonpsu_8h.html#af309384ae3efb40dd11f11a5e7170671">XSM_MIN_SUPPLY6</a>, <a class="el" href="xsysmonpsu_8h.html#aec0f9f1e8ad9a98083f6e399a2d8b5e5">XSM_MIN_SUPPLY7</a>, <a class="el" href="xsysmonpsu_8h.html#acd364c7df27909c07ca9df995f4c0af7">XSM_MIN_TEMP_REMOTE</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="ad9f2fde294e151e5db65822b26f11a4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSysMonPsu_GetMonitorStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the AMS monitor status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the monitor status. See XSYSMONPSU_MON_STS_*_MASK definations present in <a class="el" href="xsysmonpsu__hw_8h.html" title="This header file contains the identifiers and basic driver functions (or macros) that can be used to ...">xsysmonpsu_hw.h</a> for knowing the status.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None</dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a621f41dbdff59725822f0dc2f29ac1e8">XSYSMONPSU_MON_STS_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a8261ca6ec1564b9066f858adbd81a85f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XSysMonPsu_GetSeqAcqTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the status of acquisition time from the ADC Channel Acquisition Time Sequencer Registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The acquisition time for all the channels. Use XSYSMONPSU_SEQ_ACQ* defined in <a class="el" href="xsysmonpsu__hw_8h.html" title="This header file contains the identifiers and basic driver functions (or macros) that can be used to ...">xsysmonpsu_hw.h</a> to interpret the Channel numbers. Bit masks of 1 are the channels for which acquisition cycles are extended and bit mask of 0 are the channels for which acquisition cycles are not extended.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a579ce307d7e8b3d85718b47dbeaa48a2">XSYSMONPSU_SEQ_ACQ0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a7f5b375d3e31219c17cbb4dc14ae4eec">XSYSMONPSU_SEQ_ACQ1_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a88183705d7e03a3d8eeee6366d09b5f5">XSYSMONPSU_SEQ_ACQ2_OFFSET</a>.</p>

</div>
</div>
<a class="anchor" id="adf0cf3c7c355471f81fe60d663043e7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XSysMonPsu_GetSeqAvgEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the channels for which the averaging has been enabled in the ADC Channel Averaging Enables Sequencer Registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of averaging (enabled/disabled) for all the channels. Use XSYSMONPSU_SEQ_AVERAGE* defined in <a class="el" href="xsysmonpsu__hw_8h.html" title="This header file contains the identifiers and basic driver functions (or macros) that can be used to ...">xsysmonpsu_hw.h</a> to interpret the Channel numbers. Bit masks of 1 are the channels for which averaging is enabled and bit mask of 0 are the channels for averaging is disabled.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a26a83b449c5188602bafa2bfaa24e18c">XSYSMONPSU_SEQ_AVERAGE0_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ac44a549f1306faa4359a6a48ddd17dfd">XSYSMONPSU_SEQ_AVERAGE1_OFFSET</a>.</p>

</div>
</div>
<a class="anchor" id="a08d0525934fbe21b46732c039f93a8b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XSysMonPsu_GetSeqChEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the channel enable bits status from the ADC Channel Selection Sequencer Registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gets the channel enable bits. Use XSYSMONPSU_SEQ_CH* defined in <a class="el" href="xsysmonpsu__hw_8h.html" title="This header file contains the identifiers and basic driver functions (or macros) that can be used to ...">xsysmonpsu_hw.h</a> to interpret the Channel numbers. Bit masks of 1 are the channels that are enabled and bit mask of 0 are the channels that are disabled.</dd>
<dd>
None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, <a class="el" href="xsysmonpsu__hw_8h.html#abf302f7a79ec4d2aee5b9756441ce71d">XSYSMONPSU_SEQ_CH0_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a4c4cf4e1f8965f7095c9a7c58938555f">XSYSMONPSU_SEQ_CH1_OFFSET</a>.</p>

</div>
</div>
<a class="anchor" id="a2e597e2db96739d90195d9ad019377c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XSysMonPsu_GetSeqInputMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the Analog input mode for all the channels from the ADC Channel Analog-Input Mode Sequencer Registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input mode for all the channels. Use XSYSMONPSU_SEQ_INPUT_MDE* defined in <a class="el" href="xsysmonpsu__hw_8h.html" title="This header file contains the identifiers and basic driver functions (or macros) that can be used to ...">xsysmonpsu_hw.h</a> to interpret the Channel numbers. Bit masks of 1 are the channels for which input mode is differential/Bipolar and bit mask of 0 are the channels for which input mode is unipolar.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae709951620a41ee0f994506d3782b3e9">XSYSMONPSU_SEQ_INPUT_MDE0_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#af6c54048b7704171bda202c378d50920">XSYSMONPSU_SEQ_INPUT_MDE1_OFFSET</a>.</p>

</div>
</div>
<a class="anchor" id="a6a0b98e18bb6c2c8b3587e2fe2cffde8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSysMonPsu_GetSequencerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function returns the mode of the sequencer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the Sequencer mode. XSYSMONPSU_EVENT_MODE for Event mode and XSYSMONPSU_CONTINUOUS_MODE for continuous mode.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acc78e04e37a1d847fc610a978356adc1">XSYSMONPSU_CFG_REG0_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a2f2d5053a1406cecd4fa311525f68ce7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XSysMonPsu_GetSequencerMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the channel sequencer mode from the Configuration Register 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The channel sequencer mode :<ul>
<li>XSM_SEQ_MODE_SAFE : Default safe mode</li>
<li>XSM_SEQ_MODE_ONEPASS : One pass through sequence</li>
<li>XSM_SEQ_MODE_CONTINPASS : Continuous channel sequencing</li>
<li>XSM_SEQ_MODE_SINGCHAN : Single channel/Sequencer off</li>
<li>XSM_SEQ_MODE_OLYMPUS : Olympus sampling mode</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acd26481ffd9f4c26a41779246aa2cf8a">XSYSMONPSU_CFG_REG1_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#acfe5ce3d9e15f0bebdab313decf9729c">XSysMonPsu_SetSeqAcqTime()</a>, <a class="el" href="xsysmonpsu_8h.html#adb114566387fa8889b913f34a7de6010">XSysMonPsu_SetSeqAvgEnables()</a>, <a class="el" href="xsysmonpsu_8h.html#ac51295c525a507a8f334c97f02a84221">XSysMonPsu_SetSeqChEnables()</a>, <a class="el" href="xsysmonpsu_8h.html#ae6b751279110ca4a05073ae8a9b8a1a8">XSysMonPsu_SetSeqInputMode()</a>, and <a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e1841bc7888195dd3f9381947e4f8d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSysMonPsu_GetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads the contents of the Status Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit value representing the contents of the Status Register. Use the XSYSMONPSU_MON_STS_* constants defined in <a class="el" href="xsysmonpsu__hw_8h.html" title="This header file contains the identifiers and basic driver functions (or macros) that can be used to ...">xsysmonpsu_hw.h</a> to interpret the returned value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a621f41dbdff59725822f0dc2f29ac1e8">XSYSMONPSU_MON_STS_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a7c41996bf95cd7119dba302246345a9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_IntrClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears the specified interrupts in the Interrupt Status Register (ISR). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the 64 bit-mask of the interrupts to be cleared. Bit positions of 1 will be cleared. Bit positions of 0 will not change the previous interrupt status. This mask is formed by OR'ing the XSYSMONPSU_ISR_0_* and XSYSMONPSU_ISR_1_* bits which are defined in <a class="el" href="xsysmonpsu__hw_8h.html" title="This header file contains the identifiers and basic driver functions (or macros) that can be used to ...">xsysmonpsu_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a83ea9d678f45ad885e86555b51d308cd">XSYSMONPSU_ISR_0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a4f60260a330cb9d25d5ff40a293442c5">XSYSMONPSU_ISR_1_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a95f581ea48eb8d57c2fab2dcaefdeccd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_IntrDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disables the specified interrupts in the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the 64 bit-mask of the interrupts to be disabled. Bit positions of 1 will be disabled. Bit positions of 0 will keep the previous setting. This mask is formed by OR'ing XSYSMONPSU_IDR_0_* and XSYSMONPSU_IDR_1_* bits defined in <a class="el" href="xsysmonpsu__hw_8h.html" title="This header file contains the identifiers and basic driver functions (or macros) that can be used to ...">xsysmonpsu_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#aa5fe21686201b6560cc6e5745371e4e5">XSYSMONPSU_IDR_0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#aa47d1e0081286ed2c4afba303e81ff81">XSYSMONPSU_IDR_1_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a97be122426bd5302e93b45ba5a3fc8ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_IntrEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the specified interrupts in the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the 64 bit-mask of the interrupts to be enabled. Bit positions of 1 will be enabled. Bit positions of 0 will keep the previous setting. This mask is formed by OR'ing XSYSMONPSU_IER_0_* and XSYSMONPSU_IER_1_* bits defined in <a class="el" href="xsysmonpsu__hw_8h.html" title="This header file contains the identifiers and basic driver functions (or macros) that can be used to ...">xsysmonpsu_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ac651706d7049befe6bcade8d0bf057fc">XSYSMONPSU_IER_0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ab7f6d9bc9435dc7fb5d7eb1876745d77">XSYSMONPSU_IER_1_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a78b39afe5e1c62f44a320311d74e2402"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XSysMonPsu_IntrGetEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the enabled interrupts read from the Interrupt Enable Register (IER). </p>
<p>Use the XSYSMONPSU_IER_0_* and XSYSMONPSU_IER_1_* constants defined in <a class="el" href="xsysmonpsu__hw_8h.html" title="This header file contains the identifiers and basic driver functions (or macros) that can be used to ...">xsysmonpsu_hw.h</a> to interpret the returned value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 64-bit value representing the contents of the Interrupt Mask Registers (IMR1 IMR0).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a5e842a49b82a192506f90c1223dd2464">XSYSMONPSU_IMR_0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a9ecf8b14de802966a7dced05b4335e00">XSYSMONPSU_IMR_1_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a3ef44a74426b13480363747a5dedc5d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XSysMonPsu_IntrGetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the interrupt status read from Interrupt Status Register(ISR). </p>
<p>Use the XSYSMONPSU_ISR_0_* and XSYSMONPSU_ISR_1_ constants defined in <a class="el" href="xsysmonpsu__hw_8h.html" title="This header file contains the identifiers and basic driver functions (or macros) that can be used to ...">xsysmonpsu_hw.h</a> to interpret the returned value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 64-bit value representing the contents of the Interrupt Status Registers (ISR1 ISR0).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a83ea9d678f45ad885e86555b51d308cd">XSYSMONPSU_ISR_0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a4f60260a330cb9d25d5ff40a293442c5">XSYSMONPSU_ISR_1_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a948f08280b6195869015382d92ba8a50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_sys_mon_psu___config.html">XSysMonPsu_Config</a>* XSysMonPsu_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>DeviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function looks for the device configuration based on the unique device ID. </p>
<p>The table XSysmonPsu_ConfigTable[] contains the configuration information for each device in the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceId</td><td>is the unique device ID of the device being looked up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the configuration table entry corresponding to the given device ID, or NULL if no match is found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6fc9daa41e50955a71e2fe7a107a0e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function resets the SystemMonitor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Upon reset, all Maximum and Minimum status registers will be reset to their default values. Currently running and any averaging will restart. Refer to the device data sheet for the device status and register values after the reset. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a69b79177a69bce2ea1055e2b969a9f57">XSYSMONPSU_VP_VN_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a8cd0584410c0931f931aa4da1e3e151b">XSysMonPsu_CfgInitialize()</a>, and <a class="el" href="xsysmonpsu_8h.html#a39d8d59cc35fe4151b51b5bbafdca2ca">XSysMonPsu_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="a39d8d59cc35fe4151b51b5bbafdca2ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSysMonPsu_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a self-test on the driver/device. </p>
<p>The test</p><ul>
<li>Resets the device,</li>
<li>Writes a value into the Alarm Threshold register and reads it back for comparison.</li>
<li>Resets the device again.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the value read from the Alarm Threshold register is the same as the value written.</li>
<li>XST_FAILURE Otherwise</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a destructive test in that resets of the device are performed. Refer to the device specification for the device status after the reset operation. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a220ecdeca017ceb88fcb61fcc0f20253">XSM_ATR_SUP1_UPPER</a>, <a class="el" href="xsysmonpsu_8c.html#a708bc2465a24743784ce6119bc05b10a">XSysMonPsu_GetAlarmThreshold()</a>, <a class="el" href="xsysmonpsu_8c.html#ad6fc9daa41e50955a71e2fe7a107a0e5">XSysMonPsu_Reset()</a>, and <a class="el" href="xsysmonpsu_8c.html#a6d436ab807a561d70339cdfe52f6f560">XSysMonPsu_SetAlarmThreshold()</a>.</p>

</div>
</div>
<a class="anchor" id="a11e8fc0b9dffbe33b41ec4e6825ffc4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetAdcClkDivisor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Divisor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function sets the frequency of the ADCCLK by configuring the DCLK to ADCCLK ratio in the Configuration Register #2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">Divisor</td><td>is clock divisor used to derive ADCCLK from DCLK. Valid values of the divisor are PS:<ul>
<li>0 means divide by 8.</li>
<li>1,2 means divide by 2.</li>
<li>3 to 255 means divide by that value. PL:</li>
<li>0,1,2 means divide by 2.</li>
<li>3 to 255 means divide by that value. Refer to the device specification for more details. </li>
</ul>
</td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>- The ADCCLK is an internal clock used by the ADC and is synchronized to the DCLK clock. The ADCCLK is equal to DCLK divided by the user selection in the Configuration Register 2.<ul>
<li>There is no Assert on the minimum value of the Divisor. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a5a77bafe25ef83d49e8091cbe661d974">XSYSMONPSU_CFG_REG2_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a3ce8ca01b6992994737213f342847662"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetAlarmEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>AlmEnableMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the alarm outputs for the specified alarms in the Configuration Registers 1: </p>
<ul>
<li>OT for Over Temperature (XSYSMONPSU_CFR_REG1_ALRM_OT_MASK)</li>
<li>ALM0 for On board Temperature (XSYSMONPSU_CFR_REG1_ALRM_TEMP_MASK)</li>
<li>ALM1 for SUPPLY1 (XSYSMONPSU_CFR_REG1_ALRM_SUPPLY1_MASK)</li>
<li>ALM2 for SUPPLY2 (XSYSMONPSU_CFR_REG1_ALRM_SUPPLY2_MASK)<ul>
<li>ALM3 for SUPPLY3 (XSYSMONPSU_CFR_REG1_ALRM_SUPPLY3_MASK)</li>
<li>ALM4 for SUPPLY4 (XSYSMONPSU_CFR_REG1_ALRM__SUPPLY4_MASK)</li>
</ul>
</li>
<li>ALM5 for SUPPLY5 (XSYSMONPSU_CFR_REG1_ALRM_SUPPLY5_MASK)<ul>
<li>ALM6 for SUPPLY6 (XSYSMONPSU_CFR_REG1_ALRM_SUPPLY6_MASK)</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">AlmEnableMask</td><td>is the bit-mask of the alarm outputs to be enabled in the Configuration Registers 1 and 3. Bit positions of 1 will be enabled. Bit positions of 0 will be disabled. This mask is formed by OR'ing XSYSMONPSU_CFR_REG1_ALRM_*_MASK masks defined in <a class="el" href="xsysmonpsu_8h.html" title="The XSysMon driver supports the Xilinx System Monitor device. ">xsysmonpsu.h</a>, but XSM_CFR_ALM_SUPPLY8_MASK to XSM_CFR_ALM_SUPPLY13_MASK are applicable only for PS. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The implementation of the alarm enables in the Configuration register 1 is such that the alarms for bit positions of 0 will be enabled and alarms for bit positions of 1 will be disabled. The alarm outputs specified by the AlmEnableMask are negated before writing to the Configuration Register 1 because it was Disable register bits. Upper 16 bits of AlmEnableMask are applicable only for PS. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acd26481ffd9f4c26a41779246aa2cf8a">XSYSMONPSU_CFG_REG1_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a6d436ab807a561d70339cdfe52f6f560"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetAlarmThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>AlarmThrReg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions sets the contents of the given Alarm Threshold Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">AlarmThrReg</td><td>is the index of an Alarm Threshold Register to be set. Use XSM_ATR_* constants defined in <a class="el" href="xsysmonpsu_8h.html" title="The XSysMon driver supports the Xilinx System Monitor device. ">xsysmonpsu.h</a> to specify the index. </td></tr>
    <tr><td class="paramname">Value</td><td>is the 16-bit threshold value to write into the register. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a9cd13eee75fe9d48b9d004652cb12e1f">XSM_ATR_SUP7_LOWER</a>, <a class="el" href="xsysmonpsu_8h.html#a9b816bc88f59e9b497fa66f336babd99">XSM_ATR_TEMP_RMTE_LOWER</a>, <a class="el" href="xsysmonpsu_8h.html#ad1eb3b0945f7c93a178c67fe0bb66d9f">XSM_ATR_TEMP_RMTE_UPPER</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a531009f056913bfecb5b591d9f91385c">XSYSMONPSU_ALRM_TEMP_UPR_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a39d8d59cc35fe4151b51b5bbafdca2ca">XSysMonPsu_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="a711d9441ecb7c36f22b11f941d7f994b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetAvg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Average</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the number of samples of averaging that is to be done for all the channels in both the single channel mode and sequence mode of operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">Average</td><td>is the number of samples of averaging programmed to the Configuration Register 0. Use the XSM_AVG_* definitions defined in <a class="el" href="xsysmonpsu_8h.html" title="The XSysMon driver supports the Xilinx System Monitor device. ">xsysmonpsu.h</a> file :<ul>
<li>XSM_AVG_0_SAMPLES for no averaging</li>
<li>XSM_AVG_16_SAMPLES for 16 samples of averaging</li>
<li>XSM_AVG_64_SAMPLES for 64 samples of averaging</li>
<li>XSM_AVG_256_SAMPLES for 256 samples of averaging </li>
</ul>
</td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a2bcf68b01a8ff59237bea9b303828e4f">XSM_AVG_256_SAMPLES</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acc78e04e37a1d847fc610a978356adc1">XSYSMONPSU_CFG_REG0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="ab4903002cdddf192acdcda4827e5b1a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetExtenalMux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function enables the external mux and connects a channel to the mux. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">Channel</td><td>is the channel number used to connect to the external Mux. The valid channels are 0 to 5 and 16 to 31. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the Configuration Register 0.</li>
<li>XST_FAILURE if the channel sequencer is enabled or the input parameters are not valid for the selected channel.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#ae8c007df4d1c481557120435619b4ff5">XSM_CH_AUX_MAX</a>, <a class="el" href="xsysmonpsu_8h.html#a41aa90146d4e0786b8d36888e44aac34">XSM_CH_AUX_MIN</a>, <a class="el" href="xsysmonpsu_8h.html#a120bab2a7a97a74da70eef07204728fb">XSM_CH_VREFN</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acc78e04e37a1d847fc610a978356adc1">XSYSMONPSU_CFG_REG0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a118f51203c23bf2ed1f76d154e46ad3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetPSAutoConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the conversion to be automatic for PS SysMon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In the auto-trigger mode, sample rate is of 1 Million samples. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a5652827d8f6d892c11c0a1a5aa03217d">XSYSMONPSU_PS_SYSMON_CSTS_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="acfe5ce3d9e15f0bebdab313decf9729c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSysMonPsu_SetSeqAcqTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>AcqCyclesChMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the number of Acquisition cycles in the ADC Channel Acquisition Time Sequencer Registers. </p>
<p>The sequencer must be in the Safe Mode before writing to these registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">AcqCyclesChMask</td><td>is the bit mask of all the channels for which the number of acquisition cycles is to be extended. Use XSYSMONPSU_SEQ_ACQ* defined in <a class="el" href="xsysmonpsu__hw_8h.html" title="This header file contains the identifiers and basic driver functions (or macros) that can be used to ...">xsysmonpsu_hw.h</a> to specify the Channel numbers. Acquisition cycles will be extended to 10 ADCCLK cycles for bit masks of 1 and will be the default 4 ADCCLK cycles for bit masks of 0. The AcqCyclesChMask is a 64 bit mask that is written to the three 16 bit ADC Channel Acquisition Time Sequencer Registers. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the Channel Sequencer Registers.</li>
<li>XST_FAILURE if the channel sequencer is enabled.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a223c74befcd8a6710ea7a7acbaf41636">XSM_SEQ_MODE_SAFE</a>, <a class="el" href="xsysmonpsu_8c.html#a2f2d5053a1406cecd4fa311525f68ce7">XSysMonPsu_GetSequencerMode()</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a579ce307d7e8b3d85718b47dbeaa48a2">XSYSMONPSU_SEQ_ACQ0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a7f5b375d3e31219c17cbb4dc14ae4eec">XSYSMONPSU_SEQ_ACQ1_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a88183705d7e03a3d8eeee6366d09b5f5">XSYSMONPSU_SEQ_ACQ2_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="adb114566387fa8889b913f34a7de6010"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSysMonPsu_SetSeqAvgEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>AvgEnableChMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the averaging for the specified channels in the ADC Channel Averaging Enable Sequencer Registers. </p>
<p>The sequencer must be in the Safe Mode before writing to these registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">AvgEnableChMask</td><td>is the bit mask of all the channels for which averaging is to be enabled. Use XSYSMONPSU_SEQ_AVERAGE* defined in <a class="el" href="xsysmonpsu__hw_8h.html" title="This header file contains the identifiers and basic driver functions (or macros) that can be used to ...">xsysmonpsu_hw.h</a> to specify the Channel numbers. Averaging will be enabled for bit masks of 1 and disabled for bit mask of 0. The AvgEnableChMask is a 64 bit mask that is written to the three 16 bit ADC Channel Averaging Enable Sequencer Registers. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the ADC Channel Averaging Enables Sequencer Registers.</li>
<li>XST_FAILURE if the channel sequencer is enabled.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a223c74befcd8a6710ea7a7acbaf41636">XSM_SEQ_MODE_SAFE</a>, <a class="el" href="xsysmonpsu_8c.html#a2f2d5053a1406cecd4fa311525f68ce7">XSysMonPsu_GetSequencerMode()</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a26a83b449c5188602bafa2bfaa24e18c">XSYSMONPSU_SEQ_AVERAGE0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ac44a549f1306faa4359a6a48ddd17dfd">XSYSMONPSU_SEQ_AVERAGE1_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="ac51295c525a507a8f334c97f02a84221"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSysMonPsu_SetSeqChEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>ChEnableMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the specified channels in the ADC Channel Selection Sequencer Registers. </p>
<p>The sequencer must be in the Safe Mode before writing to these registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">ChEnableMask</td><td>is the bit mask of all the channels to be enabled. Use XSYSMONPSU_SEQ_CH* defined in xsysmon_hw.h to specify the Channel numbers. Bit masks of 1 will be enabled and bit mask of 0 will be disabled. The ChEnableMask is a 64 bit mask that is written to the three 16 bit ADC Channel Selection Sequencer Registers. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the ADC Channel Selection Sequencer Registers.</li>
<li>XST_FAILURE if the channel sequencer is enabled.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a223c74befcd8a6710ea7a7acbaf41636">XSM_SEQ_MODE_SAFE</a>, <a class="el" href="xsysmonpsu_8c.html#a2f2d5053a1406cecd4fa311525f68ce7">XSysMonPsu_GetSequencerMode()</a>, <a class="el" href="xsysmonpsu__hw_8h.html#abf302f7a79ec4d2aee5b9756441ce71d">XSYSMONPSU_SEQ_CH0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a4c4cf4e1f8965f7095c9a7c58938555f">XSYSMONPSU_SEQ_CH1_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="ae6b751279110ca4a05073ae8a9b8a1a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSysMonPsu_SetSeqInputMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>InputModeChMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the Analog input mode for the specified channels in the ADC Channel Analog-Input Mode Sequencer Registers. </p>
<p>The sequencer must be in the Safe Mode before writing to these registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">InputModeChMask</td><td>is the bit mask of all the channels for which the input mode is differential mode. Use XSYSMONPSU_SEQ_INPUT_MDE* defined in <a class="el" href="xsysmonpsu__hw_8h.html" title="This header file contains the identifiers and basic driver functions (or macros) that can be used to ...">xsysmonpsu_hw.h</a> to specify the channel numbers. Differential or Bipolar input mode will be set for bit masks of 1 and unipolar input mode for bit masks of 0. The InputModeChMask is a 64 bit mask that is written to the three 16 bit ADC Channel Analog-Input Mode Sequencer Registers. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the ADC Channel Analog-Input Mode Sequencer Registers.</li>
<li>XST_FAILURE if the channel sequencer is enabled.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a223c74befcd8a6710ea7a7acbaf41636">XSM_SEQ_MODE_SAFE</a>, <a class="el" href="xsysmonpsu_8c.html#a2f2d5053a1406cecd4fa311525f68ce7">XSysMonPsu_GetSequencerMode()</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae709951620a41ee0f994506d3782b3e9">XSYSMONPSU_SEQ_INPUT_MDE0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#af6c54048b7704171bda202c378d50920">XSYSMONPSU_SEQ_INPUT_MDE1_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a193dbc689e9a668ef7f548920706b2a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetSequencerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>IsEventMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function enables the Event mode or Continuous mode in the sequencer mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">IsEventMode</td><td>is a boolean parameter that specifies continuous sampling (specify FALSE) or event driven sampling mode (specify TRUE) for the channel. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acc78e04e37a1d847fc610a978356adc1">XSYSMONPSU_CFG_REG0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="aa4bdb4e555b2c8d47a0185862c9cb4c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetSequencerMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>SequencerMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the specified Channel Sequencer Mode in the Configuration Register 1 : </p>
<ul>
<li>Default safe mode (XSM_SEQ_MODE_SAFE)</li>
<li>One pass through sequence (XSM_SEQ_MODE_ONEPASS)</li>
<li>Continuous channel sequencing (XSM_SEQ_MODE_CONTINPASS)</li>
<li>Single Channel/Sequencer off (XSM_SEQ_MODE_SINGCHAN)</li>
<li>Olympus sampling mode (XSM_SEQ_MODE_OYLMPUS)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SequencerMode</td><td>is the sequencer mode to be set. Use XSM_SEQ_MODE_* bits defined in <a class="el" href="xsysmonpsu_8h.html" title="The XSysMon driver supports the Xilinx System Monitor device. ">xsysmonpsu.h</a>. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only one of the modes can be enabled at a time. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a9fadcdd4e89cd9d96581f81dfe47dce7">XSM_SEQ_MODE_OYLMPUS</a>, <a class="el" href="xsysmonpsu_8h.html#a3c4487fa8b08f41c807433ef456abc75">XSM_SEQ_MODE_SINGCHAN</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acd26481ffd9f4c26a41779246aa2cf8a">XSYSMONPSU_CFG_REG1_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a872e9a41818489e77fa554dd01408281"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSysMonPsu_SetSingleChParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>IncreaseAcqCycles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>IsEventMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>IsDifferentialMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function sets the given parameters in the Configuration Register 0 in the single channel mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">Channel</td><td>is the channel number for conversion. The valid channels are 0 - 6, 8 - 10, 13 - 37. </td></tr>
    <tr><td class="paramname">IncreaseAcqCycles</td><td>is a boolean parameter which specifies whether the Acquisition time for the external channels has to be increased to 10 ADCCLK cycles (specify TRUE) or remain at the default 4 ADCCLK cycles (specify FALSE). This parameter is only valid for the external channels. </td></tr>
    <tr><td class="paramname">IsEventMode</td><td>is a boolean parameter that specifies continuous sampling (specify FALSE) or event driven sampling mode (specify TRUE) for the given channel. </td></tr>
    <tr><td class="paramname">IsDifferentialMode</td><td>is a boolean parameter which specifies unipolar(specify FALSE) or differential mode (specify TRUE) for the analog inputs. The input mode is only valid for the external channels. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the Configuration Register 0.</li>
<li>XST_FAILURE if the channel sequencer is enabled or the input parameters are not valid for the selected channel.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The number of samples for the averaging for all the channels is set by using the function XSysMonPsu_SetAvg.</li>
<li>The calibration of the device is done by doing a ADC conversion on the calibration channel(channel 8). The input parameters IncreaseAcqCycles, IsDifferentialMode and IsEventMode are not valid for this channel. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#ae8c007df4d1c481557120435619b4ff5">XSM_CH_AUX_MAX</a>, <a class="el" href="xsysmonpsu_8h.html#a41aa90146d4e0786b8d36888e44aac34">XSM_CH_AUX_MIN</a>, <a class="el" href="xsysmonpsu_8h.html#a15ea4b9f08ee9dc44fc000384ca36e42">XSM_CH_GAINERR_CALIB</a>, <a class="el" href="xsysmonpsu_8h.html#a7c4df26dc69ef41921c484fd3ccc006c">XSM_CH_SUPPLY3</a>, <a class="el" href="xsysmonpsu_8h.html#a2939dda6d5c6efbcf10977c6b33aa7fb">XSM_CH_SUPPLY4</a>, <a class="el" href="xsysmonpsu_8h.html#a3fdb14478def5283880cd4d65dfaf56f">XSM_CH_SUPPLY_CALIB</a>, <a class="el" href="xsysmonpsu_8h.html#ace8eebd74607658044e98c7b5ca1c0c6">XSM_CH_TEMP_REMTE</a>, <a class="el" href="xsysmonpsu_8h.html#af9c81d9f5fa3d80cad2b374c84117840">XSM_CH_VPVN</a>, <a class="el" href="xsysmonpsu_8h.html#a3c4487fa8b08f41c807433ef456abc75">XSM_SEQ_MODE_SINGCHAN</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acc78e04e37a1d847fc610a978356adc1">XSYSMONPSU_CFG_REG0_OFFSET</a>, <a class="el" href="xsysmonpsu_8c.html#a2f2d5053a1406cecd4fa311525f68ce7">XSysMonPsu_GetSequencerMode()</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a2ed2a9f0fbd1be48dfd71aaeef05174f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_StartAdcConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function starts the ADC conversion in the Single Channel event driven sampling mode. </p>
<p>The EOC bit in Status Register will be set once the conversion is finished. Refer to the device specification for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data. ">XSysMonPsu</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The default state of the CONVST bit is a logic 0. The conversion is started when the CONVST bit is set to 1 from 0. This bit is self-clearing so that the next conversion can be started by setting this bit. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a5652827d8f6d892c11c0a1a5aa03217d">XSYSMONPSU_PS_SYSMON_CSTS_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
</div><!-- contents -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
