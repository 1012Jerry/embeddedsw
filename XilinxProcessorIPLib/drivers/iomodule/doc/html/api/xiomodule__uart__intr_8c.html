<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   xiomodule_uart_intr.c File Reference
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.5 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>xiomodule_uart_intr.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Contains required functions for the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> UART driver interrupt mode. See the xiomodule.h header file for more details on this driver.<p>
This file also contains interrupt-related functions for the UART.<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who  Date     Changes
 ----- ---- -------- -----------------------------------------------
 1.03a sa   10/16/12 First release
 </pre> 
<p>
<code>#include &quot;xil_assert.h&quot;</code><br>
<code>#include &quot;xiomodule.h&quot;</code><br>
<code>#include &quot;<a class="el" href="xiomodule__i_8h.html">xiomodule_i.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="xiomodule__l_8h.html">xiomodule_l.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__uart__intr_8c.html#bb82252be31efd94b0555f2541674084">XIOModule_Send</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 *DataBufferPtr, unsigned int NumBytes)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__uart__intr_8c.html#001cc0563d2c4441ee8a835a28c90b84">XIOModule_Recv</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 *DataBufferPtr, unsigned int NumBytes)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__uart__intr_8c.html#491ff203c8bf88590098838db6f493b0">XIOModule_ResetFifos</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__uart__intr_8c.html#37ea5c393584ce879f4456616673109f">XIOModule_IsSending</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__uart__intr_8c.html#b8e0380a891a8e9c52dcb07877101b43">XIOModule_SendBuffer</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__uart__intr_8c.html#4dba54a59028bb48db0cfe21ec672e61">XIOModule_ReceiveBuffer</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__uart__intr_8c.html#395aed6a41e42aba172cfaa0b2abb0ca">XIOModule_SetRecvHandler</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, XIOModule_Handler FuncPtr, void *CallBackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__uart__intr_8c.html#e07ff17249bb2197243052fc080a2425">XIOModule_SetSendHandler</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, XIOModule_Handler FuncPtr, void *CallBackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__uart__intr_8c.html#b05e9f1e24800485d989c1711a019b76">XIOModule_Uart_InterruptHandler</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__uart__intr_8c.html#83d62bfe31603e9aed26efc58cbe8a27">XIOModule_Uart_DisableInterrupt</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__uart__intr_8c.html#9a466c749aab5b25cd26cac73ee8d555">XIOModule_Uart_EnableInterrupt</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="37ea5c393584ce879f4456616673109f"></a><!-- doxytag: member="xiomodule_uart_intr.c::XIOModule_IsSending" ref="37ea5c393584ce879f4456616673109f" args="(XIOModule *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XIOModule_IsSending           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function determines if the specified UART is sending data. If the transmitter register is not empty, it is sending data.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A value of TRUE if the UART is sending data, otherwise FALSE.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4dba54a59028bb48db0cfe21ec672e61"></a><!-- doxytag: member="xiomodule_uart_intr.c::XIOModule_ReceiveBuffer" ref="4dba54a59028bb48db0cfe21ec672e61" args="(XIOModule *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned int XIOModule_ReceiveBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function receives a buffer that has been previously specified by setting up the instance variables of the instance. This function is designed to be an internal function for the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> component such that it may be called from a shell function that sets up the buffer or from an interrupt handler.<p>
This function will attempt to receive a specified number of bytes of data from the UART and store it into the specified buffer. This function is designed for either polled or interrupt driven modes. It is non-blocking such that it will return if there is no data has already received by the UART.<p>
In a polled mode, this function will only receive as much data as the UART can buffer, either in the receiver or in the FIFO if present and enabled. The application may need to call it repeatedly to receive a buffer. Polled mode is the default mode of operation for the driver.<p>
In interrupt mode, this function will start receiving and then the interrupt handler of the driver will continue until the buffer has been received. A callback function, as specified by the application, will be called to indicate the completion of receiving the buffer or when any receive errors or timeouts occur.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes received.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="001cc0563d2c4441ee8a835a28c90b84"></a><!-- doxytag: member="xiomodule_uart_intr.c::XIOModule_Recv" ref="001cc0563d2c4441ee8a835a28c90b84" args="(XIOModule *InstancePtr, u8 *DataBufferPtr, unsigned int NumBytes)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned int XIOModule_Recv           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>DataBufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>NumBytes</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function will attempt to receive a specified number of bytes of data from the UART and store it into the specified buffer. This function is designed for either polled or interrupt driven modes. It is non-blocking such that it will return if no data has already received by the UART.<p>
In a polled mode, this function will only receive as much data as the UART can buffer in the receiver. The application may need to call it repeatedly to receive a buffer. Polled mode is the default mode of operation for the driver.<p>
In interrupt mode, this function will start receiving and then the interrupt handler of the driver will continue receiving data until the buffer has been received. A callback function, as specified by the application, will be called to indicate the completion of receiving the buffer or when any receive errors or timeouts occur.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DataBufferPtr</em>&nbsp;</td><td>is pointer to buffer for data to be received into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBytes</em>&nbsp;</td><td>is the number of bytes to be received. A value of zero will stop a previous receive operation that is in progress in interrupt mode.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes received.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The number of bytes is not asserted so that this function may be called with a value of zero to stop an operation that is already in progress. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="491ff203c8bf88590098838db6f493b0"></a><!-- doxytag: member="xiomodule_uart_intr.c::XIOModule_ResetFifos" ref="491ff203c8bf88590098838db6f493b0" args="(XIOModule *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XIOModule_ResetFifos           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function does nothing, since the UART doesn't have any FIFOs. It is included for compatibility with the UART Lite driver.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance .</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="bb82252be31efd94b0555f2541674084"></a><!-- doxytag: member="xiomodule_uart_intr.c::XIOModule_Send" ref="bb82252be31efd94b0555f2541674084" args="(XIOModule *InstancePtr, u8 *DataBufferPtr, unsigned int NumBytes)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned int XIOModule_Send           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>DataBufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>NumBytes</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This functions sends the specified buffer of data using the UART in either polled or interrupt driven modes. This function is non-blocking such that it will return before the data has been sent by the UART. If the UART is busy sending data, it will return and indicate zero bytes were sent.<p>
In a polled mode, this function will only send as much data as the UART can buffer in the transmitter. The application may need to call it repeatedly to send a buffer.<p>
In interrupt mode, this function will start sending the specified buffer and then the interrupt handler of the driver will continue sending data until the buffer has been sent. A callback function, as specified by the application, will be called to indicate the completion of sending the buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DataBufferPtr</em>&nbsp;</td><td>is pointer to a buffer of data to be sent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBytes</em>&nbsp;</td><td>contains the number of bytes to be sent. A value of zero will stop a previous send operation that is in progress in interrupt mode. Any data that was already put into the transmit FIFO will be sent.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes actually sent.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The number of bytes is not asserted so that this function may be called with a value of zero to stop an operation that is already in progress. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b8e0380a891a8e9c52dcb07877101b43"></a><!-- doxytag: member="xiomodule_uart_intr.c::XIOModule_SendBuffer" ref="b8e0380a891a8e9c52dcb07877101b43" args="(XIOModule *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned int XIOModule_SendBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function sends a buffer that has been previously specified by setting up the instance variables of the instance. This function is designed to be an internal function for the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> component such that it may be called from a shell function that sets up the buffer or from an interrupt handler.<p>
This function sends the specified buffer of data to the UART in either polled or interrupt driven modes. This function is non-blocking such that it will return before the data has been sent by the UART.<p>
In a polled mode, this function will only send as much data as the UART can buffer in the transmitter. The application may need to call it repeatedly to send a buffer.<p>
In interrupt mode, this function will start sending the specified buffer and then the interrupt handler of the driver will continue until the buffer has been sent. A callback function, as specified by the application, will be called to indicate the completion of sending the buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>NumBytes is the number of bytes actually sent (put into the UART transmitter and/or FIFO).</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="395aed6a41e42aba172cfaa0b2abb0ca"></a><!-- doxytag: member="xiomodule_uart_intr.c::XIOModule_SetRecvHandler" ref="395aed6a41e42aba172cfaa0b2abb0ca" args="(XIOModule *InstancePtr, XIOModule_Handler FuncPtr, void *CallBackRef)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XIOModule_SetRecvHandler           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>XIOModule_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>FuncPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>CallBackRef</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function sets the handler that will be called when an event (interrupt) occurs in the driver for the UART. The purpose of the handler is to allow application specific processing to be performed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FuncPtr</em>&nbsp;</td><td>is the pointer to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the upper layer callback reference passed back when the callback function is invoked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>There is no assert on the CallBackRef since the driver doesn't know what it is (nor should it) </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="e07ff17249bb2197243052fc080a2425"></a><!-- doxytag: member="xiomodule_uart_intr.c::XIOModule_SetSendHandler" ref="e07ff17249bb2197243052fc080a2425" args="(XIOModule *InstancePtr, XIOModule_Handler FuncPtr, void *CallBackRef)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XIOModule_SetSendHandler           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>XIOModule_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>FuncPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>CallBackRef</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function sets the handler that will be called when an event (interrupt) occurs in the driver for the UART. The purpose of the handler is to allow application specific processing to be performed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance . </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FuncPtr</em>&nbsp;</td><td>is the pointer to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the upper layer callback reference passed back when the callback function is invoked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>There is no assert on the CallBackRef since the driver doesn't know what it is (nor should it) </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="83d62bfe31603e9aed26efc58cbe8a27"></a><!-- doxytag: member="xiomodule_uart_intr.c::XIOModule_Uart_DisableInterrupt" ref="83d62bfe31603e9aed26efc58cbe8a27" args="(XIOModule *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XIOModule_Uart_DisableInterrupt           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function disables the UART interrupt. After calling this function, data may still be received by the UART but no interrupt will be generated since the hardware device has no way to disable the receiver.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="9a466c749aab5b25cd26cac73ee8d555"></a><!-- doxytag: member="xiomodule_uart_intr.c::XIOModule_Uart_EnableInterrupt" ref="9a466c749aab5b25cd26cac73ee8d555" args="(XIOModule *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XIOModule_Uart_EnableInterrupt           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function enables the UART interrupts such that an interrupt will occur when data is received or data has been transmitted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b05e9f1e24800485d989c1711a019b76"></a><!-- doxytag: member="xiomodule_uart_intr.c::XIOModule_Uart_InterruptHandler" ref="b05e9f1e24800485d989c1711a019b76" args="(XIOModule *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XIOModule_Uart_InterruptHandler           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function is the interrupt handler for the UART. It must be connected to an interrupt system by the user such that it is called when an interrupt for any UART lite occurs. This function does not save or restore the processor context such that the user must ensure this occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>contains a pointer to the instance of the IOModule that the interrupt is for.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
Copyright @ 1995-2014 Xilinx, Inc. All rights reserved. 
