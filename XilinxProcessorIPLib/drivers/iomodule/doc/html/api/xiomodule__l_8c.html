<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   xiomodule_l.c File Reference
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.5 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>xiomodule_l.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
This file contains low-level driver functions that can be used to access the device. The user should refer to the hardware device specification for more details of the device operation.<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who  Date     Changes
 ----- ---- -------- -------------------------------------------------------
 1.00a sa   07/15/11 First release
 </pre> 
<p>
<code>#include &quot;xparameters.h&quot;</code><br>
<code>#include &quot;xiomodule.h&quot;</code><br>
<code>#include &quot;<a class="el" href="xiomodule__i_8h.html">xiomodule_i.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8c.html#bc7f42962ce2c6b6c12f47993711450f">XIOModule_DeviceInterruptHandler</a> (void *DeviceId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8c.html#e15a900d6ea26b9332df797de678edc4">XIOModule_SetIntrSvcOption</a> (u32 BaseAddress, int Option)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8c.html#05aa3ab689bf9b3d51f0c0b0cd0b0dd9">XIOModule_RegisterHandler</a> (u32 BaseAddress, int InterruptId, XInterruptHandler Handler, void *CallBackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8c.html#918190114cf5f61d4178171fd4f0346a">XIOModule_SendByte</a> (u32 BaseAddress, u8 Data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8c.html#86f12a73608dce123899ab4da3a85e18">XIOModule_RecvByte</a> (u32 BaseAddress)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="bc7f42962ce2c6b6c12f47993711450f"></a><!-- doxytag: member="xiomodule_l.c::XIOModule_DeviceInterruptHandler" ref="bc7f42962ce2c6b6c12f47993711450f" args="(void *DeviceId)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XIOModule_DeviceInterruptHandler           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>DeviceId</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function is the primary interrupt handler for the driver. It must be connected to the interrupt source such that is called when an interrupt of the interrupt controller is active. It will resolve which interrupts are active and enabled and call the appropriate interrupt handler. It uses the AckBeforeService flag in the configuration data to determine when to acknowledge the interrupt. Highest priority interrupts are serviced first. The driver can be configured to service only the highest priority interrupt or all pending interrupts using the {<a class="el" href="xiomodule__options_8c.html#c73caa85a08f6f31a832f6278b18bbc2">XIOModule_SetOptions()</a>} function or the {XIOModule_SetIntrSrvOption()} function.<p>
This function assumes that an interrupt vector table has been previously initialized. It does not verify that entries in the table are valid before calling an interrupt handler, except skipping null handlers that indicate use of fast interrupts where the hardware directly jumps to the handler.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the zero-based device ID defined in xparameters.h of the interrupting interrupt controller. It is used as a direct index into the configuration data, which contains the vector table for the interrupt controller. Note that even though the argument is a void pointer, the value is not a pointer but the actual device ID. The void pointer type is necessary to meet the XInterruptHandler typedef for interrupt handlers.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
The constant XPAR_IOMODULE_MAX_INTR_SIZE must be setup for this to compile. Interrupt IDs range from 0 - 31 and correspond to the interrupt input signals for the interrupt controller. XPAR_IOMODULE_MAX_INTR_SIZE specifies the highest numbered interrupt input signal that is used.     </td>
  </tr>
</table>
<a class="anchor" name="86f12a73608dce123899ab4da3a85e18"></a><!-- doxytag: member="xiomodule_l.c::XIOModule_RecvByte" ref="86f12a73608dce123899ab4da3a85e18" args="(u32 BaseAddress)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u8 XIOModule_RecvByte           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u32&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>BaseAddress</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This functions receives a single byte using the UART. It is blocking in that it waits for the receiver to become non-empty before it reads from the receive register.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the device</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The byte of data received.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="05aa3ab689bf9b3d51f0c0b0cd0b0dd9"></a><!-- doxytag: member="xiomodule_l.c::XIOModule_RegisterHandler" ref="05aa3ab689bf9b3d51f0c0b0cd0b0dd9" args="(u32 BaseAddress, int InterruptId, XInterruptHandler Handler, void *CallBackRef)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XIOModule_RegisterHandler           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u32&nbsp;</td>
          <td class="mdname" nowrap> <em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>InterruptId</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>XInterruptHandler&nbsp;</td>
          <td class="mdname" nowrap> <em>Handler</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>CallBackRef</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a handler function for a specific interrupt ID. The vector table of the interrupt controller is updated, overwriting any previous handler. The handler function will be called when an interrupt occurs for the given interrupt ID.<p>
This function can also be used to remove a handler from the vector table by passing in the XIOModule_DefaultHandler() as the handler and NULL as the callback reference.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the interrupt controller whose vector table will be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InterruptId</em>&nbsp;</td><td>is the interrupt ID to be associated with the input handler. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Handler</em>&nbsp;</td><td>is the function pointer that will be added to the vector table for the given interrupt ID. It adheres to the XInterruptHandler signature found in xbasic_types.h. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the argument that will be passed to the new handler function when it is called. This is user-specific.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Only used with normal interrupt mode. Does not restore normal interrupt mode.</dd></dl>
Note that this function has no effect if the input base address is invalid.     </td>
  </tr>
</table>
<a class="anchor" name="918190114cf5f61d4178171fd4f0346a"></a><!-- doxytag: member="xiomodule_l.c::XIOModule_SendByte" ref="918190114cf5f61d4178171fd4f0346a" args="(u32 BaseAddress, u8 Data)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XIOModule_SendByte           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u32&nbsp;</td>
          <td class="mdname" nowrap> <em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8&nbsp;</td>
          <td class="mdname" nowrap> <em>Data</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This functions sends a single byte using the UART. It is blocking in that it waits for the transmitter to become non-full before it writes the byte to the transmit register.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the device </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is the byte of data to send</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="e15a900d6ea26b9332df797de678edc4"></a><!-- doxytag: member="xiomodule_l.c::XIOModule_SetIntrSvcOption" ref="e15a900d6ea26b9332df797de678edc4" args="(u32 BaseAddress, int Option)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XIOModule_SetIntrSvcOption           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u32&nbsp;</td>
          <td class="mdname" nowrap> <em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Option</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the interrupt service option, which can configure the driver so that it services only a single interrupt at a time when an interrupt occurs, or services all pending interrupts when an interrupt occurs. The default behavior when using the driver interface given in xintc.h file is to service only a single interrupt, whereas the default behavior when using the driver interface given in this file is to service all outstanding interrupts when an interrupt occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the unique identifier for a device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Option</em>&nbsp;</td><td>is XIN_SVC_SGL_ISR_OPTION if you want only a single interrupt serviced when an interrupt occurs, or XIN_SVC_ALL_ISRS_OPTION if you want all pending interrupts serviced when an interrupt occurs.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
Note that this function has no effect if the input base address is invalid.     </td>
  </tr>
</table>
Copyright @ 1995-2014 Xilinx, Inc. All rights reserved. 
