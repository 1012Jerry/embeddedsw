<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   xmbox.c File Reference
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.5 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>xmbox.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Contains required functions for the <a class="el" href="struct_x_mbox.html">XMbox</a> driver.<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who  Date     Changes
 ----- ---- -------- -----------------------------------------------
 1.00a va            First release
 1.00a ecm  06/01/07 Cleanup, new coding standard, check into XCS
 1.01a ecm  08/19/08 Fixed the receive routine, FSL leg, was using SendID
			instead of the correct RecvID.
 			Fixed CRs 466320, 466322, 476535, 476242, 476243
					  new rev
 2.00a hm   04/09/09 Added support for mailbox v2.0, which has interrupts;
			Fixed CR 502464, which removed extra
			definitions that are not associated with
			the interface.
			Fixed the canonical definition so that each
			interface is considered as a device instance.
 3.00a hbm  10/19/09   Migrated to HAL phase 1 to use xil_io.
			Removed _m from the function names.
			Renamed _mIsEmpty to _IsEmptyHw and _mIsFull
			to _IsFullHw.
 3.02a bss  08/18/12   Added XMbox_GetStatus API for CR 676187</pre><p>
<pre> </pre> 
<p>
<code>#include &lt;string.h&gt;</code><br>
<code>#include &quot;xmbox.h&quot;</code><br>
<code>#include &quot;xil_assert.h&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#03167856611920557ccd189ebc9942e4">XMbox_CfgInitialize</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, <a class="el" href="struct_x_mbox___config.html">XMbox_Config</a> *ConfigPtr, u32 EffectiveAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#3a9fc221c6ba749d5d4157f2f7c71400">XMbox_Read</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 *BufferPtr, u32 RequestedBytes, u32 *BytesRecvdPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#50ed591178c351824dd96d676ee23412">XMbox_ReadBlocking</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 *BufferPtr, u32 RequestedBytes)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#3d9b8fdcdbe1a4ba26787aaa2575dab4">XMbox_Write</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 *BufferPtr, u32 RequestedBytes, u32 *BytesSentPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#b643bb1dd7ebdaa7674cb17d63ea7cc4">XMbox_WriteBlocking</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 *BufferPtr, u32 RequestedBytes)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#2944a536e30ffa972cccfb6629944e14">XMbox_IsEmpty</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#0033b5fdf52a30afa9bf44d804aab0c5">XMbox_IsFull</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#bb4866d110cafc17ae2f796d67555342">XMbox_Flush</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#c460a83470911ffe10ef8acf0e5e4745">XMbox_SetInterruptEnable</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 Mask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#86189b15b3be4d88b99c201f9afefaa6">XMbox_GetInterruptEnable</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#5238e5e07452d1f67fd73872aa68829a">XMbox_GetInterruptStatus</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#071b085ea3599cd6a1fb60acd270304e">XMbox_ClearInterrupt</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 Mask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#6981f31c1911a95bf94b3e2608e3febe">XMbox_SetSendThreshold</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 Value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#faaa97b523bfc0e4f88b53d0fab3e30b">XMbox_SetReceiveThreshold</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 Value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#2eb8e80874c451ea3bc857131e69fcf9">XMbox_GetStatus</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="03167856611920557ccd189ebc9942e4"></a><!-- doxytag: member="xmbox.c::XMbox_CfgInitialize" ref="03167856611920557ccd189ebc9942e4" args="(XMbox *InstancePtr, XMbox_Config *ConfigPtr, u32 EffectiveAddress)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XMbox_CfgInitialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct_x_mbox___config.html">XMbox_Config</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>EffectiveAddress</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializes a specific mailbox.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html">XMbox</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CfgPtr</em>&nbsp;</td><td>is the device configuration structure containing required HW build data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the Physical address of the hardware in a Virtual Memory operating system environment. It is the Base Address in a stand alone environment.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if initialization was successful</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="071b085ea3599cd6a1fb60acd270304e"></a><!-- doxytag: member="xmbox.c::XMbox_ClearInterrupt" ref="071b085ea3599cd6a1fb60acd270304e" args="(XMbox *InstancePtr, u32 Mask)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XMbox_ClearInterrupt           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Mask</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clears pending interrupts with the provided mask. This function should be called after the software has serviced the interrupts that are pending. This function clears the corresponding bits of the Interrupt Status Register. This function can only be used for Non-FSL interface. If not, the function will fail in an assert.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is a logical OR of XMB_IX_* constants found in <a class="el" href="xmbox__hw_8h.html">xmbox_hw.h</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="bb4866d110cafc17ae2f796d67555342"></a><!-- doxytag: member="xmbox.c::XMbox_Flush" ref="bb4866d110cafc17ae2f796d67555342" args="(XMbox *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XMbox_Flush           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Resets the mailbox FIFOs by empting the READ FIFO and making sure the Error Status is zero.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html">XMbox</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS on success.</li><li>XST_FAILURE if there are any outstanding errors.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Data from read FIFO is thrown away. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="86189b15b3be4d88b99c201f9afefaa6"></a><!-- doxytag: member="xmbox.c::XMbox_GetInterruptEnable" ref="86189b15b3be4d88b99c201f9afefaa6" args="(XMbox *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u32 XMbox_GetInterruptEnable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the interrupt enable for the mailbox. AND the result of this function with XMB_IX_* to determine which interrupts of this mailbox are enabled. This function can only be used for Non-FSL interface. If not, the function will fail in an assert.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Mask of interrupt bits made up of XMB_IX_* constants found in <a class="el" href="xmbox__hw_8h.html">xmbox_hw.h</a>.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5238e5e07452d1f67fd73872aa68829a"></a><!-- doxytag: member="xmbox.c::XMbox_GetInterruptStatus" ref="5238e5e07452d1f67fd73872aa68829a" args="(XMbox *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u32 XMbox_GetInterruptStatus           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve the interrupt status for the mailbox. AND the results of this function with XMB_IX_* to determine which interrupts are currently pending to the processor. This function can only be used for Non-FSL interface. If not, the function will fail in an assert.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Mask of interrupt bits made up of XMB_IX_* constants found in <a class="el" href="xmbox__hw_8h.html">xmbox_hw.h</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="2eb8e80874c451ea3bc857131e69fcf9"></a><!-- doxytag: member="xmbox.c::XMbox_GetStatus" ref="2eb8e80874c451ea3bc857131e69fcf9" args="(XMbox *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u32 XMbox_GetStatus           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns Status register contents. This function can only be used for Non-FSL interface. If not, the function will fail in an assert. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Value returns Status Register contents.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="2944a536e30ffa972cccfb6629944e14"></a><!-- doxytag: member="xmbox.c::XMbox_IsEmpty" ref="2944a536e30ffa972cccfb6629944e14" args="(XMbox *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u32 XMbox_IsEmpty           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks to see if there is data available to be read.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html">XMbox</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>FALSE if there is data to be read.</li><li>TRUE is there no data to be read.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="0033b5fdf52a30afa9bf44d804aab0c5"></a><!-- doxytag: member="xmbox.c::XMbox_IsFull" ref="0033b5fdf52a30afa9bf44d804aab0c5" args="(XMbox *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u32 XMbox_IsFull           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks to see if there is room in the write FIFO.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html">XMbox</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>FALSE if there is room in write FIFO.</li><li>TRUE if there is room in write FIFO.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="3a9fc221c6ba749d5d4157f2f7c71400"></a><!-- doxytag: member="xmbox.c::XMbox_Read" ref="3a9fc221c6ba749d5d4157f2f7c71400" args="(XMbox *InstancePtr, u32 *BufferPtr, u32 RequestedBytes, u32 *BytesRecvdPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XMbox_Read           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32 *&nbsp;</td>
          <td class="mdname" nowrap> <em>BufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>RequestedBytes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32 *&nbsp;</td>
          <td class="mdname" nowrap> <em>BytesRecvdPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reads requested bytes from the mailbox referenced by InstancePtr,into the buffer pointed to by the provided pointer. The number of bytes must be a multiple of 4 (bytes). If not, the call will fail in an assert.<p>
This function is non blocking.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html">XMbox</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferPtr</em>&nbsp;</td><td>is the buffer to read the mailbox contents into, aligned to a word boundary. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RequestedBytes</em>&nbsp;</td><td>is the number of bytes of data requested. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BytesRecvdPtr</em>&nbsp;</td><td>is the memory that is updated with the number of bytes of data actually read.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS on success.</li><li>XST_NO_DATA ifthere was no data in the mailbox.</li></ul>
</dd></dl>
On success, the number of bytes read is returned through the pointer. The call may return with fewer bytes placed in the buffer than requested (not including zero). This is not necessarily an error condition and indicates the amount of data that was currently available in the mailbox.<p>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="50ed591178c351824dd96d676ee23412"></a><!-- doxytag: member="xmbox.c::XMbox_ReadBlocking" ref="50ed591178c351824dd96d676ee23412" args="(XMbox *InstancePtr, u32 *BufferPtr, u32 RequestedBytes)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XMbox_ReadBlocking           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32 *&nbsp;</td>
          <td class="mdname" nowrap> <em>BufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>RequestedBytes</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reads requested bytes from the mailbox referenced by InstancePtr,into the buffer pointed to by the provided pointer. The number of bytes must be a multiple of 4 (bytes). If not, the call will fail in an assert.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html">XMbox</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferPtr</em>&nbsp;</td><td>is the buffer to read the mailbox contents into, aligned to a word boundary. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RequestedBytes</em>&nbsp;</td><td>is the number of bytes of data requested.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The call blocks until the number of bytes requested are available. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="c460a83470911ffe10ef8acf0e5e4745"></a><!-- doxytag: member="xmbox.c::XMbox_SetInterruptEnable" ref="c460a83470911ffe10ef8acf0e5e4745" args="(XMbox *InstancePtr, u32 Mask)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XMbox_SetInterruptEnable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Mask</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the interrupt enable register for this mailbox. This function can only be used for Non-FSL interface. If not, the function will fail in an assert.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is a logical OR of XMB_IX_* constants found in <a class="el" href="xmbox__hw_8h.html">xmbox_hw.h</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="faaa97b523bfc0e4f88b53d0fab3e30b"></a><!-- doxytag: member="xmbox.c::XMbox_SetReceiveThreshold" ref="faaa97b523bfc0e4f88b53d0fab3e30b" args="(XMbox *InstancePtr, u32 Value)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XMbox_SetReceiveThreshold           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Value</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the Receive Interrupt Threshold. This function can only be used for Non-FSL interface. If not, the function will fail in an assert. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Value</em>&nbsp;</td><td>is a value to set for the RIT. Only lower Log2(FIFO Depth) bits are used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="6981f31c1911a95bf94b3e2608e3febe"></a><!-- doxytag: member="xmbox.c::XMbox_SetSendThreshold" ref="6981f31c1911a95bf94b3e2608e3febe" args="(XMbox *InstancePtr, u32 Value)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XMbox_SetSendThreshold           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Value</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the Send Interrupt Threshold. This function can only be used for Non-FSL interface. If not, the function will fail in an assert.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Value</em>&nbsp;</td><td>is a value to set for the SIT. Only lower Log2(FIFO Depth) bits are used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="3d9b8fdcdbe1a4ba26787aaa2575dab4"></a><!-- doxytag: member="xmbox.c::XMbox_Write" ref="3d9b8fdcdbe1a4ba26787aaa2575dab4" args="(XMbox *InstancePtr, u32 *BufferPtr, u32 RequestedBytes, u32 *BytesSentPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XMbox_Write           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32 *&nbsp;</td>
          <td class="mdname" nowrap> <em>BufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>RequestedBytes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32 *&nbsp;</td>
          <td class="mdname" nowrap> <em>BytesSentPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Writes the requested bytes from the buffer pointed to by the provided pointer into the mailbox referenced by InstancePtr.The number of bytes must be a multiple of 4 (bytes). If not, the call will fail in an assert.<p>
This function is non blocking.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html">XMbox</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferPtr</em>&nbsp;</td><td>is the source data buffer, aligned to a word boundary. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RequestedBytes</em>&nbsp;</td><td>is the number of bytes requested to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BytesRecvdPtr</em>&nbsp;</td><td>points to memory which is updated with the actual number of bytes written, return value. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd></dd></dl>
<ul>
<li>XST_SUCCESS on success.</li><li>XST_FIFO_NO_ROOM if the fifo was full.</li></ul>
<p>
On success, the number of bytes successfully written into the destination mailbox is returned in the provided pointer. The call may return with zero. This is not necessarily an error condition and indicates that the mailbox is currently full.<p>
<dl compact><dt><b>Note:</b></dt><dd>The provided buffer pointed to by BufferPtr must be aligned to a word boundary. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b643bb1dd7ebdaa7674cb17d63ea7cc4"></a><!-- doxytag: member="xmbox.c::XMbox_WriteBlocking" ref="b643bb1dd7ebdaa7674cb17d63ea7cc4" args="(XMbox *InstancePtr, u32 *BufferPtr, u32 RequestedBytes)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XMbox_WriteBlocking           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32 *&nbsp;</td>
          <td class="mdname" nowrap> <em>BufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>RequestedBytes</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Writes the requested bytes from the buffer pointed to by the provided pointer into the mailbox referenced by InstancePtr. The number of bytes must be a multiple of 4 (bytes). If not, the call will fail in an assert.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html">XMbox</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferPtr</em>&nbsp;</td><td>is the source data buffer, aligned to a word boundary. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RequestedBytes</em>&nbsp;</td><td>is the number of bytes requested to be written.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The call blocks until the number of bytes requested are written. The provided buffer pointed to by BufferPtr must be aligned to a word boundary. </dd></dl>
    </td>
  </tr>
</table>
Copyright @ 1995-2014 Xilinx, Inc. All rights reserved. 
