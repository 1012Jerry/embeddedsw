<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   xemacps_bdring.c File Reference
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.5 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>xemacps_bdring.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
This file implements buffer descriptor ring related functions.<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who  Date     Changes
 ----- ---- -------- -------------------------------------------------------
 1.00a wsy  01/10/10 First release
 1.00a asa  11/21/11 The function XEmacPs_BdRingFromHwTx is modified.
		      Earlier it used to search in "BdLimit" number of BDs to
		      know which BDs are processed. Now one more check is
		      added. It looks for BDs till the current BD pointer
		      reaches HwTail. By doing this processing time is saved.
 1.00a asa  01/24/12 The function XEmacPs_BdRingFromHwTx in file
		      <a class="el" href="xemacps__bdring_8c.html">xemacps_bdring.c</a> is modified. Now start of packet is
		      searched for returning the number of BDs processed.
 1.05a asa  09/23/13 Cache operations on BDs are not required and hence
		      removed. It is expected that all BDs are allocated in
		      from uncached area. Fix for CR #663885.
 </pre> 
<p>
<code>#include &quot;xstatus.h&quot;</code><br>
<code>#include &quot;xil_cache.h&quot;</code><br>
<code>#include &quot;<a class="el" href="xemacps__hw_8h.html">xemacps_hw.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="xemacps__bd_8h.html">xemacps_bd.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="xemacps__bdring_8h.html">xemacps_bdring.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8c.html#f4b4747c7b305fae8b051e276c897b11">XEmacPs_BdRingCreate</a> (<a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *RingPtr, u32 PhysAddr, u32 VirtAddr, u32 Alignment, unsigned BdCount)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8c.html#731bb55c7d791744b1af58699626c493">XEmacPs_BdRingClone</a> (<a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *RingPtr, XEmacPs_Bd *SrcBdPtr, u8 Direction)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8c.html#9244ea6c46fd0378f5e35223e3dde85d">XEmacPs_BdRingAlloc</a> (<a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *RingPtr, unsigned NumBd, XEmacPs_Bd **BdSetPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8c.html#e8488ac7fd3352b54fef934bca5402d5">XEmacPs_BdRingUnAlloc</a> (<a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *RingPtr, unsigned NumBd, XEmacPs_Bd *BdSetPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8c.html#f3573f547d25b22b2cccd96d954a47b4">XEmacPs_BdRingToHw</a> (<a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *RingPtr, unsigned NumBd, XEmacPs_Bd *BdSetPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8c.html#873b22404031ee487413645875034420">XEmacPs_BdRingFromHwTx</a> (<a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *RingPtr, unsigned BdLimit, XEmacPs_Bd **BdSetPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8c.html#c93b4746eb95f48fb1e8d2dcb7e5902c">XEmacPs_BdRingFromHwRx</a> (<a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *RingPtr, unsigned BdLimit, XEmacPs_Bd **BdSetPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8c.html#559a6c75984916ab9bbe96aa0250bf8a">XEmacPs_BdRingFree</a> (<a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *RingPtr, unsigned NumBd, XEmacPs_Bd *BdSetPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8c.html#3240f7cfe3e23ec80ff086b103673374">XEmacPs_BdRingCheck</a> (<a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *RingPtr, u8 Direction)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="9244ea6c46fd0378f5e35223e3dde85d"></a><!-- doxytag: member="xemacps_bdring.c::XEmacPs_BdRingAlloc" ref="9244ea6c46fd0378f5e35223e3dde85d" args="(XEmacPs_BdRing *RingPtr, unsigned NumBd, XEmacPs_Bd **BdSetPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XEmacPs_BdRingAlloc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>NumBd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>XEmacPs_Bd **&nbsp;</td>
          <td class="mdname" nowrap> <em>BdSetPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reserve locations in the BD list. The set of returned BDs may be modified in preparation for future DMA transaction(s). Once the BDs are ready to be submitted to hardware, the user must call <a class="el" href="xemacps__bdring_8c.html#f3573f547d25b22b2cccd96d954a47b4">XEmacPs_BdRingToHw()</a> in the same order which they were allocated here. Example:<p>
<pre>
        NumBd = 2;
        Status = XEmacPs_BdRingAlloc(MyRingPtr, NumBd, &amp;MyBdSet);</pre><p>
<pre>        if (Status != XST_SUCCESS)
        {
            // Not enough BDs available for the request
        }</pre><p>
<pre>        CurBd = MyBdSet;
        for (i=0; i&lt;NumBd; i++)
        {
            // Prepare CurBd.....</pre><p>
<pre>            // Onto next BD
            CurBd = <a class="el" href="xemacps__bdring_8h.html#db9bfb7c4165945a5c12d4b46214db51">XEmacPs_BdRingNext(MyRingPtr, CurBd)</a>;
        }</pre><p>
<pre>        // Give list to hardware
        Status = XEmacPs_BdRingToHw(MyRingPtr, NumBd, MyBdSet);
 </pre><p>
A more advanced use of this function may allocate multiple sets of BDs. They must be allocated and given to hardware in the correct sequence: <pre>
        // Legal
        XEmacPs_BdRingAlloc(MyRingPtr, NumBd1, &amp;MySet1);
        XEmacPs_BdRingToHw(MyRingPtr, NumBd1, MySet1);</pre><p>
<pre>        // Legal
        XEmacPs_BdRingAlloc(MyRingPtr, NumBd1, &amp;MySet1);
        XEmacPs_BdRingAlloc(MyRingPtr, NumBd2, &amp;MySet2);
        XEmacPs_BdRingToHw(MyRingPtr, NumBd1, MySet1);
        XEmacPs_BdRingToHw(MyRingPtr, NumBd2, MySet2);</pre><p>
<pre>        // Not legal
        XEmacPs_BdRingAlloc(MyRingPtr, NumBd1, &amp;MySet1);
        XEmacPs_BdRingAlloc(MyRingPtr, NumBd2, &amp;MySet2);
        XEmacPs_BdRingToHw(MyRingPtr, NumBd2, MySet2);
        XEmacPs_BdRingToHw(MyRingPtr, NumBd1, MySet1);
 </pre><p>
Use the API defined in <a class="el" href="xemacps__bd_8h.html">xemacps_bd.h</a> to modify individual BDs. Traversal of the BD set can be done using <a class="el" href="xemacps__bdring_8h.html#db9bfb7c4165945a5c12d4b46214db51">XEmacPs_BdRingNext()</a> and <a class="el" href="xemacps__bdring_8h.html#c170d1a471c0b332cde92ca79f6cb0d7">XEmacPs_BdRingPrev()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is a pointer to the BD ring instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBd</em>&nbsp;</td><td>is the number of BDs to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdSetPtr</em>&nbsp;</td><td>is an output parameter, it points to the first BD available for modification.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the requested number of BDs was returned in the BdSetPtr parameter.</li><li>XST_FAILURE if there were not enough free BDs to satisfy the request.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function should not be preempted by another XEmacPs_Bd function call that modifies the BD space. It is the caller's responsibility to provide a mutual exclusion mechanism.<p>
Do not modify more BDs than the number requested with the NumBd parameter. Doing so will lead to data corruption and system instability. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="3240f7cfe3e23ec80ff086b103673374"></a><!-- doxytag: member="xemacps_bdring.c::XEmacPs_BdRingCheck" ref="3240f7cfe3e23ec80ff086b103673374" args="(XEmacPs_BdRing *RingPtr, u8 Direction)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XEmacPs_BdRingCheck           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8&nbsp;</td>
          <td class="mdname" nowrap> <em>Direction</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check the internal data structures of the BD ring for the provided channel. The following checks are made:<p>
<ul>
<li>Is the BD ring linked correctly in physical address space.</li><li>Do the internal pointers point to BDs in the ring.</li><li>Do the internal counters add up.</li></ul>
<p>
The channel should be stopped prior to calling this function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Direction</em>&nbsp;</td><td>is either XEMACPS_SEND or XEMACPS_RECV that indicates which direction.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the set of BDs was freed.</li><li>XST_DMA_SG_NO_LIST if the list has not been created.</li><li>XST_IS_STARTED if the channel is not stopped.</li><li>XST_DMA_SG_LIST_ERROR if a problem is found with the internal data structures. If this value is returned, the channel should be reset to avoid data corruption or system instability.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function should not be preempted by another XEmacPs_Bd function call that modifies the BD space. It is the caller's responsibility to provide a mutual exclusion mechanism. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="731bb55c7d791744b1af58699626c493"></a><!-- doxytag: member="xemacps_bdring.c::XEmacPs_BdRingClone" ref="731bb55c7d791744b1af58699626c493" args="(XEmacPs_BdRing *RingPtr, XEmacPs_Bd *SrcBdPtr, u8 Direction)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XEmacPs_BdRingClone           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>XEmacPs_Bd *&nbsp;</td>
          <td class="mdname" nowrap> <em>SrcBdPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8&nbsp;</td>
          <td class="mdname" nowrap> <em>Direction</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clone the given BD into every BD in the list. every field of the source BD is replicated in every BD of the list.<p>
This function can be called only when all BDs are in the free group such as they are immediately after initialization with <a class="el" href="xemacps__bdring_8c.html#f4b4747c7b305fae8b051e276c897b11">XEmacPs_BdRingCreate()</a>. This prevents modification of BDs while they are in use by hardware or the user.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is the pointer of BD ring instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SrcBdPtr</em>&nbsp;</td><td>is the source BD template to be cloned into the list. This BD will be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Direction</em>&nbsp;</td><td>is either XEMACPS_SEND or XEMACPS_RECV that indicates which direction.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the list was modified.</li><li>XST_DMA_SG_NO_LIST if a list has not been created.</li><li>XST_DMA_SG_LIST_ERROR if some of the BDs in this channel are under hardware or user control.</li><li>XST_DEVICE_IS_STARTED if the DMA channel has not been stopped. </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="f4b4747c7b305fae8b051e276c897b11"></a><!-- doxytag: member="xemacps_bdring.c::XEmacPs_BdRingCreate" ref="f4b4747c7b305fae8b051e276c897b11" args="(XEmacPs_BdRing *RingPtr, u32 PhysAddr, u32 VirtAddr, u32 Alignment, unsigned BdCount)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XEmacPs_BdRingCreate           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>PhysAddr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>VirtAddr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Alignment</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>BdCount</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Using a memory segment allocated by the caller, create and setup the BD list for the given DMA channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PhysAddr</em>&nbsp;</td><td>is the physical base address of user memory region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VirtAddr</em>&nbsp;</td><td>is the virtual base address of the user memory region. If address translation is not being utilized, then VirtAddr should be equivalent to PhysAddr. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Alignment</em>&nbsp;</td><td>governs the byte alignment of individual BDs. This function will enforce a minimum alignment of 4 bytes with no maximum as long as it is specified as a power of 2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdCount</em>&nbsp;</td><td>is the number of BDs to setup in the user memory region. It is assumed the region is large enough to contain the BDs.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd></dd></dl>
<ul>
<li>XST_SUCCESS if initialization was successful</li><li>XST_NO_FEATURE if the provided instance is a non DMA type channel.</li><li>XST_INVALID_PARAM under any of the following conditions: 1) PhysAddr and/or VirtAddr are not aligned to the given Alignment parameter; 2) Alignment parameter does not meet minimum requirements or is not a power of 2 value; 3) BdCount is 0.</li><li>XST_DMA_SG_LIST_ERROR if the memory segment containing the list spans over address 0x00000000 in virtual address space.</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>Make sure to pass in the right alignment value. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="559a6c75984916ab9bbe96aa0250bf8a"></a><!-- doxytag: member="xemacps_bdring.c::XEmacPs_BdRingFree" ref="559a6c75984916ab9bbe96aa0250bf8a" args="(XEmacPs_BdRing *RingPtr, unsigned NumBd, XEmacPs_Bd *BdSetPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XEmacPs_BdRingFree           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>NumBd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>XEmacPs_Bd *&nbsp;</td>
          <td class="mdname" nowrap> <em>BdSetPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Frees a set of BDs that had been previously retrieved with XEmacPs_BdRingFromHw().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBd</em>&nbsp;</td><td>is the number of BDs to free. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdSetPtr</em>&nbsp;</td><td>is the head of a list of BDs returned by XEmacPs_BdRingFromHw().</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the set of BDs was freed.</li><li>XST_DMA_SG_LIST_ERROR if this function was called out of sequence with XEmacPs_BdRingFromHw().</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function should not be preempted by another XEmacPs_Bd function call that modifies the BD space. It is the caller's responsibility to provide a mutual exclusion mechanism. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="c93b4746eb95f48fb1e8d2dcb7e5902c"></a><!-- doxytag: member="xemacps_bdring.c::XEmacPs_BdRingFromHwRx" ref="c93b4746eb95f48fb1e8d2dcb7e5902c" args="(XEmacPs_BdRing *RingPtr, unsigned BdLimit, XEmacPs_Bd **BdSetPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned XEmacPs_BdRingFromHwRx           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>BdLimit</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>XEmacPs_Bd **&nbsp;</td>
          <td class="mdname" nowrap> <em>BdSetPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a set of BD(s) that have been processed by hardware. The returned BDs may be examined to determine the outcome of the DMA transaction(s). Once the BDs have been examined, the user must call <a class="el" href="xemacps__bdring_8c.html#559a6c75984916ab9bbe96aa0250bf8a">XEmacPs_BdRingFree()</a> in the same order which they were retrieved here. Example:<p>
<pre>
        NumBd = XEmacPs_BdRingFromHwRx(MyRingPtr, MaxBd, &amp;MyBdSet);</pre><p>
<pre>        if (NumBd == 0)
        {
           // hardware has nothing ready for us yet
        }</pre><p>
<pre>        CurBd = MyBdSet;
        for (i=0; i&lt;NumBd; i++)
        {
           // Examine CurBd for post processing.....</pre><p>
<pre>           // Onto next BD
           CurBd = <a class="el" href="xemacps__bdring_8h.html#db9bfb7c4165945a5c12d4b46214db51">XEmacPs_BdRingNext(MyRingPtr, CurBd)</a>;
           }</pre><p>
<pre>           XEmacPs_BdRingFree(MyRingPtr, NumBd, MyBdSet); // Return list
        }
 </pre><p>
A more advanced use of this function may allocate multiple sets of BDs. They must be retrieved from hardware and freed in the correct sequence: <pre>
        // Legal
        XEmacPs_BdRingFromHwRx(MyRingPtr, NumBd1, &amp;MySet1);
        XEmacPs_BdRingFree(MyRingPtr, NumBd1, MySet1);</pre><p>
<pre>        // Legal
        XEmacPs_BdRingFromHwRx(MyRingPtr, NumBd1, &amp;MySet1);
        XEmacPs_BdRingFromHwRx(MyRingPtr, NumBd2, &amp;MySet2);
        XEmacPs_BdRingFree(MyRingPtr, NumBd1, MySet1);
        XEmacPs_BdRingFree(MyRingPtr, NumBd2, MySet2);</pre><p>
<pre>        // Not legal
        XEmacPs_BdRingFromHwRx(MyRingPtr, NumBd1, &amp;MySet1);
        XEmacPs_BdRingFromHwRx(MyRingPtr, NumBd2, &amp;MySet2);
        XEmacPs_BdRingFree(MyRingPtr, NumBd2, MySet2);
        XEmacPs_BdRingFree(MyRingPtr, NumBd1, MySet1);
 </pre><p>
If hardware has only partially completed a packet spanning multiple BDs, then none of the BDs for that packet will be included in the results.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdLimit</em>&nbsp;</td><td>is the maximum number of BDs to return in the set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdSetPtr</em>&nbsp;</td><td>is an output parameter, it points to the first BD available for examination.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of BDs processed by hardware. A value of 0 indicates that no data is available. No more than BdLimit BDs will be returned.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Treat BDs returned by this function as read-only.<p>
This function should not be preempted by another XEmacPs_Bd function call that modifies the BD space. It is the caller's responsibility to provide a mutual exclusion mechanism. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="873b22404031ee487413645875034420"></a><!-- doxytag: member="xemacps_bdring.c::XEmacPs_BdRingFromHwTx" ref="873b22404031ee487413645875034420" args="(XEmacPs_BdRing *RingPtr, unsigned BdLimit, XEmacPs_Bd **BdSetPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned XEmacPs_BdRingFromHwTx           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>BdLimit</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>XEmacPs_Bd **&nbsp;</td>
          <td class="mdname" nowrap> <em>BdSetPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a set of BD(s) that have been processed by hardware. The returned BDs may be examined to determine the outcome of the DMA transaction(s). Once the BDs have been examined, the user must call <a class="el" href="xemacps__bdring_8c.html#559a6c75984916ab9bbe96aa0250bf8a">XEmacPs_BdRingFree()</a> in the same order which they were retrieved here. Example:<p>
<pre>
        NumBd = XEmacPs_BdRingFromHwTx(MyRingPtr, MaxBd, &amp;MyBdSet);</pre><p>
<pre>        if (NumBd == 0)
        {
           // hardware has nothing ready for us yet
        }</pre><p>
<pre>        CurBd = MyBdSet;
        for (i=0; i&lt;NumBd; i++)
        {
           // Examine CurBd for post processing.....</pre><p>
<pre>           // Onto next BD
           CurBd = <a class="el" href="xemacps__bdring_8h.html#db9bfb7c4165945a5c12d4b46214db51">XEmacPs_BdRingNext(MyRingPtr, CurBd)</a>;
           }</pre><p>
<pre>           XEmacPs_BdRingFree(MyRingPtr, NumBd, MyBdSet); // Return list
        }
 </pre><p>
A more advanced use of this function may allocate multiple sets of BDs. They must be retrieved from hardware and freed in the correct sequence: <pre>
        // Legal
        XEmacPs_BdRingFromHwTx(MyRingPtr, NumBd1, &amp;MySet1);
        XEmacPs_BdRingFree(MyRingPtr, NumBd1, MySet1);</pre><p>
<pre>        // Legal
        XEmacPs_BdRingFromHwTx(MyRingPtr, NumBd1, &amp;MySet1);
        XEmacPs_BdRingFromHwTx(MyRingPtr, NumBd2, &amp;MySet2);
        XEmacPs_BdRingFree(MyRingPtr, NumBd1, MySet1);
        XEmacPs_BdRingFree(MyRingPtr, NumBd2, MySet2);</pre><p>
<pre>        // Not legal
        XEmacPs_BdRingFromHwTx(MyRingPtr, NumBd1, &amp;MySet1);
        XEmacPs_BdRingFromHwTx(MyRingPtr, NumBd2, &amp;MySet2);
        XEmacPs_BdRingFree(MyRingPtr, NumBd2, MySet2);
        XEmacPs_BdRingFree(MyRingPtr, NumBd1, MySet1);
 </pre><p>
If hardware has only partially completed a packet spanning multiple BDs, then none of the BDs for that packet will be included in the results.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdLimit</em>&nbsp;</td><td>is the maximum number of BDs to return in the set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdSetPtr</em>&nbsp;</td><td>is an output parameter, it points to the first BD available for examination.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of BDs processed by hardware. A value of 0 indicates that no data is available. No more than BdLimit BDs will be returned.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Treat BDs returned by this function as read-only.<p>
This function should not be preempted by another XEmacPs_Bd function call that modifies the BD space. It is the caller's responsibility to provide a mutual exclusion mechanism. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="f3573f547d25b22b2cccd96d954a47b4"></a><!-- doxytag: member="xemacps_bdring.c::XEmacPs_BdRingToHw" ref="f3573f547d25b22b2cccd96d954a47b4" args="(XEmacPs_BdRing *RingPtr, unsigned NumBd, XEmacPs_Bd *BdSetPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XEmacPs_BdRingToHw           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>NumBd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>XEmacPs_Bd *&nbsp;</td>
          <td class="mdname" nowrap> <em>BdSetPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enqueue a set of BDs to hardware that were previously allocated by <a class="el" href="xemacps__bdring_8c.html#9244ea6c46fd0378f5e35223e3dde85d">XEmacPs_BdRingAlloc()</a>. Once this function returns, the argument BD set goes under hardware control. Any changes made to these BDs after this point will corrupt the BD list leading to data corruption and system instability.<p>
The set will be rejected if the last BD of the set does not mark the end of a packet (see <a class="el" href="xemacps__bd_8h.html#74c49c26ad67d4b1b7576c09e2deaaac">XEmacPs_BdSetLast()</a>).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBd</em>&nbsp;</td><td>is the number of BDs in the set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdSetPtr</em>&nbsp;</td><td>is the first BD of the set to commit to hardware.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the set of BDs was accepted and enqueued to hardware.</li><li>XST_FAILURE if the set of BDs was rejected because the last BD of the set did not have its "last" bit set.</li><li>XST_DMA_SG_LIST_ERROR if this function was called out of sequence with <a class="el" href="xemacps__bdring_8c.html#9244ea6c46fd0378f5e35223e3dde85d">XEmacPs_BdRingAlloc()</a>.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function should not be preempted by another XEmacPs_Bd function call that modifies the BD space. It is the caller's responsibility to provide a mutual exclusion mechanism. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="e8488ac7fd3352b54fef934bca5402d5"></a><!-- doxytag: member="xemacps_bdring.c::XEmacPs_BdRingUnAlloc" ref="e8488ac7fd3352b54fef934bca5402d5" args="(XEmacPs_BdRing *RingPtr, unsigned NumBd, XEmacPs_Bd *BdSetPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XEmacPs_BdRingUnAlloc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>NumBd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>XEmacPs_Bd *&nbsp;</td>
          <td class="mdname" nowrap> <em>BdSetPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fully or partially undo an <a class="el" href="xemacps__bdring_8c.html#9244ea6c46fd0378f5e35223e3dde85d">XEmacPs_BdRingAlloc()</a> operation. Use this function if all the BDs allocated by <a class="el" href="xemacps__bdring_8c.html#9244ea6c46fd0378f5e35223e3dde85d">XEmacPs_BdRingAlloc()</a> could not be transferred to hardware with <a class="el" href="xemacps__bdring_8c.html#f3573f547d25b22b2cccd96d954a47b4">XEmacPs_BdRingToHw()</a>.<p>
This function helps out in situations when an unrelated error occurs after BDs have been allocated but before they have been given to hardware. An example of this type of error would be an OS running out of resources.<p>
This function is not the same as <a class="el" href="xemacps__bdring_8c.html#559a6c75984916ab9bbe96aa0250bf8a">XEmacPs_BdRingFree()</a>. The Free function returns BDs to the free list after they have been processed by hardware, while UnAlloc returns them before being processed by hardware.<p>
There are two scenarios where this function can be used. Full UnAlloc or Partial UnAlloc. A Full UnAlloc means all the BDs Alloc'd will be returned:<p>
<pre>
    Status = XEmacPs_BdRingAlloc(MyRingPtr, 10, &amp;BdPtr);
        ...
    if (Error)
    {
        Status = XEmacPs_BdRingUnAlloc(MyRingPtr, 10, &amp;BdPtr);
    }
 </pre><p>
A partial UnAlloc means some of the BDs Alloc'd will be returned:<p>
<pre>
    Status = XEmacPs_BdRingAlloc(MyRingPtr, 10, &amp;BdPtr);
    BdsLeft = 10;
    CurBdPtr = BdPtr;</pre><p>
<pre>    while (BdsLeft)
    {
       if (Error)
       {
          Status = XEmacPs_BdRingUnAlloc(MyRingPtr, BdsLeft, CurBdPtr);
       }</pre><p>
<pre>       CurBdPtr = <a class="el" href="xemacps__bdring_8h.html#db9bfb7c4165945a5c12d4b46214db51">XEmacPs_BdRingNext(MyRingPtr, CurBdPtr)</a>;
       BdsLeft--;
    }
 </pre><p>
A partial UnAlloc must include the last BD in the list that was Alloc'd.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBd</em>&nbsp;</td><td>is the number of BDs to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdSetPtr</em>&nbsp;</td><td>is an output parameter, it points to the first BD available for modification.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the BDs were unallocated.</li><li>XST_FAILURE if NumBd parameter was greater that the number of BDs in the preprocessing state.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function should not be preempted by another XEmacPs_Bd function call that modifies the BD space. It is the caller's responsibility to provide a mutual exclusion mechanism. </dd></dl>
    </td>
  </tr>
</table>
Copyright @ 1995-2014 Xilinx, Inc. All rights reserved. 
