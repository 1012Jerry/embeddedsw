<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   xemacps.c File Reference
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.5 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>xemacps.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
The <a class="el" href="struct_x_emac_ps.html">XEmacPs</a> driver. Functions in this file are the minimum required functions for this driver. See xemacps.h for a detailed description of the driver.<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who  Date     Changes
 ----- ---- -------- -------------------------------------------------------
 1.00a wsy  01/10/10 First release
 </pre> 
<p>
<code>#include &quot;xemacps.h&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8c.html#6d46c8a1fa84d2e30490cf0db50a96e8">XEmacPs_StubHandler</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8c.html#a67c6cb4e2cb2e0606dbca494e3e3888">XEmacPs_CfgInitialize</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, <a class="el" href="struct_x_emac_ps___config.html">XEmacPs_Config</a> *CfgPtr, u32 EffectiveAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8c.html#4922ebfa727233f7005407f24455b71f">XEmacPs_Start</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8c.html#938333a80086913d4e44a9f580ca9fc3">XEmacPs_Stop</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8c.html#7342973e155ffc576ec41082be09850a">XEmacPs_Reset</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a67c6cb4e2cb2e0606dbca494e3e3888"></a><!-- doxytag: member="xemacps.c::XEmacPs_CfgInitialize" ref="a67c6cb4e2cb2e0606dbca494e3e3888" args="(XEmacPs *InstancePtr, XEmacPs_Config *CfgPtr, u32 EffectiveAddress)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XEmacPs_CfgInitialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct_x_emac_ps___config.html">XEmacPs_Config</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>CfgPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>EffectiveAddress</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a specific <a class="el" href="struct_x_emac_ps.html">XEmacPs</a> instance/driver. The initialization entails:<ul>
<li>Initialize fields of the <a class="el" href="struct_x_emac_ps.html">XEmacPs</a> instance structure</li><li>Reset hardware and apply default options</li><li>Configure the DMA channels</li></ul>
<p>
The PHY is setup independently from the device. Use the MII or whatever other interface may be present for setup.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CfgPtr</em>&nbsp;</td><td>is the device configuration structure containing required hardware build data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddress</em>&nbsp;</td><td>is the base address of the device. If address translation is not utilized, this parameter can be passed in using CfgPtr-&gt;Config.BaseAddress to specify the physical base address.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if initialization was successful </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="7342973e155ffc576ec41082be09850a"></a><!-- doxytag: member="xemacps.c::XEmacPs_Reset" ref="7342973e155ffc576ec41082be09850a" args="(XEmacPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XEmacPs_Reset           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Perform a graceful reset of the Ethernet MAC. Resets the DMA channels, the transmitter, and the receiver.<p>
Steps to reset<ul>
<li>Stops transmit and receive channels</li><li>Stops DMA</li><li>Configure transmit and receive buffer size to default</li><li>Clear transmit and receive status register and counters</li><li>Clear all interrupt sources</li><li>Clear phy (if there is any previously detected) address</li><li>Clear MAC addresses (1-4) as well as Type IDs and hash value</li></ul>
<p>
All options are placed in their default state. Any frames in the descriptor lists will remain in the lists. The side effect of doing this is that after a reset and following a restart of the device, frames were in the list before the reset may be transmitted or received.<p>
The upper layer software is responsible for re-configuring (if necessary) and restarting the MAC after the reset. Note also that driver statistics are not cleared on reset. It is up to the upper layer software to clear the statistics if needed.<p>
When a reset is required, the driver notifies the upper layer software of this need through the ErrorHandler callback and specific status codes. The upper layer software is responsible for calling this Reset function and then re-configuring the device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4922ebfa727233f7005407f24455b71f"></a><!-- doxytag: member="xemacps.c::XEmacPs_Start" ref="4922ebfa727233f7005407f24455b71f" args="(XEmacPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XEmacPs_Start           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start the Ethernet controller as follows:<ul>
<li>Enable transmitter if XTE_TRANSMIT_ENABLE_OPTION is set</li><li>Enable receiver if XTE_RECEIVER_ENABLE_OPTION is set</li><li>Start the SG DMA send and receive channels and enable the device interrupt</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>N/A</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Hardware is configured with scatter-gather DMA, the driver expects to start the scatter-gather channels and expects that the user has previously set up the buffer descriptor lists.</dd></dl>
This function makes use of internal resources that are shared between the Start, Stop, and Set/ClearOptions functions. So if one task might be setting device options while another is trying to start the device, the user is required to provide protection of this shared data (typically using a semaphore).<p>
This function must not be preempted by an interrupt that may service the device.     </td>
  </tr>
</table>
<a class="anchor" name="938333a80086913d4e44a9f580ca9fc3"></a><!-- doxytag: member="xemacps.c::XEmacPs_Stop" ref="938333a80086913d4e44a9f580ca9fc3" args="(XEmacPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XEmacPs_Stop           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gracefully stop the Ethernet MAC as follows:<ul>
<li>Disable all interrupts from this device</li><li>Stop DMA channels</li><li>Disable the tansmitter and receiver</li></ul>
<p>
Device options currently in effect are not changed.<p>
This function will disable all interrupts. Default interrupts settings that had been enabled will be restored when <a class="el" href="xemacps_8c.html#4922ebfa727233f7005407f24455b71f">XEmacPs_Start()</a> is called.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>This function makes use of internal resources that are shared between the Start, Stop, SetOptions, and ClearOptions functions. So if one task might be setting device options while another is trying to start the device, the user is required to provide protection of this shared data (typically using a semaphore).</dd></dl>
Stopping the DMA channels causes this function to block until the DMA operation is complete.     </td>
  </tr>
</table>
<a class="anchor" name="6d46c8a1fa84d2e30490cf0db50a96e8"></a><!-- doxytag: member="xemacps.c::XEmacPs_StubHandler" ref="6d46c8a1fa84d2e30490cf0db50a96e8" args="(void)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XEmacPs_StubHandler           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This is a stub for the asynchronous callbacks. The stub is here in case the upper layer forgot to set the handler(s). On initialization, all handlers are set to this callback. It is considered an error for this handler to be invoked.     </td>
  </tr>
</table>
Copyright @ 1995-2014 Xilinx, Inc. All rights reserved. 
