<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   xaxidma_bdring.c File Reference
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.5 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>xaxidma_bdring.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
This file implements buffer descriptor ring related functions. For more information on how to manage the BD ring, please see xaxidma.h.<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who  Date     Changes
 ----- ---- -------- -------------------------------------------------------
 1.00a jz   05/18/10 First release
 2.00a jz   08/10/10 Second release, added in <a class="el" href="xaxidma__g_8c.html">xaxidma_g.c</a>, <a class="el" href="xaxidma__sinit_8c.html">xaxidma_sinit.c</a>,
                     updated tcl file, added <a class="el" href="xaxidma__porting__guide_8h.html">xaxidma_porting_guide.h</a>
 3.00a jz   11/22/10 Support IP core parameters change
 5.00a srt  08/25/11 Added support for memory barrier.
 6.00a srt  01/24/12 Added support for Multi-Channel DMA.<ul>
<li>New API
			* XAxiDma_UpdateBdRingCDesc(<a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> * RingPtr,
						int RingIndex)</li><li>Changed APIs
			* XAxiDma_StartBdRingHw(<a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> * RingPtr,
					int RingIndex)
			* XAxiDma_BdRingStart(<a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> * RingPtr,
						 int RingIndex)
			* XAxiDma_BdRingToHw(<a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> * RingPtr,
        			int NumBd, XAxiDma_Bd * BdSetPtr, int RingIndex)
			* XAxiDma_BdRingDumpRegs(<a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> * RingPtr,
						 int RingIndex)
			* XAxiDma_BdRingSnapShotCurrBd(<a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> * RingPtr,
						 int RingIndex)
 7.00a srt  06/18/12  All the APIs changed in v6_00_a are reverted back for
		       backward compatibility.</li></ul>
</pre><p>
<pre> </pre> 
<p>
<code>#include &quot;<a class="el" href="xaxidma__bdring_8h.html">xaxidma_bdring.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxidma__bdring_8c.html#22499d05a91555f08fe9a95d134abcdb">XAxiDma_UpdateBdRingCDesc</a> (<a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *RingPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxidma__bdring_8c.html#34e5f68cd847c46b3661af468739947b">XAxiDma_BdRingCreate</a> (<a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *RingPtr, u32 PhysAddr, u32 VirtAddr, u32 Alignment, int BdCount)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxidma__bdring_8c.html#b2761050933d1e5e60fedac1bedecc05">XAxiDma_BdRingClone</a> (<a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *RingPtr, <a class="el" href="xaxidma__bd_8h.html#afd3b643f4cd8899af5078d649f19a6f">XAxiDma_Bd</a> *SrcBdPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxidma__bdring_8c.html#aa7f3bcecba09babb5e83f9a13088fed">XAxiDma_StartBdRingHw</a> (<a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *RingPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxidma__bdring_8c.html#80d68862fd44c386c81a4e6b03d6c7a8">XAxiDma_BdRingStart</a> (<a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *RingPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxidma__bdring_8c.html#c90b66edf15509d0a12b7592e0e5c70a">XAxiDma_BdRingSetCoalesce</a> (<a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *RingPtr, u32 Counter, u32 Timer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxidma__bdring_8c.html#f8d438a4d2f2f6c390a0bcb57a02728d">XAxiDma_BdRingGetCoalesce</a> (<a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *RingPtr, u32 *CounterPtr, u32 *TimerPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxidma__bdring_8c.html#1b2b817d9ba1981124a859a977934540">XAxiDma_BdRingAlloc</a> (<a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *RingPtr, int NumBd, <a class="el" href="xaxidma__bd_8h.html#afd3b643f4cd8899af5078d649f19a6f">XAxiDma_Bd</a> **BdSetPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxidma__bdring_8c.html#592c2d0428c5a731b27071eac41ae77b">XAxiDma_BdRingUnAlloc</a> (<a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *RingPtr, int NumBd, <a class="el" href="xaxidma__bd_8h.html#afd3b643f4cd8899af5078d649f19a6f">XAxiDma_Bd</a> *BdSetPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxidma__bdring_8c.html#4cd05c3aaa28683a66510cc065ddf949">XAxiDma_BdRingToHw</a> (<a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *RingPtr, int NumBd, <a class="el" href="xaxidma__bd_8h.html#afd3b643f4cd8899af5078d649f19a6f">XAxiDma_Bd</a> *BdSetPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxidma__bdring_8c.html#a4ef4a53e1ecb5272ef7703dc48c0b75">XAxiDma_BdRingFromHw</a> (<a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *RingPtr, int BdLimit, <a class="el" href="xaxidma__bd_8h.html#afd3b643f4cd8899af5078d649f19a6f">XAxiDma_Bd</a> **BdSetPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxidma__bdring_8c.html#b114dee6f9cd802c06893dfb267b9442">XAxiDma_BdRingFree</a> (<a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *RingPtr, int NumBd, <a class="el" href="xaxidma__bd_8h.html#afd3b643f4cd8899af5078d649f19a6f">XAxiDma_Bd</a> *BdSetPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxidma__bdring_8c.html#a1b8f3f0f0e9dc659a66f17d9daed08b">XAxiDma_BdRingCheck</a> (<a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *RingPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxidma__bdring_8c.html#38bd38b2ca5727da3d7a35d13e109e70">XAxiDma_BdRingDumpRegs</a> (<a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *RingPtr)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="1b2b817d9ba1981124a859a977934540"></a><!-- doxytag: member="xaxidma_bdring.c::XAxiDma_BdRingAlloc" ref="1b2b817d9ba1981124a859a977934540" args="(XAxiDma_BdRing *RingPtr, int NumBd, XAxiDma_Bd **BdSetPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XAxiDma_BdRingAlloc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>NumBd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="xaxidma__bd_8h.html#afd3b643f4cd8899af5078d649f19a6f">XAxiDma_Bd</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>BdSetPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reserve locations in the BD ring. The set of returned BDs may be modified in preparation for future DMA transactions. Once the BDs are ready to be submitted to hardware, the application must call <a class="el" href="xaxidma__bdring_8c.html#4cd05c3aaa28683a66510cc065ddf949">XAxiDma_BdRingToHw()</a> in the same order which they were allocated here. Example:<p>
<pre>
        NumBd = 2;
        Status = XDsma_RingBdAlloc(MyRingPtr, NumBd, &amp;MyBdSet);</pre><p>
<pre>        if (Status != XST_SUCCESS)
        {
            // Not enough BDs available for the request
        }</pre><p>
<pre>        CurBd = MyBdSet;
        for (i=0; i&lt;NumBd; i++)
        {
            // Prepare CurBd.....</pre><p>
<pre>            // Onto next BD
            CurBd = <a class="el" href="xaxidma__bdring_8h.html#39c795b29575a78496c33ac021016039">XAxiDma_BdRingNext(MyRingPtr, CurBd)</a>;
        }</pre><p>
<pre>        // Give list to hardware
        Status = XAxiDma_BdRingToHw(MyRingPtr, NumBd, MyBdSet);
 </pre><p>
A more advanced use of this function may allocate multiple sets of BDs. They must be allocated and given to hardware in the correct sequence: <pre>
        // Legal
        XAxiDma_BdRingAlloc(MyRingPtr, NumBd1, &amp;MySet1);
        XAxiDma_BdRingToHw(MyRingPtr, NumBd1, MySet1);</pre><p>
<pre>        // Legal
        XAxiDma_BdRingAlloc(MyRingPtr, NumBd1, &amp;MySet1);
        XAxiDma_BdRingAlloc(MyRingPtr, NumBd2, &amp;MySet2);
        XAxiDma_BdRingToHw(MyRingPtr, NumBd1, MySet1);
        XAxiDma_BdRingToHw(MyRingPtr, NumBd2, MySet2);</pre><p>
<pre>        // Not legal
        XAxiDma_BdRingAlloc(MyRingPtr, NumBd1, &amp;MySet1);
        XAxiDma_BdRingAlloc(MyRingPtr, NumBd2, &amp;MySet2);
        XAxiDma_BdRingToHw(MyRingPtr, NumBd2, MySet2);
        XAxiDma_BdRingToHw(MyRingPtr, NumBd1, MySet1);
 </pre><p>
Use the API defined in xaxidmabd.h to modify individual BDs. Traversal of the BD set can be done using <a class="el" href="xaxidma__bdring_8h.html#39c795b29575a78496c33ac021016039">XAxiDma_BdRingNext()</a> and <a class="el" href="xaxidma__bdring_8h.html#840f8f0153313ba792793cc6331d3a31">XAxiDma_BdRingPrev()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is a pointer to the descriptor ring instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBd</em>&nbsp;</td><td>is the number of BDs to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdSetPtr</em>&nbsp;</td><td>is an output parameter, it points to the first BD available for modification.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the requested number of BDs were returned in the BdSetPtr parameter.</li><li>XST_INVALID_PARAM if passed in NumBd is not positive</li><li>XST_FAILURE if there were not enough free BDs to satisfy the request.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function should not be preempted by another <a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> function call that modifies the BD space. It is the caller's responsibility to provide a mutual exclusion mechanism.</dd></dl>
Do not modify more BDs than the number requested with the NumBd parameter. Doing so will lead to data corruption and system instability.<p>
This function can be used only when DMA is in SG mode     </td>
  </tr>
</table>
<a class="anchor" name="a1b8f3f0f0e9dc659a66f17d9daed08b"></a><!-- doxytag: member="xaxidma_bdring.c::XAxiDma_BdRingCheck" ref="a1b8f3f0f0e9dc659a66f17d9daed08b" args="(XAxiDma_BdRing *RingPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XAxiDma_BdRingCheck           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>RingPtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check the internal data structures of the BD ring for the provided channel. The following checks are made:<p>
<ul>
<li>The BD ring is linked correctly in physical address space.</li><li>The internal pointers point to BDs in the ring.</li><li>The internal counters add up.</li></ul>
<p>
The channel should be stopped (through <a class="el" href="xaxidma_8c.html#c298374c5718cc8cd8f16849ef7a8fee">XAxiDma_Pause()</a> or <a class="el" href="xaxidma_8c.html#60dc9f81136d64241090a2680e59c8e1">XAxiDma_Reset()</a>) prior to calling this function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is a pointer to the descriptor ring to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if no errors were found.</li><li>XST_DMA_SG_NO_LIST if the ring has not been created.</li><li>XST_IS_STARTED if the channel is not stopped.</li><li>XST_DMA_SG_LIST_ERROR if a problem is found with the internal data structures. If this value is returned, the channel should be reset,and the BD ring should be recreated through <a class="el" href="xaxidma__bdring_8c.html#34e5f68cd847c46b3661af468739947b">XAxiDma_BdRingCreate()</a> to avoid data corruption or system instability.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function can be used only when DMA is in SG mode </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b2761050933d1e5e60fedac1bedecc05"></a><!-- doxytag: member="xaxidma_bdring.c::XAxiDma_BdRingClone" ref="b2761050933d1e5e60fedac1bedecc05" args="(XAxiDma_BdRing *RingPtr, XAxiDma_Bd *SrcBdPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XAxiDma_BdRingClone           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="xaxidma__bd_8h.html#afd3b643f4cd8899af5078d649f19a6f">XAxiDma_Bd</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>SrcBdPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clone the given BD into every BD in the ring. Only the fields offset from XAXIDMA_BD_START_CLEAR are copied, for XAXIDMA_BD_BYTES_TO_CLEAR bytes. This covers: BufferAddr, Control/Buffer length, status, APP words 0 - 4, and software ID fields.<p>
This function can be called only when all BDs are in the free group such as immediately after creation of the ring. This prevents modification of BDs while they are in use by hardware or the application.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is the BD ring instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SrcBdPtr</em>&nbsp;</td><td>is the source BD template to be cloned into the list.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the list was modified.</li><li>XST_DMA_SG_NO_LIST if a list has not been created.</li><li>XST_DEVICE_IS_STARTED if the DMA channel has not been stopped.</li><li>XST_DMA_SG_LIST_ERROR if some of the BDs in this channel are under hardware or application control.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function can be used only when DMA is in SG mode </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="34e5f68cd847c46b3661af468739947b"></a><!-- doxytag: member="xaxidma_bdring.c::XAxiDma_BdRingCreate" ref="34e5f68cd847c46b3661af468739947b" args="(XAxiDma_BdRing *RingPtr, u32 PhysAddr, u32 VirtAddr, u32 Alignment, int BdCount)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XAxiDma_BdRingCreate           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>PhysAddr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>VirtAddr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Alignment</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>BdCount</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Using a memory segment allocated by the caller, This fundtion creates and setup the BD ring.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is the BD ring instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PhysAddr</em>&nbsp;</td><td>is the physical base address of application memory region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VirtAddr</em>&nbsp;</td><td>is the virtual base address of the application memory region.If address translation is not being utilized, then VirtAddr should be equivalent to PhysAddr. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Alignment</em>&nbsp;</td><td>governs the byte alignment of individual BDs. This function will enforce a minimum alignment of XAXIDMA_BD_MINIMUM_ALIGNMENT bytes with no maximum as long as it is specified as a power of 2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdCount</em>&nbsp;</td><td>is the number of BDs to setup in the application memory region. It is assumed the region is large enough to contain the BDs.Refer to the "SGDMA Ring Creation" section in xaxidma.h for more information. The minimum valid value for this parameter is 1.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if initialization was successful</li><li>XST_NO_FEATURE if the provided instance is a non SGDMA type of DMA channel.</li><li>XST_INVALID_PARAM under any of the following conditions: 1) BdCount is not positive</li></ul>
</dd></dl>
2) PhysAddr and/or VirtAddr are not aligned to the given Alignment parameter;<p>
3) Alignment parameter does not meet minimum requirements or is not a power of 2 value.<p>
<ul>
<li>XST_DMA_SG_LIST_ERROR if the memory segment containing the list spans over address 0x00000000 in virtual address space.</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>This function can be used only when DMA is in SG mode </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="38bd38b2ca5727da3d7a35d13e109e70"></a><!-- doxytag: member="xaxidma_bdring.c::XAxiDma_BdRingDumpRegs" ref="38bd38b2ca5727da3d7a35d13e109e70" args="(XAxiDma_BdRing *RingPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XAxiDma_BdRingDumpRegs           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>RingPtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Dump the registers for a channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is a pointer to the descriptor ring to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function can be used only when DMA is in SG mode </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b114dee6f9cd802c06893dfb267b9442"></a><!-- doxytag: member="xaxidma_bdring.c::XAxiDma_BdRingFree" ref="b114dee6f9cd802c06893dfb267b9442" args="(XAxiDma_BdRing *RingPtr, int NumBd, XAxiDma_Bd *BdSetPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XAxiDma_BdRingFree           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>NumBd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="xaxidma__bd_8h.html#afd3b643f4cd8899af5078d649f19a6f">XAxiDma_Bd</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>BdSetPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Frees a set of BDs that had been previously retrieved with <a class="el" href="xaxidma__bdring_8c.html#a4ef4a53e1ecb5272ef7703dc48c0b75">XAxiDma_BdRingFromHw()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is a pointer to the descriptor ring instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBd</em>&nbsp;</td><td>is the number of BDs to free. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdSetPtr</em>&nbsp;</td><td>is the head of a list of BDs returned by <a class="el" href="xaxidma__bdring_8c.html#a4ef4a53e1ecb5272ef7703dc48c0b75">XAxiDma_BdRingFromHw()</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the set of BDs was freed.</li><li>XST_INVALID_PARAM if NumBd is negative</li><li>XST_DMA_SG_LIST_ERROR if this function was called out of sequence with <a class="el" href="xaxidma__bdring_8c.html#a4ef4a53e1ecb5272ef7703dc48c0b75">XAxiDma_BdRingFromHw()</a>.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function should not be preempted by another <a class="el" href="struct_x_axi_dma.html">XAxiDma</a> function call that modifies the BD space. It is the caller's responsibility to ensure mutual exclusion.</dd></dl>
This function can be used only when DMA is in SG mode     </td>
  </tr>
</table>
<a class="anchor" name="a4ef4a53e1ecb5272ef7703dc48c0b75"></a><!-- doxytag: member="xaxidma_bdring.c::XAxiDma_BdRingFromHw" ref="a4ef4a53e1ecb5272ef7703dc48c0b75" args="(XAxiDma_BdRing *RingPtr, int BdLimit, XAxiDma_Bd **BdSetPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XAxiDma_BdRingFromHw           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>BdLimit</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="xaxidma__bd_8h.html#afd3b643f4cd8899af5078d649f19a6f">XAxiDma_Bd</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>BdSetPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a set of BD(s) that have been processed by hardware. The returned BDs may be examined by the application to determine the outcome of the DMA transactions. Once the BDs have been examined, the application must call <a class="el" href="xaxidma__bdring_8c.html#b114dee6f9cd802c06893dfb267b9442">XAxiDma_BdRingFree()</a> in the same order which they were retrieved here.<p>
Example:<p>
<pre>
        NumBd = XAxiDma_BdRingFromHw(MyRingPtr, XAXIDMA_ALL_BDS, &amp;MyBdSet);</pre><p>
<pre>        if (NumBd == 0)
        {
           // hardware has nothing ready for us yet
        }</pre><p>
<pre>        CurBd = MyBdSet;
        for (i=0; i&lt;NumBd; i++)
        {
           // Examine CurBd for post processing.....</pre><p>
<pre>           // Onto next BD
           CurBd = <a class="el" href="xaxidma__bdring_8h.html#39c795b29575a78496c33ac021016039">XAxiDma_BdRingNext(MyRingPtr, CurBd)</a>;
        }</pre><p>
<pre>        XAxiDma_BdRingFree(MyRingPtr, NumBd, MyBdSet); // Return the list
 </pre><p>
A more advanced use of this function may allocate multiple sets of BDs. They must be retrieved from hardware and freed in the correct sequence: <pre>
        // Legal
        XAxiDma_BdRingFromHw(MyRingPtr, NumBd1, &amp;MySet1);
        XAxiDma_BdRingFree(MyRingPtr, NumBd1, MySet1);</pre><p>
<pre>        // Legal
        XAxiDma_BdRingFromHw(MyRingPtr, NumBd1, &amp;MySet1);
        XAxiDma_BdRingFromHw(MyRingPtr, NumBd2, &amp;MySet2);
        XAxiDma_BdRingFree(MyRingPtr, NumBd1, MySet1);
        XAxiDma_BdRingFree(MyRingPtr, NumBd2, MySet2);</pre><p>
<pre>        // Not legal
        XAxiDma_BdRingFromHw(MyRingPtr, NumBd1, &amp;MySet1);
        XAxiDma_BdRingFromHw(MyRingPtr, NumBd2, &amp;MySet2);
        XAxiDma_BdRingFree(MyRingPtr, NumBd2, MySet2);
        XAxiDma_BdRingFree(MyRingPtr, NumBd1, MySet1);
 </pre><p>
If hardware has partially completed a packet spanning multiple BDs, then none of the BDs for that packet will be included in the results.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is a pointer to the descriptor ring instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdLimit</em>&nbsp;</td><td>is the maximum number of BDs to return in the set. Use XAXIDMA_ALL_BDS to return all BDs that have been processed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdSetPtr</em>&nbsp;</td><td>is an output parameter, it points to the first BD available for examination.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of BDs processed by hardware. A value of 0 indicates that no data is available. No more than BdLimit BDs will be returned.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Treat BDs returned by this function as read-only.</dd></dl>
This function should not be preempted by another <a class="el" href="struct_x_axi_dma.html">XAxiDma</a> ring function call that modifies the BD space. It is the caller's responsibility to provide a mutual exclusion mechanism.<p>
This function can be used only when DMA is in SG mode     </td>
  </tr>
</table>
<a class="anchor" name="f8d438a4d2f2f6c390a0bcb57a02728d"></a><!-- doxytag: member="xaxidma_bdring.c::XAxiDma_BdRingGetCoalesce" ref="f8d438a4d2f2f6c390a0bcb57a02728d" args="(XAxiDma_BdRing *RingPtr, u32 *CounterPtr, u32 *TimerPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XAxiDma_BdRingGetCoalesce           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32 *&nbsp;</td>
          <td class="mdname" nowrap> <em>CounterPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32 *&nbsp;</td>
          <td class="mdname" nowrap> <em>TimerPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve current interrupt coalescing parameters from the given descriptor ring channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is a pointer to the descriptor ring instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CounterPtr</em>&nbsp;</td><td>points to a memory location where the current packet counter will be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimerPtr</em>&nbsp;</td><td>points to a memory location where the current waitbound timer will be written.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The passed in parameters, CounterPtr and TimerPtr, holds the references to the return values.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function can be used only when DMA is in SG mode </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="c90b66edf15509d0a12b7592e0e5c70a"></a><!-- doxytag: member="xaxidma_bdring.c::XAxiDma_BdRingSetCoalesce" ref="c90b66edf15509d0a12b7592e0e5c70a" args="(XAxiDma_BdRing *RingPtr, u32 Counter, u32 Timer)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XAxiDma_BdRingSetCoalesce           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Counter</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Timer</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set interrupt coalescing parameters for the given descriptor ring channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is a pointer to the descriptor ring instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Counter</em>&nbsp;</td><td>sets the packet counter on the channel. Valid range is<ul>
<li>1..255.</li><li>XAXIDMA_NO_CHANGE to leave this setting unchanged. </li></ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Timer</em>&nbsp;</td><td>sets the waitbound timer on the channel. Valid range is<ul>
<li>0..255.</li><li>XAXIDMA_NO_CHANGE to leave this setting unchanged. Each unit depend on hardware building parameter C_DLYTMR_RESOLUTION,which is in the range from 0 to 100,000 clock cycles. A value of 0 disables the delay interrupt.</li></ul>
</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if interrupt coalescing settings updated</li><li>XST_FAILURE if Counter or Timer parameters are out of range</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function can be used only when DMA is in SG mode </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="80d68862fd44c386c81a4e6b03d6c7a8"></a><!-- doxytag: member="xaxidma_bdring.c::XAxiDma_BdRingStart" ref="80d68862fd44c386c81a4e6b03d6c7a8" args="(XAxiDma_BdRing *RingPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XAxiDma_BdRingStart           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>RingPtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start a DMA channel, updates current descriptors and Allow DMA transactions to commence on a given channel if descriptors are ready to be processed.<p>
After a DMA channel is started, it is not halted, and it is idle (no active DMA transfers).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is the Channel instance to be worked on</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS upon success</li><li>XST_DMA_ERROR if no valid BD available to put into current BD register</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function can be used only when DMA is in SG mode </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4cd05c3aaa28683a66510cc065ddf949"></a><!-- doxytag: member="xaxidma_bdring.c::XAxiDma_BdRingToHw" ref="4cd05c3aaa28683a66510cc065ddf949" args="(XAxiDma_BdRing *RingPtr, int NumBd, XAxiDma_Bd *BdSetPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XAxiDma_BdRingToHw           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>NumBd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="xaxidma__bd_8h.html#afd3b643f4cd8899af5078d649f19a6f">XAxiDma_Bd</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>BdSetPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enqueue a set of BDs to hardware that were previously allocated by <a class="el" href="xaxidma__bdring_8c.html#1b2b817d9ba1981124a859a977934540">XAxiDma_BdRingAlloc()</a>. Once this function returns, the argument BD set goes under hardware control. Changes to these BDs should be held until they are finished by hardware to avoid data corruption and system instability.<p>
For transmit, the set will be rejected if the last BD of the set does not mark the end of a packet or the first BD does not mark the start of a packet.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is a pointer to the descriptor ring instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBd</em>&nbsp;</td><td>is the number of BDs in the set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdSetPtr</em>&nbsp;</td><td>is the first BD of the set to commit to hardware.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the set of BDs was accepted and enqueued to hardware</li><li>XST_INVALID_PARAM if passed in NumBd is negative</li><li>XST_FAILURE if the set of BDs was rejected because the first BD does not have its start-of-packet bit set, or the last BD does not have its end-of-packet bit set, or any one of the BDs has 0 length.</li><li>XST_DMA_SG_LIST_ERROR if this function was called out of sequence with <a class="el" href="xaxidma__bdring_8c.html#1b2b817d9ba1981124a859a977934540">XAxiDma_BdRingAlloc()</a></li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function should not be preempted by another <a class="el" href="struct_x_axi_dma.html">XAxiDma</a> ring function call that modifies the BD space. It is the caller's responsibility to provide a mutual exclusion mechanism.</dd></dl>
This function can be used only when DMA is in SG mode     </td>
  </tr>
</table>
<a class="anchor" name="592c2d0428c5a731b27071eac41ae77b"></a><!-- doxytag: member="xaxidma_bdring.c::XAxiDma_BdRingUnAlloc" ref="592c2d0428c5a731b27071eac41ae77b" args="(XAxiDma_BdRing *RingPtr, int NumBd, XAxiDma_Bd *BdSetPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XAxiDma_BdRingUnAlloc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>NumBd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="xaxidma__bd_8h.html#afd3b643f4cd8899af5078d649f19a6f">XAxiDma_Bd</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>BdSetPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fully or partially undo an <a class="el" href="xaxidma__bdring_8c.html#1b2b817d9ba1981124a859a977934540">XAxiDma_BdRingAlloc()</a> operation. Use this function if all the BDs allocated by <a class="el" href="xaxidma__bdring_8c.html#1b2b817d9ba1981124a859a977934540">XAxiDma_BdRingAlloc()</a> could not be transferred to hardware with <a class="el" href="xaxidma__bdring_8c.html#4cd05c3aaa28683a66510cc065ddf949">XAxiDma_BdRingToHw()</a>.<p>
This function releases the BDs after they have been allocated but before they have been given to hardware.<p>
This function is not the same as <a class="el" href="xaxidma__bdring_8c.html#b114dee6f9cd802c06893dfb267b9442">XAxiDma_BdRingFree()</a>. The Free function returns BDs to the free list after they have been processed by hardware, while UnAlloc returns them before being processed by hardware.<p>
There are two scenarios where this function can be used. Full UnAlloc or Partial UnAlloc. A Full UnAlloc means all the BDs Alloc'd will be returned:<p>
<pre>
    Status = XAxiDma_BdRingAlloc(MyRingPtr, 10, &amp;BdPtr);
        ...
        ...
    if (Error)
    {
        Status = XAxiDma_BdRingUnAlloc(MyRingPtr, 10, &amp;BdPtr);
    }
 </pre><p>
A partial UnAlloc means some of the BDs Alloc'd will be returned:<p>
<pre>
    Status = XAxiDma_BdRingAlloc(MyRingPtr, 10, &amp;BdPtr);
    BdsLeft = 10;
    CurBdPtr = BdPtr;</pre><p>
<pre>    while (BdsLeft)
    {
       if (Error)
       {
          Status = XAxiDma_BdRingUnAlloc(MyRingPtr, BdsLeft, CurBdPtr);
       }</pre><p>
<pre>       CurBdPtr = <a class="el" href="xaxidma__bdring_8h.html#39c795b29575a78496c33ac021016039">XAxiDma_BdRingNext(MyRingPtr, CurBdPtr)</a>;
       BdsLeft--;
    }
 </pre><p>
A partial UnAlloc must include the last BD in the list that was Alloc'd.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is a pointer to the descriptor ring instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBd</em>&nbsp;</td><td>is the number of BDs to unallocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdSetPtr</em>&nbsp;</td><td>points to the first of the BDs to be returned.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the BDs were unallocated.</li><li>XST_INVALID_PARAM if passed in NumBd is negative</li><li>XST_FAILURE if NumBd parameter was greater that the number of BDs in the preprocessing state.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function should not be preempted by another <a class="el" href="struct_x_axi_dma.html">XAxiDma</a> ring function call that modifies the BD space. It is the caller's responsibility to provide a mutual exclusion mechanism.</dd></dl>
This function can be used only when DMA is in SG mode     </td>
  </tr>
</table>
<a class="anchor" name="aa7f3bcecba09babb5e83f9a13088fed"></a><!-- doxytag: member="xaxidma_bdring.c::XAxiDma_StartBdRingHw" ref="aa7f3bcecba09babb5e83f9a13088fed" args="(XAxiDma_BdRing *RingPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XAxiDma_StartBdRingHw           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>RingPtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start a DMA channel and Allow DMA transactions to commence on a given channel if descriptors are ready to be processed.<p>
After a DMA channel is started, it is not halted, and it is idle (no active DMA transfers).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is the Channel instance to be worked on</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS upon success</li><li>XST_DMA_ERROR if no valid BD available to put into current BD register</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function can be used only when DMA is in SG mode </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="22499d05a91555f08fe9a95d134abcdb"></a><!-- doxytag: member="xaxidma_bdring.c::XAxiDma_UpdateBdRingCDesc" ref="22499d05a91555f08fe9a95d134abcdb" args="(XAxiDma_BdRing *RingPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XAxiDma_UpdateBdRingCDesc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_axi_dma___bd_ring.html">XAxiDma_BdRing</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>RingPtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Update Current Descriptor<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is the Channel instance to be worked on</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS upon success</li><li>XST_DMA_ERROR if no valid BD available to put into current BD register</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function can be used only when DMA is in SG mode </dd></dl>
    </td>
  </tr>
</table>
Copyright @ 1995-2014 Xilinx, Inc. All rights reserved. 
