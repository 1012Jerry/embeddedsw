<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   xqspipsu.c File Reference
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>xqspipsu.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
This file implements the functions required to use the QSPIPSU hardware to perform a transfer. These are accessible to the user via <a class="el" href="xqspipsu_8h.html">xqspipsu.h</a>.<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who Date     Changes
 ----- --- -------- -----------------------------------------------
 1.0   hk  08/21/14 First release
       sk  03/13/15 Added IO mode support.</pre><p>
<pre> </pre>
<p>
<code>#include &quot;<a class="el" href="xqspipsu_8h.html">xqspipsu.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu_8c.html#3c23b3bb935cf4238301444cdcc2e810">XQspiPsu_CfgInitialize</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *InstancePtr, <a class="el" href="struct_x_qspi_psu___config.html">XQspiPsu_Config</a> *ConfigPtr, u32 EffectiveAddr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu_8c.html#799b60ee7157ed46b84475677aa0dc03">XQspiPsu_Reset</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu_8c.html#aa69ec6da90deb760954ea3dcfd55d7f">XQspiPsu_Abort</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu_8c.html#17d058fa58b8599c1db27092f444d0d0">XQspiPsu_PolledTransfer</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *InstancePtr, <a class="el" href="struct_x_qspi_psu___msg.html">XQspiPsu_Msg</a> *Msg, unsigned NumMsg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu_8c.html#7c466797e1ee111cea006766a5547eee">XQspiPsu_InterruptTransfer</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *InstancePtr, <a class="el" href="struct_x_qspi_psu___msg.html">XQspiPsu_Msg</a> *Msg, unsigned NumMsg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu_8c.html#8a8f3a75fb4cb75c943245c7b9fccfd5">XQspiPsu_InterruptHandler</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu_8c.html#7b78484a0a6c8b30976a911a2a6c805a">XQspiPsu_SetStatusHandler</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *InstancePtr, void *CallBackRef, <a class="el" href="xqspipsu_8h.html#a8a9e7bc144fabb62eb6a2d3d2ec7b0e">XQspiPsu_StatusHandler</a> FuncPtr)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="aa69ec6da90deb760954ea3dcfd55d7f"></a><!-- doxytag: member="xqspipsu.c::XQspiPsu_Abort" ref="aa69ec6da90deb760954ea3dcfd55d7f" args="(XQspiPsu *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XQspiPsu_Abort           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Aborts a transfer in progress by<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="3c23b3bb935cf4238301444cdcc2e810"></a><!-- doxytag: member="xqspipsu.c::XQspiPsu_CfgInitialize" ref="3c23b3bb935cf4238301444cdcc2e810" args="(XQspiPsu *InstancePtr, XQspiPsu_Config *ConfigPtr, u32 EffectiveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XQspiPsu_CfgInitialize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu___config.html">XQspiPsu_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes a specific <a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> instance such that the driver is ready to use.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ConfigPtr</em>&nbsp;</td><td>is a reference to a structure containing information about a specific QSPIPSU device. This function initializes an InstancePtr object for a specific device specified by the contents of Config. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the device base address in the virtual memory address space. The caller is responsible for keeping the address mapping from EffectiveAddr to the device physical base address unchanged once this function is invoked. Unexpected errors may occur if the address mapping changes after this function is called. If address translation is not used, use ConfigPtr-&gt;Config.BaseAddress for this device.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XST_DEVICE_IS_STARTED if the device is already started. It must be stopped to re-initialize.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8a8f3a75fb4cb75c943245c7b9fccfd5"></a><!-- doxytag: member="xqspipsu.c::XQspiPsu_InterruptHandler" ref="8a8f3a75fb4cb75c943245c7b9fccfd5" args="(XQspiPsu *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XQspiPsu_InterruptHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Handles interrupt based transfers by acting on GENFIFO and DMA interurpts.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XST_FAILURE if transfer fails.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7c466797e1ee111cea006766a5547eee"></a><!-- doxytag: member="xqspipsu.c::XQspiPsu_InterruptTransfer" ref="7c466797e1ee111cea006766a5547eee" args="(XQspiPsu *InstancePtr, XQspiPsu_Msg *Msg, unsigned NumMsg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XQspiPsu_InterruptTransfer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu___msg.html">XQspiPsu_Msg</a> *&nbsp;</td>
          <td class="paramname"> <em>Msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>NumMsg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function initiates a transfer on the bus and enables interrupts. The transfer is completed by the interrupt handler. The messages passed are all transferred on the bus between one CS assert and de-assert.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Msg</em>&nbsp;</td><td>is a pointer to the structure containing transfer data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumMsg</em>&nbsp;</td><td>is the number of messages to be transferred.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XST_FAILURE if transfer fails.</li><li>XST_DEVICE_BUSY if a transfer is already in progress.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="17d058fa58b8599c1db27092f444d0d0"></a><!-- doxytag: member="xqspipsu.c::XQspiPsu_PolledTransfer" ref="17d058fa58b8599c1db27092f444d0d0" args="(XQspiPsu *InstancePtr, XQspiPsu_Msg *Msg, unsigned NumMsg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XQspiPsu_PolledTransfer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu___msg.html">XQspiPsu_Msg</a> *&nbsp;</td>
          <td class="paramname"> <em>Msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>NumMsg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function performs a transfer on the bus in polled mode. The messages passed are all transferred on the bus between one CS assert and de-assert.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Msg</em>&nbsp;</td><td>is a pointer to the structure containing transfer data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumMsg</em>&nbsp;</td><td>is the number of messages to be transferred.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XST_FAILURE if transfer fails.</li><li>XST_DEVICE_BUSY if a transfer is already in progress.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="799b60ee7157ed46b84475677aa0dc03"></a><!-- doxytag: member="xqspipsu.c::XQspiPsu_Reset" ref="799b60ee7157ed46b84475677aa0dc03" args="(XQspiPsu *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XQspiPsu_Reset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resets the QSPIPSU device. Reset must only be called after the driver has been initialized. Any data transfer that is in progress is aborted.<p>
The upper layer software is responsible for re-configuring (if necessary) and restarting the QSPIPSU device after the reset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7b78484a0a6c8b30976a911a2a6c805a"></a><!-- doxytag: member="xqspipsu.c::XQspiPsu_SetStatusHandler" ref="7b78484a0a6c8b30976a911a2a6c805a" args="(XQspiPsu *InstancePtr, void *CallBackRef, XQspiPsu_StatusHandler FuncPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XQspiPsu_SetStatusHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xqspipsu_8h.html#a8a9e7bc144fabb62eb6a2d3d2ec7b0e">XQspiPsu_StatusHandler</a>&nbsp;</td>
          <td class="paramname"> <em>FuncPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the status callback function, the status handler, which the driver calls when it encounters conditions that should be reported to upper layer software. The handler executes in an interrupt context, so it must minimize the amount of processing performed. One of the following status events is passed to the status handler.<p>
<pre></pre><p>
<pre> XST_SPI_TRANSFER_DONE		The requested data transfer is done</pre><p>
<pre> XST_SPI_TRANSMIT_UNDERRUN	As a slave device, the master clocked data
				but there were none available in the transmit
				register/FIFO. This typically means the slave
				application did not issue a transfer request
				fast enough, or the processor/driver could not
				fill the transmit register/FIFO fast enough.</pre><p>
<pre> XST_SPI_RECEIVE_OVERRUN	The QSPIPSU device lost data. Data was received
				but the receive data register/FIFO was full.</pre><p>
<pre> </pre> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the upper layer callback reference passed back when the callback function is invoked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FuncPtr</em>&nbsp;</td><td>is the pointer to the callback function.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
The handler is called within interrupt context, so it should do its work quickly and queue potentially time-consuming work to a task-level thread.
</div>
</div><p>
Copyright @ 1995-2014 Xilinx, Inc. All rights reserved.
